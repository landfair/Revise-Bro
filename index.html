<!DOCTYPE html>
<html lang="en">
<head>
    
    <meta charset="UTF-8">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2pdf.js/0.10.1/html2pdf.bundle.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mammoth/1.6.0/mammoth.browser.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jsdiff/5.1.0/diff.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/diff-match-patch@1.0.5/index.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/fast-diff@1.3.0/diff.min.js"></script>
    <script src="https://unpkg.com/difflib@0.2.4/difflib-browser.js"></script>
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document Comparison Tool</title>
    <style>

.header {
    background-color: var(--header-background);
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08);
    padding: 16px 30px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    position: relative;
    top: 0;
    z-index: 100;
    transition: background-color 0.3s ease;
}

.header-title {
    flex-grow: 1;
    min-width: 0;
    text-align: center;
}

.header-title h1 {
    font-size: 2rem; /* Smaller than the original 2.8rem */
    background: var(--primary-gradient);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
    background-clip: text;
    text-fill-color: transparent;
    margin: 0; /* Remove margins */
    font-weight: 700;
    letter-spacing: -0.03em;
    line-height: 1.2;
}

.header-buttons {
    display: flex;
    gap: 15px;
    align-items: center;
    flex-shrink: 0;
}


/* Button Base Styles */
.about-btn {
    background-color: var(--card-background);
    color: var(--primary-color);
    border: 2px solid var(--primary-color);
    border-radius: var(--radius-full);
    padding: 10px 20px;
    font-size: var(--font-size-sm);
    font-weight: 600;
    cursor: pointer;
    transition: all var(--transition-base);
    box-shadow: var(--shadow-sm);
}

.about-btn:hover {
    background-color: var(--primary-color);
    color: white;
    transform: translateY(-2px);
    box-shadow: var(--shadow-md);
}

.about-btn:active {
    transform: translateY(0);
    box-shadow: var(--shadow-sm);
}

.new-comparison-btn {
    background: var(--primary-gradient);
    color: white;
    border: none;
    border-radius: var(--radius-full);
    padding: 12px 28px;
    font-size: var(--font-size-base);
    font-weight: 600;
    cursor: pointer;
    transition: all var(--transition-base);
    margin-right: var(--space-md);
    box-shadow: var(--shadow-md);
    position: relative;
    overflow: hidden;
}

.new-comparison-btn::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: linear-gradient(135deg, rgba(255,255,255,0.1) 0%, rgba(255,255,255,0) 100%);
    opacity: 0;
    transition: opacity var(--transition-base);
}

.new-comparison-btn:hover {
    transform: translateY(-2px);
    box-shadow: var(--shadow-lg);
}

.new-comparison-btn:hover::before {
    opacity: 1;
}

.new-comparison-btn:active {
    transform: translateY(0);
    box-shadow: var(--shadow-md);
}

        .hidden {
            display: none !important;
        }
        
       
        
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.4);
        }
        
        .modal-content {
            background-color: var(--modal-background);
            margin: 5% auto;
            padding: 20px;
            border: 1px solid var(--border-color);
            width: 80%;
            border-radius: var(--border-radius);
            box-shadow: var(--shadow);
            transition: background-color 0.3s ease, color 0.3s ease;
            color: var(--text-color);
        }

        .modal-content h3,
        .modal-content p,
        .modal-content div {
            color: var(--text-color);
        }

        .modal-content strong {
            color: var(--text-color);
        }
        
        .modal-close {
            color: #aaa;
            float: right;
            font-size: 28px;
            font-weight: bold;
            cursor: pointer;
            transition: color 0.3s ease;
        }

        .modal-close:hover,
        .modal-close:focus {
            color: var(--text-color);
            text-decoration: none;
            cursor: pointer;
        }

        body.night-mode .modal-close {
            color: #999;
        }

        body.night-mode .modal-close:hover,
        body.night-mode .modal-close:focus {
            color: var(--text-color);
        }
        :root {
            /* NYU Official Brand Colors */
            --primary-color: #57068c;        /* NYU Violet (Primary) */
            --primary-dark: #330662;         /* Deep Violet */
            --primary-light: #702b9d;        /* Medium Violet 1 */
            --primary-gradient: linear-gradient(135deg, #702b9d 0%, #57068c 100%);

            /* Neutral Colors - NYU Official */
            --text-primary: #404040;         /* Dark Gray */
            --text-secondary: #6d6d6d;       /* Medium Gray 1 */
            --text-tertiary: #b8b8b8;        /* Medium Gray 2 */
            --background-color: #f2f2f2;     /* Light Gray */
            --card-background: #ffffff;      /* White */
            --header-background: #ffffff;    /* White */
            --modal-background: #ffffff;     /* White */
            --input-background: #ffffff;     /* White */

            /* Accent Colors - NYU Purple Tints */
            --accent-purple-light: #7b5aa6;     /* Medium Violet 2 */
            --accent-purple-lighter: #ab82c5;   /* Light Violet 1 */
            --accent-purple-lightest: #eee6f3; /* Light Violet 2 */

            /* Semantic Colors - Purple-tinted */
            --addition-bg: #e8f0ec;
            --addition-text: #2d5f3f;
            --addition-border: #5a9d73;
            --addition-accent: #7cb899;
            --deletion-bg: #fceef2;
            --deletion-text: #8c2d4a;
            --deletion-border: #c76581;
            --deletion-accent: #d68599;

            /* UI Elements */
            --border-color: #e4e0eb;
            --border-color-strong: #c8c0d6;
            --card-border: 1px solid rgba(230, 225, 240, 0.8);
            --diff-panel-bg: #fafafe;
            --diff-legend-bg: #f8f7fb;
            --nav-info-bg: rgba(255, 255, 255, 0.95);
            --spinner-bg: rgba(255, 255, 255, 0.95);

            /* Restore Banner - NYU Purple Theme */
            --restore-banner-bg: linear-gradient(135deg, #eee6f3 0%, #ab82c5 100%);
            --restore-banner-border: #57068c;
            --restore-banner-heading: #330662;
            --restore-banner-text: #57068c;
            --restore-btn-bg: #57068c;
            --restore-btn-bg-hover: #330662;
            --dismiss-btn-bg: #ffffff;
            --dismiss-btn-text: #57068c;
            --dismiss-btn-border: #57068c;
            --dismiss-btn-bg-hover: #eee6f3;

            /* Spacing Scale */
            --space-xs: 4px;
            --space-sm: 8px;
            --space-md: 16px;
            --space-lg: 24px;
            --space-xl: 32px;
            --space-2xl: 48px;

            /* Typography */
            --font-primary: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
            --font-size-sm: 0.875rem;
            --font-size-base: 1rem;
            --font-size-lg: 1.125rem;
            --font-size-xl: 1.25rem;
            --font-size-2xl: 1.5rem;
            --font-size-3xl: 2rem;
            --line-height-tight: 1.25;
            --line-height-normal: 1.5;
            --line-height-relaxed: 1.75;

            /* Border Radius */
            --radius-sm: 6px;
            --radius-md: 10px;
            --radius-lg: 14px;
            --radius-xl: 20px;
            --radius-full: 9999px;

            /* Shadows - Refined Elevation */
            --shadow-sm: 0 2px 8px rgba(87, 6, 140, 0.08);
            --shadow-md: 0 4px 16px rgba(87, 6, 140, 0.12);
            --shadow-lg: 0 8px 24px rgba(87, 6, 140, 0.16);
            --shadow-xl: 0 16px 48px rgba(87, 6, 140, 0.2);

            /* Transitions */
            --transition-fast: 150ms cubic-bezier(0.4, 0, 0.2, 1);
            --transition-base: 250ms cubic-bezier(0.4, 0, 0.2, 1);
            --transition-slow: 350ms cubic-bezier(0.4, 0, 0.2, 1);
            --transition-bounce: 500ms cubic-bezier(0.34, 1.56, 0.64, 1);

            /* Legacy Support - Map to new system */
            --text-color: var(--text-primary);
            --secondary-color: var(--accent-purple-lightest);
            --accent-light: var(--accent-purple-light);
            --accent-lighter: var(--accent-purple-lighter);
            --border-radius: var(--radius-md);
            --border-radius-sm: var(--radius-sm);
            --shadow: var(--shadow-md);
            --transition-standard: var(--transition-base);
        }

        body.night-mode {
            /* NYU Brand Colors - Night Mode */
            --primary-color: #ab82c5;        /* Light Violet 1 (lightened for dark mode) */
            --primary-dark: #7b5aa6;         /* Medium Violet 2 */
            --primary-light: #eee6f3;        /* Light Violet 2 */
            --primary-gradient: linear-gradient(135deg, #ab82c5 0%, #7b5aa6 100%);

            /* Neutral Colors - NYU Dark Theme */
            --text-primary: #f2f2f2;         /* Light Gray */
            --text-secondary: #d6d6d6;       /* Medium Gray 3 */
            --text-tertiary: #b8b8b8;        /* Medium Gray 2 */
            --background-color: #1a1825;
            --card-background: #252335;
            --header-background: #1f1d2e;
            --modal-background: #252335;
            --input-background: #2d2b3d;

            /* Accent Colors - NYU Night Purple Tints */
            --accent-purple-light: #ab82c5;     /* Light Violet 1 */
            --accent-purple-lighter: #7b5aa6;   /* Medium Violet 2 */
            --accent-purple-lightest: #702b9d;  /* Medium Violet 1 (darker for dark mode backgrounds) */

            /* Semantic Colors - Night Mode Purple-tinted */
            --addition-bg: #263d30;
            --addition-text: #8fc9a5;
            --addition-border: #6ab387;
            --addition-accent: #7cb899;
            --deletion-bg: #3d2630;
            --deletion-text: #e6a1b5;
            --deletion-border: #d68599;
            --deletion-accent: #c76581;

            /* UI Elements - Dark */
            --border-color: #3a3848;
            --border-color-strong: #4d4b5c;
            --card-border: 1px solid rgba(106, 85, 120, 0.3);
            --diff-panel-bg: #2d2b3d;
            --diff-legend-bg: #2d2b3d;
            --nav-info-bg: rgba(37, 35, 53, 0.95);
            --spinner-bg: rgba(26, 24, 37, 0.95);

            /* Restore Banner - NYU Night Purple Theme */
            --restore-banner-bg: linear-gradient(135deg, #330662 0%, #57068c 100%);
            --restore-banner-border: #ab82c5;
            --restore-banner-heading: #eee6f3;
            --restore-banner-text: #d6d6d6;
            --restore-btn-bg: #ab82c5;
            --restore-btn-bg-hover: #7b5aa6;
            --dismiss-btn-bg: #2d2b3d;
            --dismiss-btn-text: #eee6f3;
            --dismiss-btn-border: #ab82c5;
            --dismiss-btn-bg-hover: #702b9d;

            /* Shadows - Enhanced for Dark Mode */
            --shadow-sm: 0 2px 8px rgba(0, 0, 0, 0.4);
            --shadow-md: 0 4px 16px rgba(0, 0, 0, 0.5);
            --shadow-lg: 0 8px 24px rgba(0, 0, 0, 0.6);
            --shadow-xl: 0 16px 48px rgba(0, 0, 0, 0.7);

            /* Legacy Support */
            --text-color: var(--text-primary);
            --secondary-color: var(--accent-purple-lightest);
            --accent-light: var(--accent-purple-light);
            --accent-lighter: var(--accent-purple-lighter);
            --shadow: var(--shadow-md);
        }

        .panel-content {
    white-space: pre-wrap;
    word-wrap: break-word;
    overflow-wrap: break-word;
    line-height: 1.8;
    font-size: 1.1rem;
    text-align: left;  /* <-- FIXED */
    max-width: 85%;
    width: 85%;
    margin: 0 auto;
}
        
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: var(--font-primary);
            background: var(--background-color);
            color: var(--text-primary);
            font-size: var(--font-size-base);
            line-height: var(--line-height-normal);
            margin: 0;
            padding: 0;
            transition: background-color var(--transition-base), color var(--transition-base);
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }

        input[type="text"], textarea {
            background-color: var(--input-background);
            color: var(--text-primary);
            border: 2px solid var(--border-color);
            border-radius: var(--radius-sm);
            font-family: var(--font-primary);
            font-size: var(--font-size-base);
            transition: background-color var(--transition-base),
                        color var(--transition-base),
                        border-color var(--transition-base),
                        box-shadow var(--transition-base);
        }

        input[type="text"]:focus, textarea:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 3px rgba(87, 6, 140, 0.1);
        }

        .container {
            max-width: 1300px;
            margin: 0 auto;
            padding: var(--space-xl) var(--space-lg) 80px;
        }

        h1 {
            font-size: var(--font-size-3xl);
            background: var(--primary-gradient);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: var(--space-2xl);
            text-align: center;
            font-weight: 700;
            letter-spacing: -0.03em;
            line-height: var(--line-height-tight);
        }

        h2 {
            font-size: var(--font-size-2xl);
            color: var(--primary-dark);
            font-weight: 700;
            margin-bottom: var(--space-lg);
            letter-spacing: -0.02em;
        }

        h3 {
            font-size: var(--font-size-xl);
            color: var(--primary-color);
            font-weight: 600;
            margin-bottom: var(--space-md);
        }

        p {
            color: var(--text-secondary);
            line-height: var(--line-height-relaxed);
            margin-bottom: var(--space-md);
        }
        
        .upload-section {
            background-color: var(--card-background);
            margin-bottom: var(--space-2xl);
            padding: var(--space-2xl);
            border-radius: var(--radius-lg);
            box-shadow: var(--shadow-md);
            border: var(--card-border);
            position: relative;
            overflow: hidden;
            transition: background-color var(--transition-base),
                        box-shadow var(--transition-base);
        }

        .upload-section:hover {
            box-shadow: var(--shadow-lg);
        }
        
        .upload-section::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 5px;
            background: var(--primary-gradient);
        }
        
        .tab-container {
            display: flex;
            margin-bottom: var(--space-xl);
            border-bottom: 2px solid var(--border-color);
            gap: var(--space-sm);
        }

        .tab-btn {
            background: none;
            border: none;
            padding: var(--space-md) var(--space-xl);
            font-size: var(--font-size-lg);
            font-weight: 600;
            cursor: pointer;
            color: var(--text-secondary);
            border-bottom: 3px solid transparent;
            transition: all var(--transition-base);
            margin: 0;
            display: inline-block;
            box-shadow: none;
            border-radius: var(--radius-sm) var(--radius-sm) 0 0;
        }

        .tab-btn:hover {
            color: var(--primary-color);
            background-color: var(--accent-purple-lightest);
        }

        .tab-btn.active {
            color: var(--primary-color);
            border-bottom-color: var(--primary-color);
            background-color: var(--accent-purple-lightest);
        }
        
        .tab-content {
            display: none;
        }
        
        .tab-content.active {
            display: block;
        }
        
        .examples-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: var(--space-lg);
            margin-top: var(--space-lg);
        }

        .example-card {
            background: var(--card-background);
            border: var(--card-border);
            border-radius: var(--radius-lg);
            padding: var(--space-xl);
            box-shadow: var(--shadow-sm);
            transition: all var(--transition-slow);
            position: relative;
            overflow: hidden;
            cursor: pointer;
        }

        .example-card:hover {
            transform: translateY(-4px);
            box-shadow: var(--shadow-lg);
        }
        
        .example-card::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 4px;
            background: var(--primary-gradient);
        }
        
        .example-card h4 {
            font-size: var(--font-size-xl);
            color: var(--primary-dark);
            margin-bottom: var(--space-sm);
            font-weight: 700;
        }

        .example-author {
            font-size: var(--font-size-sm);
            color: var(--accent-purple-light);
            font-weight: 600;
            margin-bottom: var(--space-md);
            font-style: italic;
        }

        .example-description {
            color: var(--text-secondary);
            line-height: var(--line-height-relaxed);
            margin-bottom: var(--space-lg);
            font-size: var(--font-size-sm);
        }

        .example-btn {
            background: var(--primary-gradient);
            color: white;
            border: none;
            border-radius: var(--radius-full);
            padding: 12px 24px;
            font-size: var(--font-size-base);
            font-weight: 600;
            cursor: pointer;
            transition: all var(--transition-base);
            width: 100%;
            box-shadow: var(--shadow-sm);
            margin: 0;
            display: block;
            position: relative;
            overflow: hidden;
        }

        .example-btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(135deg, rgba(255,255,255,0.15) 0%, rgba(255,255,255,0) 100%);
            opacity: 0;
            transition: opacity var(--transition-base);
        }

        .example-btn:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-md);
        }

        .example-btn:hover::before {
            opacity: 1;
        }

        .example-btn:active {
            transform: translateY(0);
            box-shadow: var(--shadow-sm);
        }

        /* Hover tooltips for extra guidance */
.upload-icon::after {
    content: attr(data-tooltip);
    position: absolute;
    bottom: -40px;
    left: 50%;
    transform: translateX(-50%);
    background: rgba(0, 0, 0, 0.8);
    color: white;
    padding: 5px 10px;
    border-radius: 5px;
    font-size: 0.85rem;
    white-space: nowrap;
    opacity: 0;
    pointer-events: none;
    transition: opacity 0.3s;
}

.file-input-container:hover .upload-icon::after {
    opacity: 1;
}
        
        .error {
            background-color: #fce8ea;
            color: #721c24;
            font-weight: 500;
            padding: 20px;
            border-radius: var(--border-radius);
            margin-bottom: 30px;
            box-shadow: var(--shadow);
            border-left: 5px solid #d9534f;
        }
        
        .comparison-viewport {
            position: relative;
            width: 100%;
            overflow: hidden;
            height: 700px;
            border-radius: var(--border-radius);
            box-shadow: var(--shadow);
            border: var(--card-border);
            background-color: var(--card-background);
            transition: background-color 0.3s ease;
        }
        
        .comparison-slider {
            display: flex;
            height: 100%;
            transition: transform 0.6s cubic-bezier(0.22, 1, 0.36, 1);
        }
        
        .panel {
            width: 90%;
            min-width: 100%;
            max-width: 90%;
            height: 100%;
            padding: 30px 25px; /* Reduced from 40px to 25px on sides */
            background-color: var(--card-background);
            overflow-y: auto;
            flex-shrink: 0;
            box-sizing: border-box;
            transition: background-color 0.3s ease;
        }

        .nav-arrow.left {
            left: 0px;
        }

        .nav-arrow.right {
            right: 5px;
        }
        
        .panel.diff-panel {
            background-color: var(--diff-panel-bg);
            transition: background-color 0.3s ease;
        }

        .diff-header h3 {
            margin-bottom: 0;
            flex-grow: 1;
        }

@media (max-width: 768px) {
    .header {
        flex-direction: column;
        gap: 15px;
        padding: 20px 15px;
    }
    
    .header-title h1 {
        font-size: 1.8rem;
    }
    
    .logo-container {
        height: 35px;
    }
    
    .header-buttons {
        width: 100%;
        justify-content: center;
    }
    
    .options-dropdown-menu {
        right: auto;
        left: 50%;
        transform: translateX(-50%);
    }
}
        
        .nav-arrow {
            position: absolute;
            top: 50%;
            transform: translateY(-50%);
            width: 60px;
            height: 60px;
            border-radius: 50%;
            background: var(--primary-gradient);
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            font-size: 1.6rem;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.15);
            z-index: 10;
            transition: var(--transition-standard);
        }
        
        .logo-container {
    height: 80px; /* Much smaller than before */
    display: flex;
    align-items: center;
    flex-shrink: 0;
}

.logo-container img {
    height: 100%;
    max-width: 240px; /* Limit width too */
    object-fit: contain;
}

.loading-spinner {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: var(--spinner-bg);
    display: none;
    justify-content: center;
    align-items: center;
    z-index: 9999;
    backdrop-filter: blur(2px);
    transition: background-color 0.3s ease;
}

.spinner {
    width: 50px;
    height: 50px;
    border: 4px solid var(--accent-lighter);
    border-top: 4px solid var(--primary-color);
    border-radius: 50%;
    animation: spin 1s linear infinite;
}

.spinner-text {
    margin-top: 20px;
    color: var(--primary-dark);
    font-weight: 600;
    font-size: 1.1rem;
}

@keyframes spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
}


       
        
        .nav-arrow:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }
        
        .navigation-info {
            display: none; /* Hidden per user request */
            position: absolute;
            top: 20px;
            right: 20px;
            background: var(--nav-info-bg);
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 0.9rem;
            font-weight: 600;
            color: var(--primary-dark);
            z-index: 5;
            backdrop-filter: blur(10px);
            transition: background-color 0.3s ease;
        }
        
       /* Deletion styles */
.deletion {
    background-color: var(--deletion-bg);
    color: var(--deletion-text);
    text-decoration: line-through;
    padding: 2px 4px;
    border-radius: 3px;
    border-left: 3px solid var(--deletion-border);
    transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease;
}

.diff-legend {
    margin-bottom: 20px;
    padding: 10px;
    background: var(--diff-legend-bg);
    border-radius: 5px;
    font-size: 0.9rem;
    transition: background-color 0.3s ease;
}

.legend-item {
    margin-right: 20px;
    display: inline-block;
}

/* Addition styles */
.addition {
    background-color: var(--addition-bg);
    color: var(--addition-text);
    text-decoration: none;
    padding: 2px 4px;
    border-radius: 3px;
    border-left: 3px solid var(--addition-border);
    transition: background-color 0.3s ease, color 0.3s ease, border-color 0.3s ease;
}

/* Level-specific styling */
.char-level {
    font-weight: 600;
    border-width: 1px;
}

.word-level {
    font-weight: 500;
    border-width: 2px;
}

.phrase-level {
    font-weight: 500;
    border-width: 2px;
    margin: 0 1px;
}

.sentence-level {
    font-weight: 400;
    border-width: 3px;
    margin: 2px 0;
    display: inline-block;
}


        .upload-area {
    text-align: center;
}

.file-input-container {
    border: 3px dashed var(--accent-light);
    border-radius: var(--border-radius);
    padding: 40px 20px;
    margin-bottom: 20px;
    transition: var(--transition-standard);
    cursor: pointer;
}

.file-input-container:hover {
    border-color: var(--primary-color);
    background-color: rgba(87, 6, 140, 0.02);
}

.upload-icon {
    font-size: 3rem;
    margin-bottom: 15px;
}

.upload-text strong {
    font-size: 1.2rem;
    color: var(--primary-dark);
    display: block;
    margin-bottom: 8px;
}

.upload-text p {
    color: var(--accent-light);
    margin: 0;
}

.file-list {
    background: var(--secondary-color);
    border-radius: var(--border-radius-sm);
    padding: 20px;
    margin-bottom: 20px;
    text-align: left;
}

.file-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 10px 0;
    border-bottom: 1px solid var(--border-color);
}

.file-item:last-child {
    border-bottom: none;
}

.file-name {
    font-weight: 600;
    color: var(--primary-dark);
}

.file-size {
    color: var(--accent-light);
    font-size: 0.9rem;
}

.remove-file {
    background: #dc3545;
    color: white;
    border: none;
    border-radius: 50%;
    width: 25px;
    height: 25px;
    cursor: pointer;
    font-size: 0.8rem;
}

.compare-btn {
    background: var(--primary-gradient);
    color: white;
    border: none;
    border-radius: var(--radius-full);
    padding: var(--space-md) var(--space-xl);
    font-size: var(--font-size-lg);
    font-weight: 600;
    cursor: pointer;
    transition: all var(--transition-base);
    box-shadow: var(--shadow-md);
    position: relative;
    overflow: hidden;
}

.compare-btn::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: linear-gradient(135deg, rgba(255,255,255,0.15) 0%, rgba(255,255,255,0) 100%);
    opacity: 0;
    transition: opacity var(--transition-base);
}

.compare-btn:hover {
    transform: translateY(-2px);
    box-shadow: var(--shadow-lg);
}

.compare-btn:hover::before {
    opacity: 1;
}

.compare-btn:active {
    transform: translateY(0);
    box-shadow: var(--shadow-md);
}

@media (max-width: 768px) {
    .header {
        flex-direction: column;
        gap: 15px;
        padding: 20px 15px;
    }
    
    .header-title h1 {
        font-size: 1.8rem;
    }
    
    .logo-container {
        height: 35px;
    }
    
    .header-buttons {
        width: 100%;
        justify-content: center;
    }
}

@media (max-width: 768px) {
    .panel {
        padding: 25px 20px; /* Even tighter on mobile */
    }
    
    .nav-arrow.left {
        left: 10px;
    }
    
    .nav-arrow.right {
        right: 10px;
    }
}

/* Modal Styles */
.modal {
    display: none;
    position: fixed;
    z-index: 1000;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    overflow: auto;
    background-color: rgba(0, 0, 0, 0.5);
    backdrop-filter: blur(4px);
}

.modal-content {
    background-color: white;
    margin: 7% auto;
    padding: 40px;
    border-radius: var(--border-radius);
    box-shadow: 0 15px 50px rgba(0, 0, 0, 0.25);
    width: 80%;
    max-width: 700px;
    animation: fadeIn 0.4s;
    position: relative;
}

.modal-content::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 5px;
    background: var(--primary-gradient);
    border-top-left-radius: var(--border-radius);
    border-top-right-radius: var(--border-radius);
}

.modal-close {
    position: absolute;
    top: 15px;
    right: 15px;
    color: #777;
    font-size: 28px;
    font-weight: bold;
    cursor: pointer;
    transition: var(--transition-standard);
    height: 40px;
    width: 40px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 50%;
    background-color: #f5f5fa;
}

.modal-close:hover {
    color: var(--primary-dark);
    background-color: var(--accent-lighter);
    transform: rotate(90deg);
}

@keyframes fadeIn {
    from { opacity: 0; transform: translateY(10px); }
    to { opacity: 1; transform: translateY(0); }
}

.modal-content h3 {
    color: var(--primary-color);
    margin-top: 25px;
    margin-bottom: 15px;
    font-size: 1.3rem;
    border-bottom: 1px solid var(--accent-lighter);
    padding-bottom: 8px;
}

.modal-content h4 {
    color: var(--primary-dark);
    margin-top: 20px;
    margin-bottom: 10px;
    font-size: 1.1rem;
    font-weight: 600;
}

.modal-content ul {
    margin-left: 20px;
    margin-bottom: 15px;
}

.modal-content li {
    margin-bottom: 8px;
    line-height: 1.5;
}

.modal-content li strong {
    color: var(--primary-dark);
}

.citation {
    margin-top: 30px;
    padding: 15px;
    background-color: var(--secondary-color);
    border-left: 4px solid var(--primary-color);
    font-size: 0.9rem;
    font-style: italic;
}

.report-container {
    background: white;
    border-radius: var(--border-radius);
    padding: 30px;
    margin: 30px 0;
    box-shadow: var(--shadow);
    border: var(--card-border);
}

.report-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 25px;
    padding-bottom: 15px;
    border-bottom: 2px solid var(--border-color);
}

.report-title {
    font-size: 1.8rem;
    color: var(--primary-dark);
    font-weight: 700;
}

.report-toggle {
    display: flex;
    gap: 10px;
}

.toggle-btn {
    background: white;
    color: var(--primary-color);
    border: 2px solid var(--primary-color);
    border-radius: 20px;
    padding: 8px 16px;
    font-size: 0.9rem;
    font-weight: 600;
    cursor: pointer;
    transition: var(--transition-standard);
}

.toggle-btn.active {
    background: var(--primary-gradient);
    color: white;
    border-color: transparent;
}

.revision-table {
    width: 100%;
    border-collapse: collapse;
    margin-top: 20px;
}

.revision-table th {
    background: var(--primary-gradient);
    color: white;
    padding: 12px;
    text-align: left;
    font-weight: 600;
}

.revision-table td {
    padding: 10px 12px;
    border: 1px solid var(--border-color);
    text-align: center;
}

.revision-table tr:nth-child(even) {
    background-color: #f8f9fa;
}

.revision-table .row-label {
    font-weight: 600;
    background-color: #f0ecf8;
    text-align: left;
}

.total-row {
    background-color: #e5e1ea !important;
    font-weight: 700;
}

.detail-list {
    max-height: 400px;
    overflow-y: auto;
    padding: 20px;
    background: #f8f9fa;
    border-radius: var(--border-radius-sm);
}

.revision-category {
    margin-bottom: 25px;
}

.category-title {
    font-size: 1.2rem;
    color: var(--primary-dark);
    font-weight: 600;
    margin-bottom: 10px;
    padding-bottom: 5px;
    border-bottom: 2px solid var(--accent-light);
}

.revision-item {
    margin: 8px 0;
    padding: 8px;
    background: white;
    border-radius: 5px;
    border-left: 3px solid var(--accent-light);
}

.revision-item.addition {
    border-left-color: #66bb6a;
}

.revision-item.deletion {
    border-left-color: #ef5350;
}


.revision-text {
    font-family: 'Courier New', monospace;
    font-size: 0.9rem;
    color: #555;
    margin-top: 5px;
    padding: 5px;
    background: #f5f5f5;
    border-radius: 3px;
    word-break: break-word;
}

.stats-summary {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 20px;
    margin: 20px 0;
}

.stat-card {
    background: white;
    padding: 15px;
    border-radius: var(--border-radius-sm);
    border: 1px solid var(--border-color);
    text-align: center;
}

.stat-number {
    font-size: 2rem;
    font-weight: 700;
    color: var(--primary-color);
}

.stat-label {
    color: var(--text-color);
    font-size: 0.9rem;
    margin-top: 5px;
}

.generate-report-btn {
    background: var(--primary-gradient);
    color: white;
    border: none;
    border-radius: 25px;
    padding: 12px 24px;
    font-size: 1rem;
    font-weight: 600;
    cursor: pointer;
    transition: var(--transition-standard);
    margin: 20px auto;
    display: block;
    box-shadow: 0 3px 10px rgba(87, 6, 140, 0.2);
}

.generate-report-btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 5px 15px rgba(87, 6, 140, 0.3);
}

/* Annotation Styles */
.annotatable {
    cursor: pointer;
    position: relative;
}

.annotatable:hover {
    background-color: rgba(87, 6, 140, 0.1) !important;
    box-shadow: 0 0 0 2px rgba(87, 6, 140, 0.3);
}

/* Find and REPLACE the .has-annotation styles */
.has-annotation {
    border-bottom: 3px solid var(--primary-color);
    background-color: rgba(87, 6, 140, 0.08);
    padding: 2px 4px;
    border-radius: 3px;
    box-shadow: 0 0 0 2px rgba(87, 6, 140, 0.15);
}

.has-annotation::after {
    content: 'ðŸ“';
    font-size: 1em;
    margin-left: 6px;
    opacity: 0.9;
    vertical-align: middle;
}

/* Add this new CSS rule for animation */
@keyframes annotationPulse {
    0%, 100% {
        box-shadow: 0 0 0 2px rgba(87, 6, 140, 0.15);
    }
    50% {
        box-shadow: 0 0 0 4px rgba(87, 6, 140, 0.25);
    }
}

.has-annotation {
    border-bottom: 3px solid var(--primary-color);
    background-color: rgba(87, 6, 140, 0.08);
    padding: 2px 4px;
    border-radius: 3px;
    box-shadow: 0 0 0 2px rgba(87, 6, 140, 0.15);
    animation: annotationPulse 2s ease-in-out infinite;
}

.has-annotation::after {
    content: 'ðŸ“';
    font-size: 1em;
    margin-left: 6px;
    opacity: 0.9;
    vertical-align: middle;
}

.annotation-popup {
    position: fixed;
    background: white;
    border: 2px solid var(--primary-color);
    border-radius: var(--border-radius);
    padding: 20px;
    box-shadow: 0 8px 30px rgba(0, 0, 0, 0.2);
    z-index: 2000;
    max-width: 400px;
    min-width: 300px;
}

.annotation-popup h4 {
    margin: 0 0 15px 0;
    color: var(--primary-dark);
    font-size: 1.1rem;
}

.annotation-popup textarea {
    width: 100%;
    min-height: 100px;
    padding: 10px;
    border: 1px solid var(--border-color);
    border-radius: var(--border-radius-sm);
    font-family: var(--font-primary);
    font-size: 0.95rem;
    resize: vertical;
    background-color: var(--input-background);
    color: var(--text-color);
    transition: background-color 0.3s ease, color 0.3s ease;
}

.annotation-popup-buttons {
    display: flex;
    gap: 10px;
    margin-top: 15px;
}

.annotation-save-btn, .annotation-cancel-btn, .annotation-delete-btn {
    padding: 8px 16px;
    border: none;
    border-radius: 20px;
    cursor: pointer;
    font-weight: 600;
    font-size: 0.9rem;
    transition: var(--transition-standard);
}

.annotation-save-btn {
    background: var(--primary-gradient);
    color: white;
    flex: 1;
}

.annotation-save-btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(87, 6, 140, 0.3);
}

.annotation-cancel-btn {
    background: #e0e0e0;
    color: #333;
}

.annotation-delete-btn {
    background: #dc3545;
    color: white;
}

.annotation-display {
    margin-top: 5px;
    padding: 10px;
    background: #f8f9fa;
    border-left: 3px solid var(--primary-color);
    border-radius: 4px;
    font-size: 0.9rem;
    font-style: italic;
    color: #555;
}

.annotations-panel {
    background: white;
    padding: 25px;
    margin: 20px 0;
    border-radius: var(--border-radius);
    box-shadow: var(--shadow);
    border: var(--card-border);
}

.annotations-panel h3 {
    color: var(--primary-dark);
    margin-bottom: 20px;
}

.annotation-item {
    padding: 15px;
    margin-bottom: 15px;
    background: #f8f9fa;
    border-radius: var(--border-radius-sm);
    border-left: 4px solid var(--primary-color);
}

.annotation-item-header {
    font-weight: 600;
    color: var(--primary-dark);
    margin-bottom: 8px;
}

.annotation-item-text {
    color: #555;
    margin-bottom: 8px;
}

.annotation-item-note {
    background: white;
    padding: 10px;
    border-radius: 4px;
    font-style: italic;
    color: #333;
}



/* Tooltip Help Button Styles */
.help-tooltip-btn {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    width: 22px;
    height: 22px;
    border-radius: 50%;
    background: var(--primary-color);
    color: white;
    border: none;
    font-size: 13px;
    font-weight: bold;
    cursor: help;
    margin-left: 8px;
    vertical-align: middle;
    position: relative;
    transition: background-color var(--transition-base);
}

.help-tooltip-btn:hover {
    background: var(--primary-dark);
}

.help-tooltip-content {
    display: none;
    position: absolute;
    top: 100%;
    left: 50%;
    transform: translateX(-50%);
    margin-top: 10px;
    padding: 15px;
    background: var(--card-background);
    border: 2px solid var(--primary-color);
    border-radius: var(--radius-md);
    box-shadow: var(--shadow-lg);
    width: 320px;
    z-index: 10000;
    color: var(--text-primary);
    font-size: 0.9rem;
    line-height: 1.6;
}

.help-tooltip-content::after {
    content: '';
    position: absolute;
    bottom: 100%;
    left: 50%;
    transform: translateX(-50%);
    border: 8px solid transparent;
    border-bottom-color: var(--primary-color);
}

.help-tooltip-btn:hover .help-tooltip-content,
.help-tooltip-btn:focus .help-tooltip-content {
    display: block;
}

.help-tooltip-content strong {
    color: var(--primary-dark);
    display: block;
    margin-bottom: 8px;
}

.help-tooltip-content ul {
    margin: 8px 0;
    padding-left: 20px;
}

.help-tooltip-content li {
    margin: 4px 0;
}

/* Feedback Button Styles */
.feedback-button {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    padding: 8px 16px;
    border-radius: var(--radius-full);
    background: var(--primary-gradient);
    color: white;
    border: none;
    font-size: 0.85rem;
    font-weight: 600;
    cursor: pointer;
    box-shadow: var(--shadow-md);
    transition: all var(--transition-base);
    margin-left: 12px;
    vertical-align: middle;
    white-space: nowrap;
}

.feedback-button:hover {
    transform: translateY(-2px);
    box-shadow: var(--shadow-lg);
}

.feedback-button:active {
    transform: translateY(0);
}

.feedback-button.has-feedback {
    background: linear-gradient(135deg, #702b9d 0%, #57068c 100%);
}

.panel h3 {
    display: flex;
    align-items: center;
}

/* Enhanced Feedback Modal */
.feedback-modal-content {
    background-color: var(--modal-background);
    margin: 2% auto;
    padding: 0;
    border: 1px solid var(--border-color);
    width: 95%;
    max-width: 850px;
    max-height: 90vh;
    border-radius: var(--radius-lg);
    box-shadow: var(--shadow-xl);
    color: var(--text-color);
    overflow-y: auto;
}

.enhanced-feedback-modal {
    display: flex;
    flex-direction: column;
}

.feedback-modal-content h3 {
    color: var(--primary-dark);
    padding: 25px 30px 15px;
    margin: 0;
    font-size: 1.6rem;
    border-bottom: 2px solid var(--border-color);
    position: sticky;
    top: 0;
    background: var(--modal-background);
    z-index: 10;
}

.feedback-modal-content h4 {
    color: var(--primary-dark);
    margin-bottom: 15px;
    font-size: 1.2rem;
}

/* Feedback List View */
.feedback-list-container {
    padding: 20px 30px;
}

.feedback-list-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 20px;
}

.feedback-list-actions {
    display: flex;
    gap: 10px;
    align-items: center;
}

.feedback-synthesis-btn {
    background: var(--primary-gradient);
    color: white;
    border: none;
    padding: 10px 18px;
    border-radius: var(--radius-full);
    font-weight: 600;
    font-size: 0.9rem;
    cursor: pointer;
    transition: all 0.2s ease;
    box-shadow: 0 2px 8px rgba(124, 77, 255, 0.3);
}

.feedback-synthesis-btn:hover {
    transform: translateY(-1px);
    box-shadow: 0 4px 12px rgba(124, 77, 255, 0.4);
}

.feedback-add-new-btn {
    background: var(--primary-gradient);
    color: white;
    border: none;
    border-radius: var(--radius-full);
    padding: 10px 20px;
    font-weight: 600;
    cursor: pointer;
    transition: var(--transition-base);
}

.feedback-add-new-btn:hover {
    transform: translateY(-2px);
    box-shadow: var(--shadow-md);
}

.feedback-items-list {
    display: flex;
    flex-direction: column;
    gap: 15px;
}

.feedback-item {
    background: var(--card-background);
    border: 2px solid var(--border-color);
    border-radius: var(--radius-md);
    padding: 15px;
    transition: var(--transition-base);
    cursor: pointer;
}

.feedback-item:hover {
    border-color: var(--primary-color);
    box-shadow: var(--shadow-sm);
}

.feedback-item-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 10px;
}

.feedback-item-source {
    display: flex;
    align-items: center;
    gap: 8px;
    font-weight: 600;
    color: var(--primary-color);
}

.feedback-item-date {
    font-size: 0.85rem;
    color: var(--text-secondary);
}

.feedback-item-content {
    color: var(--text-primary);
    line-height: 1.6;
    margin-bottom: 10px;
}

.feedback-item-tags {
    display: flex;
    flex-wrap: wrap;
    gap: 6px;
}

.feedback-item-tag {
    background: var(--accent-purple-lightest);
    color: var(--primary-color);
    padding: 4px 10px;
    border-radius: var(--radius-full);
    font-size: 0.8rem;
    font-weight: 500;
}

.feedback-item-empty {
    text-align: center;
    padding: 40px 20px;
    color: var(--text-secondary);
}

.feedback-item.item-understood {
    border-color: #57068c;
    background: linear-gradient(to right, rgba(87, 6, 140, 0.05), var(--card-background));
}

/* Understanding Progress Bar */
.feedback-progress-container {
    background: var(--card-background);
    border: 2px solid var(--border-color);
    border-radius: var(--radius-md);
    padding: 15px;
    margin-bottom: 20px;
}

.feedback-progress-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 10px;
}

.feedback-progress-label {
    font-weight: 600;
    color: var(--text-primary);
    font-size: 0.9rem;
}

.feedback-progress-count {
    font-size: 0.85rem;
    color: var(--text-secondary);
}

.feedback-progress-bar {
    width: 100%;
    height: 8px;
    background: var(--border-color);
    border-radius: 10px;
    overflow: hidden;
}

.feedback-progress-fill {
    height: 100%;
    transition: width 0.3s ease, background-color 0.3s ease;
    border-radius: 10px;
}

/* Understanding Badges */
.understanding-badge {
    display: inline-flex;
    align-items: center;
    padding: 4px 10px;
    border-radius: var(--radius-full);
    font-size: 0.75rem;
    font-weight: 600;
    white-space: nowrap;
}

.understanding-badge.understood {
    background: #d4edda;
    color: #155724;
    border: 1px solid #c3e6cb;
}

.understanding-badge.not-understood {
    background: #fff3cd;
    color: #856404;
    border: 1px solid #ffeaa7;
}

/* Understanding Section */
.understanding-section {
    background: #eee6f3;
    border: 2px solid #ab82c5;
    border-radius: var(--radius-md);
    padding: 20px;
    margin-top: 25px;
    margin-bottom: 20px;
}

.understanding-section h5 {
    color: var(--primary-dark);
    margin-top: 0;
    margin-bottom: 15px;
    font-size: 1.1rem;
    display: flex;
    align-items: center;
    gap: 8px;
}

.understanding-checkbox-wrapper {
    display: flex;
    align-items: center;
    gap: 10px;
    margin-top: 20px;
    padding: 15px;
    background: white;
    border-radius: var(--radius-sm);
    border: 2px solid #ab82c5;
}

.understanding-checkbox-wrapper input[type="checkbox"] {
    width: 20px;
    height: 20px;
    cursor: pointer;
}

.understanding-checkbox-wrapper input[type="checkbox"]:disabled {
    cursor: not-allowed;
    opacity: 0.5;
}

.understanding-checkbox-wrapper.disabled {
    opacity: 0.7;
    background: #f5f5f5;
}

.understanding-checkbox-label {
    font-weight: 600;
    color: var(--text-primary);
    cursor: pointer;
    flex: 1;
}

.understanding-prompts {
    display: block;
}

.understanding-prompt-group {
    margin-bottom: 15px;
}

.understanding-prompt-group:last-child {
    margin-bottom: 0;
}

.understanding-prompt-label {
    font-weight: 600;
    color: var(--primary-color);
    margin-bottom: 8px;
    display: block;
    font-size: 0.9rem;
}

.understanding-prompt-textarea {
    width: 100%;
    min-height: 80px;
    padding: 12px;
    border: 2px solid #c8e6c9;
    border-radius: var(--radius-sm);
    font-family: var(--font-primary);
    font-size: 0.9rem;
    resize: vertical;
    background: white;
    color: var(--text-primary);
    line-height: 1.6;
}

.understanding-prompt-textarea:focus {
    outline: none;
    border-color: var(--primary-color);
    box-shadow: 0 0 0 3px rgba(87, 6, 140, 0.1);
}

.understanding-help-text {
    font-size: 0.8rem;
    color: var(--text-secondary);
    font-style: italic;
    margin-top: 5px;
}

/* Priority Section */
.priority-section {
    background: #e3f2fd;
    border: 2px solid #64b5f6;
    border-radius: var(--radius-md);
    padding: 20px;
    margin-top: 25px;
    margin-bottom: 20px;
}

.priority-section h5 {
    color: #1565c0;
    margin-top: 0;
    margin-bottom: 10px;
    font-size: 1.1rem;
    display: flex;
    align-items: center;
    gap: 8px;
}

.priority-help-text {
    font-size: 0.85rem;
    color: #1976d2;
    margin-bottom: 20px;
    line-height: 1.5;
}

.priority-slider-group {
    margin-bottom: 25px;
}

.priority-slider-group:last-child {
    margin-bottom: 0;
}

.priority-slider-label {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 10px;
}

.priority-label-text {
    font-weight: 600;
    color: #1565c0;
    font-size: 0.9rem;
}

.priority-slider-value {
    font-size: 0.85rem;
    color: #1976d2;
    font-weight: 500;
    background: white;
    padding: 4px 12px;
    border-radius: var(--radius-sm);
    border: 1px solid #90caf9;
}

.priority-slider {
    width: 100%;
    height: 8px;
    border-radius: 5px;
    background: linear-gradient(to right, #bbdefb 0%, #1976d2 100%);
    outline: none;
    -webkit-appearance: none;
    margin-bottom: 8px;
    cursor: pointer;
}

.priority-slider::-webkit-slider-thumb {
    -webkit-appearance: none;
    appearance: none;
    width: 20px;
    height: 20px;
    border-radius: 50%;
    background: #1565c0;
    cursor: pointer;
    border: 3px solid white;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
    transition: all 0.2s ease;
}

.priority-slider::-webkit-slider-thumb:hover {
    transform: scale(1.2);
    box-shadow: 0 3px 8px rgba(0, 0, 0, 0.3);
}

.priority-slider::-moz-range-thumb {
    width: 20px;
    height: 20px;
    border-radius: 50%;
    background: #1565c0;
    cursor: pointer;
    border: 3px solid white;
    box-shadow: 0 2px 5px rgba(0, 0, 0, 0.2);
    transition: all 0.2s ease;
}

.priority-slider::-moz-range-thumb:hover {
    transform: scale(1.2);
    box-shadow: 0 3px 8px rgba(0, 0, 0, 0.3);
}

.priority-slider-labels {
    display: flex;
    justify-content: space-between;
    font-size: 0.8rem;
    color: #1976d2;
    padding: 0 5px;
}

.priority-slider-labels small {
    display: block;
    font-size: 0.75rem;
    color: #64b5f6;
    font-weight: normal;
}

/* Synthesis & Priorities View */
.feedback-synthesis-view {
    padding: 20px 30px 30px;
}

.synthesis-header {
    display: flex;
    align-items: center;
    gap: 15px;
    margin-bottom: 25px;
    padding-bottom: 15px;
    border-bottom: 2px solid var(--card-border);
}

.synthesis-back-btn {
    background: white;
    border: 2px solid var(--primary-color);
    color: var(--primary-color);
    padding: 8px 16px;
    border-radius: var(--radius-sm);
    font-weight: 600;
    font-size: 0.9rem;
    cursor: pointer;
    transition: all 0.2s ease;
}

.synthesis-back-btn:hover {
    background: var(--primary-color);
    color: white;
}

.synthesis-header h4 {
    margin: 0;
    color: var(--primary-dark);
    font-size: 1.3rem;
}

.synthesis-content {
    max-height: 60vh;
    overflow-y: auto;
}

.synthesis-reflection-section {
    background: #fff3e0;
    border: 2px solid #ffb74d;
    border-radius: var(--radius-md);
    padding: 20px;
    margin-bottom: 30px;
}

.synthesis-reflection-section h5 {
    color: #e65100;
    margin-top: 0;
    margin-bottom: 10px;
    font-size: 1.1rem;
    display: flex;
    align-items: center;
    gap: 8px;
}

.synthesis-help-text {
    font-size: 0.85rem;
    color: #e65100;
    margin-bottom: 20px;
    line-height: 1.5;
}

.synthesis-textarea-group {
    margin-bottom: 20px;
}

.synthesis-textarea-group:last-child {
    margin-bottom: 0;
}

.synthesis-label {
    display: block;
    margin-bottom: 8px;
}

.synthesis-label-text {
    display: block;
    font-weight: 600;
    color: #e65100;
    font-size: 0.95rem;
    margin-bottom: 4px;
}

.synthesis-label-hint {
    display: block;
    font-size: 0.8rem;
    color: #f57c00;
    font-style: italic;
}

.synthesis-textarea {
    width: 100%;
    min-height: 100px;
    padding: 12px;
    border: 2px solid #ffcc80;
    border-radius: var(--radius-sm);
    font-family: var(--font-primary);
    font-size: 0.9rem;
    resize: vertical;
    background: white;
    color: var(--text-primary);
    line-height: 1.6;
}

.synthesis-textarea:focus {
    outline: none;
    border-color: #fb8c00;
    box-shadow: 0 0 0 3px rgba(255, 183, 77, 0.2);
}

.synthesis-priorities-section {
    background: #f3e5f5;
    border: 2px solid #ba68c8;
    border-radius: var(--radius-md);
    padding: 20px;
    margin-bottom: 20px;
}

.synthesis-priorities-section h5 {
    color: #6a1b9a;
    margin-top: 0;
    margin-bottom: 10px;
    font-size: 1.1rem;
    display: flex;
    align-items: center;
    gap: 8px;
}

.priority-add-form {
    margin-top: 15px;
    background: white;
    border: 1px solid #ce93d8;
    border-radius: var(--radius-sm);
    padding: 15px;
}

.priority-input {
    width: 100%;
    padding: 10px;
    border: 2px solid #ce93d8;
    border-radius: var(--radius-sm);
    font-family: var(--font-primary);
    font-size: 0.95rem;
    margin-bottom: 12px;
}

.priority-input:focus {
    outline: none;
    border-color: #8e24aa;
}

.priority-tags-selector {
    display: flex;
    gap: 30px;
    margin-bottom: 12px;
    flex-wrap: wrap;
}

.priority-tag-group {
    display: flex;
    align-items: center;
    gap: 10px;
}

.priority-tag-label {
    font-weight: 600;
    color: #6a1b9a;
    font-size: 0.9rem;
}

.priority-tag-option {
    display: flex;
    align-items: center;
    gap: 5px;
    cursor: pointer;
    font-size: 0.85rem;
    color: var(--text-primary);
}

.priority-tag-option input[type="radio"] {
    cursor: pointer;
}

.priority-add-btn {
    background: var(--primary-gradient);
    color: white;
    border: none;
    padding: 8px 18px;
    border-radius: var(--radius-full);
    font-weight: 600;
    font-size: 0.9rem;
    cursor: pointer;
    transition: all 0.2s ease;
}

.priority-add-btn:hover {
    transform: translateY(-1px);
    box-shadow: 0 4px 8px rgba(124, 77, 255, 0.3);
}

.priorities-list {
    margin-top: 20px;
    display: flex;
    flex-direction: column;
    gap: 10px;
}

.empty-priorities {
    text-align: center;
    color: #999;
    font-style: italic;
    padding: 30px 20px;
    background: white;
    border: 2px dashed #ce93d8;
    border-radius: var(--radius-sm);
}

.priority-item {
    background: white;
    border: 1px solid #ce93d8;
    border-radius: var(--radius-sm);
    padding: 12px;
    display: flex;
    align-items: flex-start;
    gap: 12px;
    transition: all 0.2s ease;
}

.priority-item:hover {
    border-color: #8e24aa;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
}

.priority-drag-handle {
    color: #999;
    cursor: grab;
    font-size: 1.2rem;
    user-select: none;
}

.priority-drag-handle:active {
    cursor: grabbing;
}

.priority-content {
    flex: 1;
    display: flex;
    flex-direction: column;
    gap: 8px;
}

.priority-text {
    color: var(--text-primary);
    line-height: 1.5;
    font-size: 0.95rem;
}

.priority-tags-display {
    display: flex;
    gap: 6px;
    flex-wrap: wrap;
}

.priority-tag {
    display: inline-block;
    padding: 3px 10px;
    border-radius: var(--radius-full);
    font-size: 0.75rem;
    font-weight: 600;
}

.priority-tag.scope-local {
    background: #e3f2fd;
    color: #1565c0;
}

.priority-tag.scope-global {
    background: #f3e5f5;
    color: #6a1b9a;
}

.priority-tag.impact-low {
    background: #f5f5f5;
    color: #666;
}

.priority-tag.impact-high {
    background: #fff3e0;
    color: #e65100;
}

.priority-delete-btn {
    background: none;
    border: none;
    color: #999;
    cursor: pointer;
    font-size: 1.2rem;
    padding: 0 5px;
    transition: color 0.2s ease;
}

.priority-delete-btn:hover {
    color: #dc3545;
}

.synthesis-save-section {
    text-align: center;
    padding: 20px 0;
}

.synthesis-save-btn {
    background: var(--primary-gradient);
    color: white;
    border: none;
    padding: 12px 30px;
    border-radius: var(--radius-full);
    font-weight: 600;
    font-size: 1rem;
    cursor: pointer;
    transition: all 0.2s ease;
    box-shadow: 0 4px 12px rgba(124, 77, 255, 0.3);
}

.synthesis-save-btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 6px 16px rgba(124, 77, 255, 0.4);
}

/* Feedback Entry Form */
.feedback-entry-form {
    padding: 20px 30px 30px;
}

.feedback-modal-error {
    background-color: #f8d7da;
    color: #721c24;
    border: 1px solid #f5c6cb;
    border-radius: var(--radius-sm);
    padding: 12px 15px;
    margin-bottom: 20px;
    font-size: 0.9rem;
    font-weight: 500;
}

.form-group {
    margin-bottom: 20px;
}

.form-row {
    display: grid;
    grid-template-columns: 2fr 1fr;
    gap: 15px;
}

/* Source Selector */
.source-selector {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(110px, 1fr));
    gap: 10px;
    margin-top: 10px;
}

.source-btn {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 6px;
    padding: 15px 10px;
    border: 2px solid var(--border-color);
    border-radius: var(--radius-md);
    background: var(--card-background);
    color: var(--text-primary);
    cursor: pointer;
    transition: var(--transition-base);
    font-size: 0.85rem;
    font-weight: 500;
}

.source-btn:hover {
    border-color: var(--primary-color);
    background: var(--accent-purple-lightest);
}

.source-btn.active {
    border-color: var(--primary-color);
    background: var(--primary-gradient);
    color: white;
}

.source-icon {
    font-size: 1.5rem;
}

/* Form Inputs */
.feedback-input {
    width: 100%;
    padding: 10px 15px;
    border: 2px solid var(--border-color);
    border-radius: var(--radius-sm);
    font-family: var(--font-primary);
    font-size: 0.95rem;
    background-color: var(--input-background);
    color: var(--text-primary);
    transition: var(--transition-base);
}

.feedback-input:focus {
    outline: none;
    border-color: var(--primary-color);
    box-shadow: 0 0 0 3px rgba(87, 6, 140, 0.1);
}

.feedback-textarea {
    width: 100%;
    min-height: 80px;
    padding: 12px 15px;
    border: 2px solid var(--border-color);
    border-radius: var(--radius-sm);
    font-family: var(--font-primary);
    font-size: 0.95rem;
    resize: vertical;
    background-color: var(--input-background);
    color: var(--text-primary);
    line-height: 1.6;
    transition: var(--transition-base);
}

.feedback-textarea:focus {
    outline: none;
    border-color: var(--primary-color);
    box-shadow: 0 0 0 3px rgba(87, 6, 140, 0.1);
}

/* Self-Analysis Section */
.self-analysis-section {
    background: var(--accent-purple-lightest);
    padding: 15px;
    border-radius: var(--radius-md);
    margin-bottom: 20px;
}

/* Rich Text Editor */
.rich-text-toolbar {
    display: flex;
    gap: 5px;
    padding: 8px;
    background: var(--card-background);
    border: 2px solid var(--border-color);
    border-bottom: none;
    border-radius: var(--radius-sm) var(--radius-sm) 0 0;
    align-items: center;
}

.toolbar-btn {
    padding: 6px 10px;
    border: 1px solid var(--border-color);
    border-radius: var(--radius-sm);
    background: var(--modal-background);
    color: var(--text-primary);
    cursor: pointer;
    transition: var(--transition-base);
    font-size: 0.9rem;
}

.toolbar-btn:hover {
    background: var(--accent-purple-lightest);
    border-color: var(--primary-color);
}

.toolbar-btn.active {
    background: var(--primary-color);
    color: white;
    border-color: var(--primary-color);
}

.toolbar-divider {
    color: var(--border-color);
    margin: 0 5px;
}

.feedback-editor {
    min-height: 150px;
    max-height: 300px;
    padding: 15px;
    border: 2px solid var(--border-color);
    border-radius: 0 0 var(--radius-sm) var(--radius-sm);
    font-family: var(--font-primary);
    font-size: 0.95rem;
    background-color: var(--input-background);
    color: var(--text-primary);
    line-height: 1.6;
    overflow-y: auto;
    transition: var(--transition-base);
}

.feedback-editor:focus {
    outline: none;
    border-color: var(--primary-color);
    box-shadow: 0 0 0 3px rgba(87, 6, 140, 0.1);
}

.feedback-editor:empty:before {
    content: attr(data-placeholder);
    color: var(--text-secondary);
    opacity: 0.6;
}

/* Tags Input */
.tags-input-container {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
    align-items: center;
}

.tags-display {
    display: flex;
    flex-wrap: wrap;
    gap: 6px;
}

.tag-item {
    display: inline-flex;
    align-items: center;
    gap: 6px;
    background: var(--primary-gradient);
    color: white;
    padding: 5px 12px;
    border-radius: var(--radius-full);
    font-size: 0.85rem;
    font-weight: 500;
}

.tag-remove {
    cursor: pointer;
    font-weight: bold;
    opacity: 0.8;
    transition: opacity 0.2s;
}

.tag-remove:hover {
    opacity: 1;
}

.tags-input {
    flex: 1;
    min-width: 150px;
}

.suggested-tags {
    display: flex;
    flex-wrap: wrap;
    gap: 6px;
    align-items: center;
    margin-top: 8px;
}

.suggested-tag-label {
    font-size: 0.85rem;
    color: var(--text-secondary);
    margin-right: 5px;
}

.suggested-tag {
    background: transparent;
    color: var(--primary-color);
    border: 1px solid var(--primary-color);
    padding: 4px 10px;
    border-radius: var(--radius-full);
    font-size: 0.8rem;
    cursor: pointer;
    transition: var(--transition-base);
}

.suggested-tag:hover {
    background: var(--primary-gradient);
    color: white;
}

/* File Upload */
.file-upload-area {
    display: flex;
    flex-direction: column;
    gap: 10px;
}

.file-upload-btn {
    display: inline-flex;
    align-items: center;
    gap: 8px;
    padding: 10px 20px;
    border: 2px dashed var(--border-color);
    border-radius: var(--radius-md);
    background: var(--card-background);
    color: var(--text-primary);
    cursor: pointer;
    transition: var(--transition-base);
    font-weight: 500;
    align-self: flex-start;
}

.file-upload-btn:hover {
    border-color: var(--primary-color);
    background: var(--accent-purple-lightest);
}

.attachments-list {
    display: flex;
    flex-direction: column;
    gap: 8px;
}

.attachment-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 10px 15px;
    background: var(--card-background);
    border: 1px solid var(--border-color);
    border-radius: var(--radius-sm);
}

.attachment-info {
    display: flex;
    align-items: center;
    gap: 10px;
}

.attachment-icon {
    font-size: 1.2rem;
}

.attachment-name {
    font-weight: 500;
    color: var(--text-primary);
}

.attachment-size {
    font-size: 0.85rem;
    color: var(--text-secondary);
}

.attachment-remove {
    background: transparent;
    border: none;
    color: #dc3545;
    cursor: pointer;
    font-size: 1.2rem;
    padding: 5px;
    transition: var(--transition-base);
}

.attachment-remove:hover {
    transform: scale(1.2);
}

/* Form Buttons */
.feedback-form-buttons {
    display: flex;
    gap: 10px;
    margin-top: 25px;
    padding-top: 20px;
    border-top: 2px solid var(--border-color);
    justify-content: flex-end;
}

.feedback-save-btn, .feedback-cancel-btn, .feedback-delete-btn {
    padding: 12px 24px;
    border: none;
    border-radius: var(--radius-full);
    cursor: pointer;
    font-weight: 600;
    font-size: 0.95rem;
    transition: var(--transition-base);
}

.feedback-save-btn {
    background: var(--primary-gradient);
    color: white;
}

.feedback-save-btn:hover {
    transform: translateY(-2px);
    box-shadow: var(--shadow-md);
}

.feedback-cancel-btn {
    background: transparent;
    color: var(--text-secondary);
    border: 2px solid var(--border-color);
}

.feedback-cancel-btn:hover {
    background: var(--accent-purple-lightest);
    border-color: var(--primary-color);
    color: var(--text-primary);
}

.feedback-delete-btn {
    background: transparent;
    color: #dc3545;
    border: 2px solid #dc3545;
    margin-right: auto;
}

.feedback-delete-btn:hover {
    background: #dc3545;
    color: white;
}

.feedback-display {
    background: var(--diff-legend-bg);
    padding: 20px;
    border-radius: var(--radius-md);
    border-left: 4px solid var(--primary-color);
    line-height: 1.8;
    white-space: pre-wrap;
    word-wrap: break-word;
}

.feedback-label {
    font-size: 0.9rem;
    font-weight: 600;
    color: var(--text-secondary);
    margin-bottom: 10px;
    display: block;
}

/* Project Management Styles */
.project-item {
    background: var(--card-background);
    border: 2px solid var(--border-color);
    border-radius: var(--radius-md);
    padding: 15px 20px;
    margin-bottom: 12px;
    display: flex;
    justify-content: space-between;
    align-items: center;
    transition: all var(--transition-base);
    cursor: pointer;
}

.project-item:hover {
    border-color: var(--primary-color);
    box-shadow: var(--shadow-md);
    transform: translateY(-2px);
}

.project-item-info {
    flex: 1;
}

.project-item-name {
    font-size: 1.1rem;
    font-weight: 600;
    color: var(--text-primary);
    margin-bottom: 5px;
}

.project-item-date {
    font-size: 0.85rem;
    color: var(--text-secondary);
}

.project-item-actions {
    display: flex;
    gap: 10px;
}

.project-load-btn, .project-delete-btn {
    padding: 8px 16px;
    border: none;
    border-radius: 20px;
    cursor: pointer;
    font-weight: 600;
    font-size: 0.9rem;
    transition: var(--transition-base);
}

.project-load-btn {
    background: var(--primary-gradient);
    color: white;
}

.project-load-btn:hover {
    transform: translateY(-2px);
    box-shadow: var(--shadow-md);
}

.project-delete-btn {
    background: transparent;
    color: #dc3545;
    border: 2px solid #dc3545;
}

.project-delete-btn:hover {
    background: #dc3545;
    color: white;
}

.no-projects-message {
    text-align: center;
    padding: 40px 20px;
    color: var(--text-secondary);
    font-style: italic;
}

/* Data Management Styles */
.data-manager {
    position: fixed;
    bottom: 20px;
    right: 20px;
    z-index: 1000;
}

.data-status {
    background: white;
    border: 2px solid var(--primary-color);
    border-radius: 25px;
    padding: 10px 20px;
    font-size: 0.9rem;
    color: var(--primary-dark);
    box-shadow: 0 4px 15px rgba(0, 0, 0, 0.1);
    display: none;
    animation: slideIn 0.3s ease-out;
}

.data-status.show {
    display: block;
}

@keyframes slideIn {
    from {
        transform: translateY(20px);
        opacity: 0;
    }
    to {
        transform: translateY(0);
        opacity: 1;
    }
}

.clear-data-btn {
    background: #dc3545;
    color: white;
    border: none;
    border-radius: 20px;
    padding: 8px 16px;
    font-size: 0.85rem;
    font-weight: 600;
    cursor: pointer;
    margin-top: 10px;
    transition: var(--transition-standard);
}

.clear-data-btn:hover {
    background: #c82333;
    transform: translateY(-2px);
}

.restore-banner {
    background: var(--restore-banner-bg);
    border-left: 4px solid var(--restore-banner-border);
    padding: 15px 20px;
    margin-bottom: 20px;
    border-radius: var(--border-radius);
    box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1);
    transition: background 0.3s ease, border-color 0.3s ease;
}

.restore-banner h4 {
    color: var(--restore-banner-heading);
    margin: 0 0 8px 0;
    font-size: 1.1rem;
    transition: color 0.3s ease;
}

.restore-banner p {
    color: var(--restore-banner-text);
    margin: 0;
    transition: color 0.3s ease;
}

.restore-banner-buttons {
    margin-top: 12px;
    display: flex;
    gap: 10px;
}

.restore-btn, .dismiss-btn {
    padding: 8px 16px;
    border: none;
    border-radius: 20px;
    cursor: pointer;
    font-weight: 600;
    font-size: 0.9rem;
    transition: var(--transition-standard);
}

.restore-btn {
    background: var(--restore-btn-bg);
    color: white;
    transition: var(--transition-standard);
}

.restore-btn:hover {
    background: var(--restore-btn-bg-hover);
    transform: translateY(-2px);
}

.dismiss-btn {
    background: var(--dismiss-btn-bg);
    color: var(--dismiss-btn-text);
    border: 2px solid var(--dismiss-btn-border);
    transition: var(--transition-standard);
}

.dismiss-btn:hover {
    background: var(--dismiss-btn-bg-hover);
}

.generate-report-btn, .view-annotations-btn, .export-pdf-btn {
    background: var(--primary-gradient);
    color: white;
    border: none;
    border-radius: 25px;
    padding: 12px 24px;
    font-size: 1rem;
    font-weight: 600;
    cursor: pointer;
    transition: var(--transition-standard);
    box-shadow: 0 3px 10px rgba(87, 6, 140, 0.2);
}

.generate-report-btn:hover, .view-annotations-btn:hover, .export-pdf-btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 5px 15px rgba(87, 6, 140, 0.3);
}




@media print {
    /* Force white background */
    body {
        background: white !important;
    }
    
    /* Hide specific UI elements but keep container structure */
    .header,
    .upload-section,
    .comparison-viewport,
    .nav-arrow,
    .navigation-info,
    .generate-report-btn,
    .view-annotations-btn,
    .export-pdf-btn,
    .new-comparison-btn,
    .data-manager,
    .modal,
    #comparisonResults,
    #errorMessage,
    .tutorial-overlay,
    .tutorial-tooltip,
    .restore-banner {
        display: none !important;
    }
    
    /* Make sure printable content is visible and positioned */
    #printableContent {
        display: block !important;
        position: static !important;
        width: 100% !important;
        background: white !important;
        padding: 0 !important;
        margin: 0 !important;
    }
    
    .container {
        max-width: 100% !important;
        padding: 20px !important;
        background: white !important;
    }
    
    /* Two-column layout: 60% text, 40% annotations */
    .print-page {
        page-break-after: always;
        page-break-inside: avoid;
        position: relative;
        padding: 20px;
        background: white !important;
    }
    
    .print-page:last-child {
        page-break-after: auto;
    }
    
    .print-content-wrapper {
        display: flex;
        gap: 20px;
        position: relative;
        background: white !important;
    }
    
    .print-main-content {
        width: 60%;
        flex-shrink: 0;
        line-height: 1.8;
        font-size: 11pt;
        background: white !important;
    }
    
    .print-annotations-margin {
        width: 38%;
        flex-shrink: 0;
        border-left: 2px solid #ddd;
        padding-left: 20px;
        background: white !important;
    }
    
    /* Optimize diff highlighting for print */
    .deletion {
        background-color: #ffebee !important;
        color: #c62828 !important;
        text-decoration: line-through;
        border-left: 3px solid #ef5350 !important;
        padding: 2px 4px;
        -webkit-print-color-adjust: exact;
        print-color-adjust: exact;
    }
    
    .addition {
        background-color: #e8f5e8 !important;
        color: #2e7d32 !important;
        border-left: 3px solid #66bb6a !important;
        padding: 2px 4px;
        -webkit-print-color-adjust: exact;
        print-color-adjust: exact;
    }
    
    /* Annotation reference numbers */
    .annotation-ref {
        display: inline-block;
        border: 1.5px solid #000 !important;
        background: white !important;
        color: #000 !important;
        border-radius: 50%;
        width: 16px;
        height: 16px;
        line-height: 14px;
        text-align: center;
        font-weight: bold;
        margin-left: 3px;
        vertical-align: super;
        font-size: 8pt;
    }

    /* Inline annotations (appear next to edits) */
    .inline-annotation {
        display: inline-block;
        margin-left: 8px;
        padding: 6px 10px;
        background: #f9f9f9 !important;
        border: 1px solid #666 !important;
        border-radius: 4px;
        font-size: 9pt;
        line-height: 1.4;
        vertical-align: middle;
        max-width: 300px;
        page-break-inside: avoid;
    }

    .inline-annotation-number {
        display: inline-block;
        border: 1.5px solid #000 !important;
        background: white !important;
        color: #000 !important;
        border-radius: 50%;
        width: 18px;
        height: 18px;
        line-height: 16px;
        text-align: center;
        font-weight: bold;
        margin-right: 6px;
        font-size: 9pt;
    }

    .inline-annotation-content {
        font-style: italic;
        color: #333 !important;
    }

    /* Legacy margin annotation styles (kept for backwards compatibility) */
    .margin-annotation {
        margin-bottom: 20px;
        page-break-inside: avoid;
        font-size: 9pt;
        line-height: 1.4;
    }

    .margin-annotation-number {
        display: inline-block;
        border: 2px solid #000 !important;
        background: white !important;
        color: #000 !important;
        border-radius: 50%;
        width: 20px;
        height: 20px;
        line-height: 18px;
        text-align: center;
        font-weight: bold;
        margin-right: 8px;
        flex-shrink: 0;
    }

    .margin-annotation-content {
        font-style: italic;
        color: #333 !important;
    }

    .margin-annotation-text {
        font-size: 8pt;
        color: #666 !important;
        margin-top: 4px;
        font-style: normal;
        border: 1px solid #ddd !important;
        background: white !important;
        padding: 4px 6px;
        border-radius: 3px;
    }

    .has-annotation {
        background-color: white !important;
        border-bottom: 2px solid #000 !important;
        padding: 2px 4px;
    }
    
    /* Ensure colors print */
    * {
        -webkit-print-color-adjust: exact;
        print-color-adjust: exact;
    }
    
    /* Legend for print */
    .print-legend {
        border: 2px solid #333 !important;
        padding: 15px;
        margin: 20px 0;
        background-color: white !important;
        page-break-inside: avoid;
    }
    
    .print-legend h3 {
        margin-top: 0;
        color: #000 !important;
    }
    
    /* Page headers */
    .print-page-header {
        font-size: 14pt;
        font-weight: bold;
        color: #000 !important;
        margin-bottom: 15px;
        padding-bottom: 10px;
        border-bottom: 2px solid #000 !important;
    }
}

.pdf-options-modal {
    display: none;
    position: fixed;
    z-index: 1000;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.5);
    backdrop-filter: blur(4px);
}

.pdf-options-content {
    background-color: white;
    margin: 5vh auto;
    padding: 30px;
    border-radius: var(--border-radius);
    box-shadow: 0 15px 50px rgba(0, 0, 0, 0.25);
    width: 90%;
    max-width: 500px;
    max-height: 90vh;
    overflow-y: auto;
    position: relative;
}

.pdf-options-content h3 {
    color: var(--primary-dark);
    margin-bottom: 20px;
}

.pdf-option {
    margin: 15px 0;
    padding: 15px;
    border: 2px solid var(--border-color);
    border-radius: var(--border-radius-sm);
    cursor: pointer;
    transition: var(--transition-standard);
}

.pdf-option:hover {
    border-color: var(--primary-color);
    background-color: rgba(87, 6, 140, 0.05);
}

.pdf-option input[type="checkbox"] {
    margin-right: 10px;
    width: 18px;
    height: 18px;
    cursor: pointer;
}

.pdf-option label {
    cursor: pointer;
    font-weight: 600;
    color: var(--primary-dark);
}

.pdf-option-description {
    margin-top: 5px;
    font-size: 0.9rem;
    color: #666;
    margin-left: 28px;
}

.pdf-buttons {
    display: flex;
    gap: 10px;
    margin-top: 25px;
}

.pdf-generate-btn, .pdf-cancel-btn {
    flex: 1;
    padding: 12px;
    border: none;
    border-radius: 25px;
    font-weight: 600;
    cursor: pointer;
    transition: var(--transition-standard);
}

.pdf-generate-btn {
    background: var(--primary-gradient);
    color: white;
}

.pdf-generate-btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 5px 15px rgba(87, 6, 140, 0.3);
}

.pdf-cancel-btn {
    background: #e0e0e0;
    color: #333;
}

.pdf-cancel-btn:hover {
    background: #d0d0d0;
}

/* Fizzle animations */
@keyframes fizzleOut {
  0% { opacity: 1; filter: blur(0px); }
  50% { opacity: 0.3; filter: blur(2px); }
  100% { opacity: 0; filter: blur(6px); }
}

@keyframes fizzleIn {
  0% { opacity: 0; filter: blur(6px); }
  50% { opacity: 0.5; filter: blur(2px); }
  100% { opacity: 1; filter: blur(0px); }
}

/* Quote mode stays in flex layout to adapt to available space */
.header-title.quote-mode {
  flex-grow: 1;
  min-width: 0;
  max-width: 500px; /* Maximum width for quotes, but can shrink if needed */
  text-align: center;
  display: flex;
  flex-direction: column;
  justify-content: center;
  align-items: center;
  padding: 0 20px; /* Side padding to prevent touching buttons */
}

.header-title.quote-mode h1 {
  font-size: 0.95rem;
  font-style: italic;
  font-weight: 400;
  line-height: 1.4;
  margin: 0;
  background: none !important;
  -webkit-text-fill-color: initial !important;
  color: var(--primary-dark) !important;
  word-break: break-word;
}

.header-title.quote-mode .quote-author {
    font-size: 0.85rem;
    font-style: normal;
    font-weight: 600;
    color: var(--accent-light);
    margin-top: 8px;
    display: block; /* Ensures it's always on its own line */
}

/* Optional: make fizzle stronger for visibility in smaller text */
.fizzle-out {
  animation: fizzleOut 0.9s forwards ease-in;
}
.fizzle-in {
  animation: fizzleIn 0.9s forwards ease-out;
}

/* Tutorial Overlay and Tooltips */
.tutorial-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0, 0, 0, 0.7);
    z-index: 9998;
    display: none;
}

.tutorial-overlay.active {
    display: block;
}

.tutorial-tooltip {
    position: fixed;
    background: white;
    border: 3px solid var(--primary-color);
    border-radius: var(--border-radius);
    padding: 25px;
    box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
    z-index: 9999;
    max-width: 400px;
    animation: tooltipFadeIn 0.3s ease-out;
}

@keyframes tooltipFadeIn {
    from {
        opacity: 0;
        transform: translateY(10px);
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}

.tutorial-tooltip h3 {
    color: var(--primary-dark);
    margin: 0 0 12px 0;
    font-size: 1.2rem;
}

.tutorial-tooltip p {
    color: #333;
    line-height: 1.6;
    margin: 0 0 20px 0;
}

.tutorial-tooltip-buttons {
    display: flex;
    gap: 10px;
    justify-content: flex-end;
}

.tutorial-btn {
    padding: 10px 20px;
    border: none;
    border-radius: 20px;
    font-weight: 600;
    cursor: pointer;
    transition: var(--transition-standard);
}

.tutorial-btn-primary {
    background: var(--primary-gradient);
    color: white;
}

.tutorial-btn-primary:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(87, 6, 140, 0.3);
}

.tutorial-btn-secondary {
    background: #e0e0e0;
    color: #333;
}

.tutorial-btn-secondary:hover {
    background: #d0d0d0;
}

.tutorial-highlight {
    position: fixed;
    border: 3px solid var(--primary-color);
    border-radius: 8px;
    box-shadow: 0 0 0 4px rgba(87, 6, 140, 0.3);
    z-index: 9997;
    pointer-events: none;
    animation: highlightPulse 2s ease-in-out infinite;
}

@keyframes highlightPulse {
    0%, 100% {
        box-shadow: 0 0 0 4px rgba(87, 6, 140, 0.3);
    }
    50% {
        box-shadow: 0 0 0 8px rgba(87, 6, 140, 0.5);
    }
}

.tutorial-arrow {
    position: absolute;
    width: 0;
    height: 0;
}

.tutorial-arrow-up {
    border-left: 15px solid transparent;
    border-right: 15px solid transparent;
    border-bottom: 15px solid var(--primary-color);
    top: -18px;
    left: 50%;
    transform: translateX(-50%);
}

.tutorial-arrow-down {
    border-left: 15px solid transparent;
    border-right: 15px solid transparent;
    border-top: 15px solid var(--primary-color);
    bottom: -18px;
    left: 50%;
    transform: translateX(-50%);
}

.tutorial-arrow-left {
    border-top: 15px solid transparent;
    border-bottom: 15px solid transparent;
    border-right: 15px solid var(--primary-color);
    left: -18px;
    top: 50%;
    transform: translateY(-50%);
}

.tutorial-arrow-right {
    border-top: 15px solid transparent;
    border-bottom: 15px solid transparent;
    border-left: 15px solid var(--primary-color);
    right: -18px;
    top: 50%;
    transform: translateY(-50%);
}

.tutorial-step-indicator {
    text-align: center;
    color: #666;
    font-size: 0.85rem;
    margin-bottom: 10px;
}

/* Options Dropdown Styles */
.options-dropdown {
    position: relative;
    display: inline-block;
}

.options-dropdown-menu {
    display: none;
    position: absolute;
    right: 0;
    top: calc(100% + 5px);
    background-color: var(--card-background);
    min-width: 180px;
    box-shadow: 0 8px 16px rgba(0, 0, 0, 0.15);
    border-radius: 8px;
    z-index: 1000;
    border: 1px solid var(--border-color);
    overflow: hidden;
    transition: background-color 0.3s ease;
}

.options-dropdown-menu.show {
    display: block;
    animation: dropdownFadeIn 0.2s ease-out;
}

@keyframes dropdownFadeIn {
    from {
        opacity: 0;
        transform: translateY(-10px);
    }
    to {
        opacity: 1;
        transform: translateY(0);
    }
}

.dropdown-item {
    display: block;
    width: 100%;
    padding: 12px 20px;
    text-align: left;
    background: none;
    border: none;
    border-bottom: 1px solid #f0f0f0;
    color: var(--text-color);
    font-size: 0.95rem;
    font-weight: 600;
    cursor: pointer;
    transition: var(--transition-standard);
}

.dropdown-item:last-child {
    border-bottom: none;
}

.dropdown-item:hover {
    background-color: var(--secondary-color);
    color: var(--primary-color);
    
}

.dropdown-item[href] {
    text-decoration: none;
}

.dropdown-item[href]:visited {
    color: var(--text-color);
}

.dropdown-item[href]:hover {
    color: var(--primary-color);
}

.dropdown-item-danger {
    color: #dc3545;
}

.dropdown-item-danger:hover {
    background-color: #fff5f5;
    color: #c82333;
}



    </style>
</head>


<body>

    <div id="loadingSpinner" class="loading-spinner">
        <div>
            <div class="spinner"></div>
            <div class="spinner-text">Analyzing drafts...</div>
        </div>
    </div>

    <header class="header">
        <div class="logo-container">
            <img src="https://i.imgur.com/iIODsNl.png" alt="NYU Logo" class="nyu-logo" id="headerLogo">
        </div>
        <div class="header-title">
            <h1>u even revise, bro?</h1>
        </div>
       <!-- Consolidated header buttons with dropdown -->
       <!-- Consolidated header buttons with dropdown -->
       <div class="header-buttons">

        <button class="new-comparison-btn hidden" id="headerNewComparisonBtn">New Comparison</button>
            <!-- Options Dropdown -->
            <div class="options-dropdown">
                <button class="about-btn" id="optionsDropdownBtn">
                    Options âˆ¨
                </button>
                <div class="options-dropdown-menu" id="optionsDropdownMenu">
                    <button class="dropdown-item" id="aboutButton">About</button>
                    <button class="dropdown-item" id="restartLandingTourBtn">Take Tour</button>
                    <button class="dropdown-item" id="nightModeToggle">Night Mode: <span id="nightModeStatus">Off</span></button>
                    <a href="https://docs.google.com/forms/d/e/1FAIpQLSfjLT0XMpp4k__8cgiwBS2_JTZnrRKPRXDktcvcdgH8fYSDTA/viewform?usp=header" target="_blank" rel="noopener noreferrer" class="dropdown-item">Report a Bug</a>
                    <button class="dropdown-item" id="saveProjectButton">Save Project</button>
                    <button class="dropdown-item" id="loadProjectButton">Load Project</button>
                    <button class="dropdown-item dropdown-item-danger" id="clearDataButton">Clear Data</button>
                </div>
            </div>
            
            
        </div>
    </header>

    

    <div class="container">
        
        
        <div class="upload-section">
            <h2>Compare Drafts</h2>
            
            <div class="tab-container">
                <button class="tab-btn active" id="uploadTab">Upload Files</button>
                <button class="tab-btn" id="pasteTab">Paste Text</button>
                <button class="tab-btn" id="examplesTab"><i>Mercer Street</i></button>
            </div>
            
            <div id="uploadContent" class="tab-content active">
                <div class="upload-area">
                    <div class="file-input-container">
                        <label for="fileInput" class="file-input-label">
                            <div class="upload-icon">ðŸ“</div>
                            <div class="upload-text">
                                <strong>Choose files to compare</strong>
                                <p>Select multiple text files (.txt, .docx) or drag and drop them here</p>
                            </div>
                        </label>
                        <input type="file" id="fileInput" multiple accept=".txt,.docx,text/plain,application/vnd.openxmlformats-officedocument.wordprocessingml.document" style="display: none;">
                    </div>
                    
                    <!-- Privacy Notice -->
                    <div style="text-align: center; margin: 15px 0 20px 0; padding: 12px; background: var(--secondary-color); border-radius: 8px; border: 1px solid var(--accent-lighter);">
                        <p style="margin: 0; color: var(--primary-dark); font-size: 0.9rem; line-height: 1.4;">
                            <strong>ðŸ”’ Privacy:</strong> All document processing happens locally in your browser. Your files never leave your device.
                        </p>
                    </div>
                    
                    <div style="margin: 20px 0; text-align: center;">
                       
                    </div>
                    
                        <div id="fileList" class="file-list" style="display: none;"></div>
                    <button id="compareFiles" class="compare-btn" style="display: none;">Compare Files</button>
                </div>
            </div>
            
            <div id="pasteContent" class="tab-content">
                <div style="max-width: 900px; margin: 0 auto;">
                    <h3 style="color: var(--primary-dark); margin-bottom: 15px;">Paste Your Drafts</h3>
                    <p style="margin-bottom: 15px; line-height: 1.6; color: var(--text-color);">
                        Copy and paste your drafts below. Label each draft (e.g., "Draft 1", "First Draft", "Final") and paste the full text. You can compare 2-5 drafts.
                    </p>
                    
                    <!-- Privacy Notice -->
                    <div style="text-align: center; margin: 0 0 25px 0; padding: 12px; background: var(--secondary-color); border-radius: 8px; border: 1px solid var(--accent-lighter);">
                        <p style="margin: 0; color: var(--primary-dark); font-size: 0.9rem; line-height: 1.4;">
                            <strong>ðŸ”’ Privacy:</strong> All document processing happens locally in your browser. Your files never leave your device.
                        </p>
                    </div>
                    
                    <div id="pasteContainer">
                        <!-- Draft 1 -->
                        <div class="paste-draft-section" data-draft-num="1" style="margin-bottom: 30px;">
                            <label style="display: block; font-weight: 600; color: var(--primary-dark); margin-bottom: 8px;">
                                Draft 1 Label:
                            </label>
                            <input type="text" id="paste-label-1" placeholder="e.g., Draft 1, First Draft" 
                                style="width: 100%; padding: 10px; border: 2px solid var(--border-color); border-radius: 8px; 
                                font-size: 1rem; margin-bottom: 10px;">
                            
                            <label style="display: block; font-weight: 600; color: var(--primary-dark); margin-bottom: 8px;">
                                Draft 1 Text:
                            </label>
                            <textarea id="paste-text-1" placeholder="Paste your first draft here..." 
                                style="width: 100%; min-height: 200px; padding: 15px; border: 2px solid var(--border-color); 
                                border-radius: 8px; font-family: 'Segoe UI', sans-serif; font-size: 1rem; line-height: 1.6; 
                                resize: vertical;"></textarea>
                        </div>
                        
                        <!-- Draft 2 -->
                        <div class="paste-draft-section" data-draft-num="2" style="margin-bottom: 30px;">
                            <label style="display: block; font-weight: 600; color: var(--primary-dark); margin-bottom: 8px;">
                                Draft 2 Label:
                            </label>
                            <input type="text" id="paste-label-2" placeholder="e.g., Draft 2, Revised Draft" 
                                style="width: 100%; padding: 10px; border: 2px solid var(--border-color); border-radius: 8px; 
                                font-size: 1rem; margin-bottom: 10px;">
                            
                            <label style="display: block; font-weight: 600; color: var(--primary-dark); margin-bottom: 8px;">
                                Draft 2 Text:
                            </label>
                            <textarea id="paste-text-2" placeholder="Paste your second draft here..." 
                                style="width: 100%; min-height: 200px; padding: 15px; border: 2px solid var(--border-color); 
                                border-radius: 8px; font-family: 'Segoe UI', sans-serif; font-size: 1rem; line-height: 1.6; 
                                resize: vertical;"></textarea>
                        </div>
                    </div>
                    
                    <!-- Add Draft Button -->
                    <div style="text-align: center; margin-bottom: 20px;">
                        <button id="addDraftBtn" class="compare-btn" style="background: white; color: var(--primary-color); border: 2px solid var(--primary-color);">
                            + Add Another Draft
                        </button>
                        <p id="draftLimitMessage" style="display: none; margin-top: 10px; color: #666; font-size: 0.9rem;">
                            Maximum of 5 drafts reached
                        </p>
                    </div>
                    
                    <button id="comparePastedText" class="compare-btn" style="margin-top: 10px;">
                        Compare Drafts
                    </button>
                </div>
            </div>




            <div id="examplesContent" class="tab-content">
                <div style="margin: 0 0 90px 0;">
                    <h3 style="color: var(--primary-dark); margin-bottom: 15px; font-size: 1.3rem;">Example Essays from <i>Mercer Street</i></h3>
                    <p style="margin-bottom: 12px; line-height: 1.6; color: var(--text-color);">
                        <i><a href="https://wp.nyu.edu/mercerstreet/" target="_blank" rel="noopener noreferrer" style="color: var(--primary-color); text-decoration: underline; font-style: italic;">Mercer Street</a></i> is the annual anthology of essays composed by students in the Expository Writing Program at New York University. Each year, approximately twenty essays are selected from hundreds of submissions, representing the rigorous and thoughtful work accomplished in our courses.
                    </p>
                    <p style="margin-bottom: 30px; line-height: 1.6; color: var(--text-color);">
                        The drafts below offer a window into the writing processes of exceptional undergraduate writers. Draft by draft, you can see how these students developed and refined their ideas iteratively, moving from early explorations to polished final arguments. These examples demonstrate the transformative power of sustained revision.
                    </p>
                </div>
                <div class="examples-grid">
                    <div class="example-card" data-essay="essay1">
                        <h4>Ping! Panic! Repeat!</h4>
                        <p class="example-author">By Braden Ou</p>
                        <p class="example-description">An ethnographic study exploring smartphone use.</p>
                        <button class="example-btn">View All Drafts</button>
                    </div>

                    <div class="example-card" data-essay="essay2">
                        <h4><i>An excerpt from </i>Simulated Systems and the Limits of Intuitive Learning</h4>
                        <p class="example-author">By Srinivas Harish</p>
                        <p class="example-description">Examining the affordance and limitations of gamified learning.</p>
                        <button class="example-btn">View All Drafts</button>
                    </div>
                </div>
            </div>
        </div>
        
        <div id="errorMessage" class="error" style="display: none;"></div>
        
        <div id="comparisonResults" style="display: none;">
            <div class="comparison-viewport">
                <div class="navigation-info" id="navigationInfo">Draft 1</div>
                <div class="nav-arrow left" id="leftArrow">â†</div>
                <div class="nav-arrow right" id="rightArrow">â†’</div>
                <div class="comparison-slider" id="comparisonSlider">
                    <!-- Panels will be dynamically generated -->
                </div>
            </div>
            
            <!-- Button Container -->
            <div id="comparisonButtonsContainer" style="display: flex; justify-content: center; gap: 15px; margin-top: 25px; flex-wrap: wrap;">
                <!-- Buttons will be added here dynamically -->
            </div>
        </div>


        <div id="revisionReportModal" class="modal">
            <div class="modal-content" style="max-width: 900px;">
                <span class="modal-close" id="reportModalClose">&times;</span>
                <h2 style="color: var(--primary-dark); margin-bottom: 20px;">Revision Analysis Report</h2>
                
                <div class="report-toggle" style="margin-bottom: 20px;">
                    <button class="toggle-btn active" id="tableViewBtn">Table View</button>
                    <button class="toggle-btn" id="detailViewBtn">Detailed List</button>
                </div>
                
                <div id="reportContent" style="max-height: 70vh; overflow-y: auto;">
                    <!-- Report content will be dynamically generated here -->
                </div>
            </div>
        </div>

        <!-- Annotations Panel Modal -->
<div id="annotationsModal" class="modal">
    <div class="modal-content" style="max-width: 800px;">
        <span class="modal-close" id="annotationsModalClose">&times;</span>
        <h2 style="color: var(--primary-dark); margin-bottom: 20px;">Revision Annotations</h2>
        <div id="annotationsContent">
            <!-- Annotations will be displayed here -->
        </div>
    </div>
</div>

<!-- PDF Export Options Modal -->
<div id="pdfOptionsModal" class="pdf-options-modal">
    <div class="pdf-options-content">
        <span class="modal-close" id="pdfOptionsClose">&times;</span>
        <h3>Export Options</h3>
        
        <div class="pdf-option" onclick="document.getElementById('includeAllDrafts').click()">
            <input type="checkbox" id="includeAllDrafts" >
            <label for="includeAllDrafts">Include all drafts</label>
            <div class="pdf-option-description">Export all draft versions and their comparisons</div>
        </div>
        
        <div class="pdf-option" onclick="document.getElementById('includeCurrentOnly').click()">
            <input type="checkbox" id="includeCurrentOnly"checked>
            <label for="includeCurrentOnly">Current view only</label>
            <div class="pdf-option-description">Export only the currently visible draft or comparison</div>
        </div>
        
        <div class="pdf-option" onclick="document.getElementById('includeAnnotations').click()">
            <input type="checkbox" id="includeAnnotations" checked>
            <label for="includeAnnotations">Include annotations</label>
            <div class="pdf-option-description">Add your annotation notes to the exported document</div>
        </div>

        <div class="pdf-option" onclick="document.getElementById('includeFeedback').click()">
            <input type="checkbox" id="includeFeedback" checked>
            <label for="includeFeedback">Include feedback</label>
            <div class="pdf-option-description">Add instructor/classmate feedback as footnotes on each draft</div>
        </div>

        <div class="pdf-option" onclick="document.getElementById('includeLegend').click()">
            <input type="checkbox" id="includeLegend" >
            <label for="includeLegend">Include color legend</label>
            <div class="pdf-option-description">Add a legend explaining the color coding</div>
        </div>
        
        <div class="pdf-buttons">
            <button class="pdf-generate-btn" id="generatePdfBtn">Generate PDF</button>
            <button class="pdf-cancel-btn" id="pdfCancelBtn">Cancel</button>
        </div>
    </div>
</div>

<!-- Quotes Easter Egg Modal -->
<div id="quotesModal" class="modal">
    <div class="modal-content" style="max-width: 900px; max-height: 85vh; overflow-y: auto;">
        <span class="modal-close" id="quotesModalClose">&times;</span>
        <h2 style="color: var(--primary-dark); margin-bottom: 10px; text-align: center;">
            ðŸ’œ All Revision Quotes ðŸ’œ
        </h2>
        <p style="text-align: center; color: #666; margin-bottom: 30px; font-style: italic;">
            You found the secret! Here are all the quotes about revision from famous writers.
        </p>
        <div id="quotesListContainer">
            <!-- Quotes will be populated here -->
        </div>
    </div>
</div>

<!-- Hidden printable content area -->
<div id="printableContent" style="display: none;"></div>

<!-- Save Project Modal -->
<div id="saveProjectModal" class="modal">
    <div class="modal-content" style="max-width: 500px;">
        <span class="modal-close" id="saveProjectModalClose">&times;</span>
        <h2 style="color: var(--primary-dark); margin-bottom: 20px; display: inline-flex; align-items: center;">
            Save Project
            <button class="help-tooltip-btn" tabindex="0">
                ?
                <div class="help-tooltip-content">
                    <strong>Save Project</strong>
                    <p>Save your current work including:</p>
                    <ul>
                        <li>All uploaded draft files</li>
                        <li>Revision annotations</li>
                        <li>Instructor/classmate feedback</li>
                    </ul>
                    <p>You can save up to 5 projects. Projects can be loaded later or downloaded as .bro files.</p>
                </div>
            </button>
        </h2>
        <p style="margin-bottom: 20px; color: var(--text-secondary);">Give your project a name to save all drafts and annotations.</p>
        <input type="text" id="projectNameInput" placeholder="Enter project name..."
            style="width: 100%; padding: 12px; border: 2px solid var(--border-color); border-radius: 8px;
            font-size: 1rem; margin-bottom: 20px;">
        <div style="display: flex; gap: 10px; justify-content: space-between; border-top: 1px solid var(--border-color); padding-top: 15px;">
            <button class="annotation-cancel-btn" id="manageProjectsFromSaveBtn">Manage Projects</button>
            <div style="display: flex; gap: 10px;">
                <button class="annotation-cancel-btn" id="cancelSaveProjectBtn">Cancel</button>
                <button class="annotation-save-btn" id="confirmSaveProjectBtn">Save Project</button>
            </div>
        </div>
    </div>
</div>

<!-- Load Project Modal -->
<div id="loadProjectModal" class="modal">
    <div class="modal-content" style="max-width: 600px;">
        <span class="modal-close" id="loadProjectModalClose">&times;</span>
        <h2 style="color: var(--primary-dark); margin-bottom: 20px; display: inline-flex; align-items: center;">
            Load Project
            <button class="help-tooltip-btn" tabindex="0">
                ?
                <div class="help-tooltip-content">
                    <strong>Load Project</strong>
                    <p>Load a previously saved project to continue working on it.</p>
                    <ul>
                        <li>Click any project to load it</li>
                        <li>All drafts, annotations, and feedback will be restored</li>
                        <li>Your current work will be replaced</li>
                    </ul>
                    <p>Use "Manage Projects" to download projects as .bro files or delete them.</p>
                </div>
            </button>
        </h2>
        <p style="margin-bottom: 20px; color: var(--text-secondary);">Select a saved project to load.</p>
        <div id="projectsList" style="max-height: 400px; overflow-y: auto; margin-bottom: 20px;">
            <!-- Projects will be listed here -->
        </div>
        <div style="display: flex; gap: 10px; justify-content: flex-end; border-top: 1px solid var(--border-color); padding-top: 15px;">
            <button class="annotation-cancel-btn" id="manageProjectsFromLoadBtn">Manage Projects</button>
        </div>
    </div>
</div>

<!-- Manage Projects Modal (when limit reached) -->
<div id="manageProjectsModal" class="modal">
    <div class="modal-content" style="max-width: 600px;">
        <span class="modal-close" id="manageProjectsModalClose">&times;</span>
        <h2 style="color: var(--primary-dark); margin-bottom: 10px; display: inline-flex; align-items: center;">
            Manage Projects
            <button class="help-tooltip-btn" tabindex="0">
                ?
                <div class="help-tooltip-content">
                    <strong>Manage Projects</strong>
                    <p><strong>Upload .bro Files:</strong> Import projects shared by others or backed up previously.</p>
                    <p><strong>Download:</strong> Export projects as .bro files to share with classmates or create backups.</p>
                    <p><strong>Delete:</strong> Remove projects you no longer need (maximum 5 projects).</p>
                    <p>.bro files contain all drafts, annotations, and feedback.</p>
                </div>
            </button>
        </h2>
        <p id="projectCountMessage" style="margin-bottom: 20px; color: var(--text-secondary); font-weight: 600;">
            <!-- Count will be shown here -->
        </p>

        <!-- Upload .bro file section -->
        <div style="margin-bottom: 20px; padding: 15px; background: var(--accent-purple-lightest); border-radius: var(--radius-md); border: 2px dashed var(--primary-color);">
            <label for="broFileInput" style="display: block; font-weight: 600; color: var(--primary-dark); margin-bottom: 8px;">
                ðŸ“ Upload Project File (.bro)
            </label>
            <input type="file" id="broFileInput" accept=".bro" style="display: none;">
            <button class="annotation-save-btn" onclick="document.getElementById('broFileInput').click()" style="width: 100%;">
                Choose .bro File to Import
            </button>
        </div>

        <div id="manageProjectsList" style="max-height: 400px; overflow-y: auto; margin-bottom: 20px;">
            <!-- Projects will be listed here with delete buttons -->
        </div>
        <div style="display: flex; gap: 10px; justify-content: space-between;">
            <button class="annotation-save-btn" id="backToSaveFromManageBtn" style="display: none;">Save New Project</button>
            <button class="annotation-cancel-btn" id="cancelManageProjectsBtn">Close</button>
        </div>
    </div>
</div>

<!-- Feedback Modal -->
<div id="feedbackModal" class="modal">
    <div class="feedback-modal-content enhanced-feedback-modal">
        <span class="modal-close" id="feedbackModalClose">&times;</span>
        <h3 id="feedbackModalTitle">Manage Feedback</h3>

        <!-- Feedback List View -->
        <div id="feedbackListView" class="feedback-list-container">
            <div class="feedback-list-header">
                <h4>Feedback for <span id="feedbackDraftName"></span></h4>
                <div class="feedback-list-actions">
                    <button class="feedback-synthesis-btn" id="feedbackSynthesisBtn">ðŸ“Š Synthesize and Prioritize</button>
                    <button class="feedback-add-new-btn" id="feedbackAddNewBtn">+ Add Feedback</button>
                </div>
            </div>
            <div id="feedbackItemsList" class="feedback-items-list">
                <!-- Feedback items will be dynamically inserted here -->
            </div>
        </div>

        <!-- Feedback Entry/Edit Form -->
        <div id="feedbackEntryForm" class="feedback-entry-form" style="display: none;">
            <h4 id="feedbackFormTitle">Add New Feedback</h4>

            <!-- Error Message -->
            <div id="feedbackModalError" class="feedback-modal-error" style="display: none;"></div>

            <!-- Source Type Selector -->
            <div class="form-group">
                <label class="feedback-label">Feedback Source:</label>
                <div class="source-selector">
                    <button type="button" class="source-btn" data-source="instructor">
                        <span class="source-icon">ðŸ“š</span>
                        <span>Instructor</span>
                    </button>
                    <button type="button" class="source-btn" data-source="peer">
                        <span class="source-icon">ðŸ‘¥</span>
                        <span>Peer</span>
                    </button>
                    <button type="button" class="source-btn" data-source="writing-center">
                        <span class="source-icon">ðŸ“</span>
                        <span>Writing Center</span>
                    </button>
                    <button type="button" class="source-btn" data-source="self">
                        <span class="source-icon">ðŸ’­</span>
                        <span>Self-Analysis</span>
                    </button>
                    <button type="button" class="source-btn" data-source="other">
                        <span class="source-icon">ðŸ“Œ</span>
                        <span>Other</span>
                    </button>
                </div>
            </div>

            <!-- Source Name and Date -->
            <div class="form-row">
                <div class="form-group">
                    <label class="feedback-label">Name (optional):</label>
                    <input type="text" id="feedbackSourceName" class="feedback-input" placeholder="e.g., Prof. Smith">
                </div>
                <div class="form-group">
                    <label class="feedback-label">Date (optional):</label>
                    <input type="date" id="feedbackDate" class="feedback-input">
                </div>
            </div>

            <!-- Self-Analysis Special Fields -->
            <div id="selfAnalysisFields" class="self-analysis-section" style="display: none;">
                <div class="form-group">
                    <label class="feedback-label">My Goals for This Draft:</label>
                    <textarea id="selfGoals" class="feedback-textarea" rows="2" placeholder="What are you trying to achieve?"></textarea>
                </div>
                <div class="form-group">
                    <label class="feedback-label">What I'm Trying to Improve:</label>
                    <textarea id="selfImproving" class="feedback-textarea" rows="2" placeholder="What specific areas do you want to work on?"></textarea>
                </div>
            </div>

            <!-- Feedback Content (Rich Text) -->
            <div class="form-group">
                <label class="feedback-label">
                    <span id="contentLabel">Feedback Content:</span>
                </label>
                <div class="rich-text-toolbar">
                    <button type="button" class="toolbar-btn" data-command="bold" title="Bold">
                        <strong>B</strong>
                    </button>
                    <button type="button" class="toolbar-btn" data-command="italic" title="Italic">
                        <em>I</em>
                    </button>
                    <button type="button" class="toolbar-btn" data-command="underline" title="Underline">
                        <u>U</u>
                    </button>
                    <span class="toolbar-divider">|</span>
                    <button type="button" class="toolbar-btn" data-command="insertUnorderedList" title="Bullet List">
                        â€¢ List
                    </button>
                    <button type="button" class="toolbar-btn" data-command="insertOrderedList" title="Numbered List">
                        1. List
                    </button>
                </div>
                <div id="feedbackContentEditor" class="feedback-editor" contenteditable="true" data-placeholder="Type your feedback here..."></div>
            </div>

            <!-- Tags -->
            <div class="form-group">
                <label class="feedback-label">Tags (optional):</label>
                <div class="tags-input-container">
                    <div id="feedbackTagsDisplay" class="tags-display"></div>
                    <input type="text" id="feedbackTagsInput" class="feedback-input tags-input" placeholder="Add tags (press Enter)">
                </div>
                <div class="suggested-tags">
                    <span class="suggested-tag-label">Suggested:</span>
                    <button type="button" class="suggested-tag" data-tag="thesis">thesis</button>
                    <button type="button" class="suggested-tag" data-tag="structure">structure</button>
                    <button type="button" class="suggested-tag" data-tag="evidence">evidence</button>
                    <button type="button" class="suggested-tag" data-tag="grammar">grammar</button>
                    <button type="button" class="suggested-tag" data-tag="style">style</button>
                    <button type="button" class="suggested-tag" data-tag="argument">argument</button>
                </div>
            </div>

            <!-- File Attachments -->
            <div class="form-group">
                <label class="feedback-label">Attachments (optional):</label>
                <div class="file-upload-area">
                    <input type="file" id="feedbackFileInput" multiple accept=".pdf,.jpg,.jpeg,.png,.gif,.doc,.docx" style="display: none;">
                    <button type="button" class="file-upload-btn" id="feedbackUploadBtn">
                        ðŸ“Ž Upload File
                    </button>
                    <div id="feedbackAttachmentsList" class="attachments-list"></div>
                </div>
            </div>

            <!-- Understanding Demonstration -->
            <div class="understanding-section" id="understandingSection" style="display: none;">
                <h5>ðŸ’¡ Demonstrate Your Understanding</h5>

                <div class="understanding-prompts">
                    <div class="understanding-prompt-group">
                        <label class="understanding-prompt-label">
                            Explain this feedback in your own words:
                        </label>
                        <textarea id="understandingExplanation" class="understanding-prompt-textarea"
                                  placeholder="Paraphrase the feedback to show you understand what it means..."></textarea>
                        <div class="understanding-help-text">
                            Restating feedback helps ensure you've interpreted it correctly.
                        </div>
                    </div>

                    <div class="understanding-prompt-group">
                        <label class="understanding-prompt-label">
                            How will you address this in your next draft?
                        </label>
                        <textarea id="understandingActionPlan" class="understanding-prompt-textarea"
                                  placeholder="List specific changes you plan to make based on this feedback..."></textarea>
                        <div class="understanding-help-text">
                            Be concrete: "I will revise my thesis to be more specific" is better than "I will fix it."
                        </div>
                    </div>

                    <div class="understanding-prompt-group">
                        <label class="understanding-prompt-label">
                            Questions or clarifications needed (optional):
                        </label>
                        <textarea id="understandingQuestions" class="understanding-prompt-textarea" rows="3"
                                  placeholder="What questions do you still have about this feedback?"></textarea>
                        <div class="understanding-help-text">
                            It's okay to have questions! Note them here so you can ask your instructor or consultant.
                        </div>
                    </div>

                    <div class="understanding-checkbox-wrapper">
                        <input type="checkbox" id="feedbackUnderstoodCheckbox" disabled>
                        <label class="understanding-checkbox-label" for="feedbackUnderstoodCheckbox">
                            <span id="understandingCheckboxText">I understand this feedback</span>
                            <span id="understandingCheckboxHint" style="display: block; font-size: 0.8rem; font-weight: normal; color: #856404; margin-top: 4px;">
                                Complete all three fields above (minimum 15 characters each) to mark as understood
                            </span>
                        </label>
                    </div>
                </div>
            </div>

            <!-- Form Buttons -->
            <div class="feedback-form-buttons">
                <button class="feedback-delete-btn" id="feedbackDeleteBtn" style="display: none;">Delete Feedback</button>
                <button class="feedback-cancel-btn" id="feedbackCancelBtn">Cancel</button>
                <button class="feedback-save-btn" id="feedbackSaveBtn">Save Feedback</button>
            </div>
        </div>

        <!-- Synthesis & Priorities View -->
        <div id="feedbackSynthesisView" class="feedback-synthesis-view" style="display: none;">
            <div class="synthesis-header">
                <button class="synthesis-back-btn" id="synthesisBackBtn">â† Back to List</button>
                <h4>Synthesis & Revision Priorities</h4>
            </div>

            <div class="synthesis-content">
                <!-- Reflection Section -->
                <div class="synthesis-reflection-section">
                    <h5>ðŸ“ Reflect on Your Feedback</h5>
                    <p class="synthesis-help-text">
                        After reviewing all your feedback, take time to identify patterns and plan your revision strategy.
                    </p>

                    <div class="synthesis-textarea-group">
                        <label class="synthesis-label">
                            <span class="synthesis-label-text">ðŸ¤ Convergence: Where does feedback agree?</span>
                            <span class="synthesis-label-hint">What themes or patterns emerge across different sources?</span>
                        </label>
                        <textarea id="synthesisConvergence" class="synthesis-textarea"
                                  placeholder="Example: Both my instructor and peer reviewers mentioned that my thesis needs to be more specific. The writing center consultant also suggested focusing my argument more clearly..."
                                  rows="6"></textarea>
                    </div>

                    <div class="synthesis-textarea-group">
                        <label class="synthesis-label">
                            <span class="synthesis-label-text">âš–ï¸ Divergence: Where does feedback conflict?</span>
                            <span class="synthesis-label-hint">How will you resolve contradictions or choose between competing suggestions?</span>
                        </label>
                        <textarea id="synthesisDivergence" class="synthesis-textarea"
                                  placeholder="Example: My instructor wants me to add more evidence, but my peer said the paper feels too cluttered with examples. I think I'll add more evidence but be more selective about which examples I include..."
                                  rows="6"></textarea>
                    </div>
                </div>

                <!-- Revision Priorities List -->
                <div class="synthesis-priorities-section">
                    <h5>ðŸ“Š My Revision Priorities</h5>
                    <p class="synthesis-help-text">
                        List the specific revisions you plan to make, in order of priority. Tag each by scope and impact.
                    </p>

                    <!-- Add Priority Form -->
                    <div class="priority-add-form">
                        <input type="text" id="priorityInput" class="priority-input"
                               placeholder="Describe a specific revision you plan to make..." />

                        <div class="priority-tags-selector">
                            <div class="priority-tag-group">
                                <label class="priority-tag-label">Scope:</label>
                                <label class="priority-tag-option">
                                    <input type="radio" name="priorityScope" value="local" checked>
                                    <span>Local (word/sentence)</span>
                                </label>
                                <label class="priority-tag-option">
                                    <input type="radio" name="priorityScope" value="global">
                                    <span>Global (structure/argument)</span>
                                </label>
                            </div>

                            <div class="priority-tag-group">
                                <label class="priority-tag-label">Impact:</label>
                                <label class="priority-tag-option">
                                    <input type="radio" name="priorityImpact" value="low" checked>
                                    <span>Low Impact</span>
                                </label>
                                <label class="priority-tag-option">
                                    <input type="radio" name="priorityImpact" value="high">
                                    <span>High Impact</span>
                                </label>
                            </div>
                        </div>

                        <button class="priority-add-btn" id="addPriorityBtn">+ Add Priority</button>
                    </div>

                    <!-- Priorities List -->
                    <div class="priorities-list" id="prioritiesList">
                        <!-- Priorities will be rendered here -->
                    </div>
                </div>

                <!-- Save Button -->
                <div class="synthesis-save-section">
                    <button class="synthesis-save-btn" id="synthesisSaveBtn">Save Synthesis Notes</button>
                </div>
            </div>
        </div>
    </div>
</div>

<!-- Data Manager -->
<div class="data-manager">
    <div id="dataStatus" class="data-status"></div>
</div>

<!-- Restore Banner (will be added dynamically) -->
    </div>
</div>


    <!-- About Modal -->
    <!-- Restore Session Modal -->
    <div id="restoreSessionModal" class="modal" style="display: none; align-items: center; justify-content: center; z-index: 10000;">
        <div class="modal-content" style="max-width: 450px; width: 90%; padding: 25px; margin: 0;">
            <span class="modal-close" id="restoreSessionModalClose">&times;</span>
            <h2 style="color: var(--primary-dark); margin: 0 0 10px 0; font-size: 1.3rem;">
                ðŸ”„ Resume Previous Session?
            </h2>
            <p id="restoreSessionMessage" style="margin: 0 0 15px 0; color: var(--text-secondary); line-height: 1.5;"></p>
            <div style="display: flex; gap: 10px; justify-content: flex-end; border-top: 1px solid var(--border-color); padding-top: 15px;">
                <button class="annotation-cancel-btn" id="startFreshBtn">Start Fresh</button>
                <button class="annotation-save-btn" id="restoreSessionBtn">Restore Session</button>
            </div>
        </div>
    </div>

    <div id="aboutModal" class="modal">
        <div class="modal-content">
            <span class="modal-close" id="aboutModalClose">&times;</span>
            <h3>What is this site for?</h3>
            <div>
                <p>Expert writers often say that writing is 99 percent revision. That's not just a comment on how hard it is to write well. It also reveals how writing skills are really developed.</p>
                <br>
                <p>At EWP, we believe people improve as writers when they learn to revise more holistically, more strategically, and more often. The purpose of this website is to draw writers attention to this most important part of the writing process. It highlights large and small changes, and invites writers to reflect upon the nature, scope, goal, and impact of these changes. Honing your revision skills means honing your writing skills.</p>
                <br>
                <p>The "Mercer Street" tab is a window to the writing processes of exceptional undergraduate writers. Draft by draft, you can see how contributors developed and refined their ideas iteratively, much in the same way that engineers improve on each prototype.</p>
                 <br>
                 </div>
                 <div>
                <h3>A research-backed approach</h3>
                <p>In 1980, Harvard researcher Nancy Sommers published a landmark study comparing the revision habits of novice and expert writers. Her findings revealed several fundamentally different approaches to and understandings of revision:</p>
                <br>
                <p><strong>For novice writers,</strong> revising involves mostly small changes, like word substitutions or addressing mechanical and grammatical errors. This minimalist approach to revision reflects novice's beliefs about the very purpose of writing. For most novices, writing is primarily a tool for expression--to "get down" our ideas on the page. This understanding of writing requires little use of revision.</p>
                <br>
                <p><strong>For experts,</strong> revision means much more. It can mean adding, deleting, or rewriting entire paragraphs. It can mean introducing new evidence and considering alternative perspectives. It can mean reinforcing, challenging or transforming one's initial assumptions and beliefs. This maximalist approach to revision reflects a profoundly different theory about the purpose of writing. For experts, writing isn't only a tool for expression but also exploration and discovery. They turn to writing to generate and better understand new ideas, and this demands revision, literally re-envisioning their ideas.</p>
                <br>
            </div>
        <div>
                <h3>How This Tool Helps</h3>
                <p>By examining the nature and scope of revisions, writers can identify current revision habits and patterns, identify opportunities for more substantial revision, and begin utilizing writing not merely to express ideas you already have, but also to expand, refine, challenge, and develop your thinking as well.</p>
            </div>
            </div>
        </div>
    </div>

    <script>
        // Global variables
        let currentPosition = 0;
        let totalPanels = 0;
        let currentEssay = null;
        
        // Function to show error message
        function showError(message) {
            const errorMessage = document.getElementById('errorMessage');
            if (errorMessage) {
                errorMessage.textContent = message;
                errorMessage.style.display = 'block';
            }
        }



        const quotes = [
    { text: "By the time I am nearing the end of a story, the first part will have been reread and altered and corrected at least one hundred and fifty times. I am suspicious of both facility and speed. Good writing is essentially rewriting.", author: "Roald Dahl" },
    { text: "I'm a rewriter. That's the part I like best...once I have a pile of paper to work with, it's like having the pieces of a puzzle. I just have to put the pieces together to make a picture.", author: "Judy Blume" },
    { text: "The beautiful part of writing is that you don't have to get it right the first time, unlike, say, a brain surgeon.", author: "Robert Cormier" },
    { text: "Books aren't writtenâ€”they're rewritten. Including your own.", author: "Michael Crichton" },
    { text: "Half my life is an act of revision.", author: "John Irving" },
    { text: "It is no sign of weakness or defeat that your manuscript ends up in need of major surgery. This is common in all writing and among the best of writers.", author: "E.B. White" },
    { text: "Writing is rewriting. A writer must learn to deepen characters, trim writing, intensify scenes.", author: "Richard North Patterson" },
    { text: "I have rewrittenâ€”often several timesâ€”every word I have ever written. My pencils outlast their erasers.", author: "Vladimir Nabokov" },
    { text: "I'm not a very good writer, but I'm an excellent rewriter.", author: "James Michener" },
    { text: "The best advice I can give is to put it away until you can read it with new eyes.", author: "Neil Gaiman" },
    { text: "Revision is one of the exquisite pleasures of writing.", author: "Bernard Malamud" },
    { text: "The writer's life is a life of revisions.", author: "Jonathan Franzen" },
    { text: "The novel really happens in the revisions.", author: "Tama Janowitz" },
    { text: "I love revisions...We can't go back and revise our lives, but revising what we have written comes closest.", author: "Katherine Paterson" },
    { text: "Writing and rewriting are a constant search for what it is one is saying.", author: "John Updike" },
    { text: "Reread, rewrite, reread, rewrite. If it still doesn't work, throw it away.", author: "Helen Dunmore" },
    { text: "I edit as I write. I revise endlessly. I don't go forward until I know that what I've written is as good as I can make it.", author: "Anita Shreve" }
];

const titleContainer = document.querySelector('.header-title');
const titleEl = titleContainer.querySelector('h1');
const originalTitle = titleEl.innerHTML;

let showingTitle = true;

/**
 * Handles the fade-out/fade-in transition between title and quotes.
 */
function cycleDisplay() {
    // Trigger fizzle-out animation
    titleEl.classList.remove('fizzle-in');
    void titleEl.offsetWidth; // force reflow
    titleEl.classList.add('fizzle-out');

    setTimeout(() => {
        titleEl.classList.remove('fizzle-out');

        let nextDelay;
        
        if (showingTitle) {
            // Show random quote
            const randomIndex = Math.floor(Math.random() * quotes.length);
            const quote = quotes[randomIndex];
            titleContainer.classList.add('quote-mode');
            titleEl.innerHTML = `
                <span style="display: block; margin-bottom: 8px;">${quote.text}</span>
                <span class="quote-author">${quote.author}</span>
            `;
            showingTitle = false;
            nextDelay = 10000; // Show quote for 10 seconds
        } else {
            // Show main title again
            titleContainer.classList.remove('quote-mode');
            titleEl.innerHTML = originalTitle;
            showingTitle = true;
            nextDelay = 30000; // Show title for 30 seconds
        }

        // Trigger fizzle-in
        void titleEl.offsetWidth;
        titleEl.classList.add('fizzle-in');
        
        // Schedule next transition with appropriate delay
        setTimeout(cycleDisplay, nextDelay);
    }, 1200);
}

// Start showing title for 30 seconds before first quote
setTimeout(cycleDisplay, 30000);
        
// Add this function anywhere in your script section (before generateAdvancedDiff is called)
function determineRevisionLevel(text) {
    // Normalize the text for consistent analysis
    const normalizedText = text.trim();
    
    // Define clear thresholds
    const words = (normalizedText.match(/\b\w+['']?\w*\b/g) || []).length;
    const sentences = (normalizedText.match(/[.!?]+[\s\n]+/g) || []).length;
    const hasMultipleParagraphs = /\n\s*\n/.test(normalizedText);
    
    // Clear hierarchical logic
    if (hasMultipleParagraphs || sentences >= 3) {
        return 'paragraph';
    } else if (sentences >= 1 && words >= 6) {
        return 'sentence';
    } else if (words >= 3) {
        return 'phrase';
    } else if (words >= 1) {
        return 'word';
    } else {
        return 'char'; // For punctuation-only changes
    }
}

// Fix broken words where DEL/INS splits happen in the middle of a word
// Example: "act[ual][ive]ly" -> "[del:actually][ins:actively]"
// Example: "[stalk][follow]ed" -> "[del:stalked][ins:followed]"
// Example: "[t]he[i]r" -> "[del:her][ins:their]"
function fixBrokenWords(diffs) {
    const DIFF_DELETE = -1;
    const DIFF_INSERT = 1;
    const DIFF_EQUAL = 0;

    let pointer = 0;

    while (pointer < diffs.length) {
        // Look for patterns: EQUAL-DELETE-INSERT or DELETE-INSERT-EQUAL

        // Pattern 1: EQUAL-DELETE-INSERT (prefix case: "act[ual][ive]ly")
        if (pointer > 0 &&
            pointer < diffs.length - 1 &&
            diffs[pointer][0] === DIFF_DELETE &&
            diffs[pointer + 1][0] === DIFF_INSERT &&
            diffs[pointer - 1][0] === DIFF_EQUAL) {

            const prefix = diffs[pointer - 1][1];
            const deletion = diffs[pointer][1];
            const insertion = diffs[pointer + 1][1];

            // Check if the equal part ends with word characters (could be part of the word)
            const deletionMatch = deletion.match(/^(\w+)/);
            const prefixMatch = prefix.match(/(\w+)$/);
            if (deletionMatch && prefixMatch && prefixMatch[1].length > 0) {
                const wordPrefix = prefixMatch[1];
                const remainingPrefix = prefix.substring(0, prefix.length - wordPrefix.length);

                // Move the word prefix into the deletion and insertion
                diffs[pointer - 1][1] = remainingPrefix;
                diffs[pointer][1] = wordPrefix + deletion;
                diffs[pointer + 1][1] = wordPrefix + insertion;
            }
        }

        // Pattern 2: DELETE-INSERT-EQUAL (suffix case: "[stalk][follow]ed")
        if (pointer < diffs.length - 2 &&
            diffs[pointer][0] === DIFF_DELETE &&
            diffs[pointer + 1][0] === DIFF_INSERT &&
            diffs[pointer + 2][0] === DIFF_EQUAL) {

            const deletion = diffs[pointer][1];
            const insertion = diffs[pointer + 1][1];
            const suffix = diffs[pointer + 2][1];

            // Check if the equal part starts with word characters (could be part of the word)
            const suffixMatch = suffix.match(/^(\w+)/);
            if (suffixMatch && suffixMatch[1].length > 0) {
                const wordSuffix = suffixMatch[1];
                const remainingSuffix = suffix.substring(wordSuffix.length);

                // Move the word suffix into the deletion and insertion
                diffs[pointer][1] = deletion + wordSuffix;
                diffs[pointer + 1][1] = insertion + wordSuffix;
                diffs[pointer + 2][1] = remainingSuffix;
            }
        }

        // Pattern 3: INSERT-EQUAL-INSERT (middle word case: "[t]he[i]r")
        if (pointer < diffs.length - 2 &&
            diffs[pointer][0] === DIFF_INSERT &&
            diffs[pointer + 1][0] === DIFF_EQUAL &&
            diffs[pointer + 2][0] === DIFF_INSERT) {

            const firstInsert = diffs[pointer][1];
            const equalPart = diffs[pointer + 1][1];
            const secondInsert = diffs[pointer + 2][1];

            // Check if the equal part is entirely word characters (a complete word or part of one)
            if (/^\w+$/.test(equalPart)) {
                // Look backward to get trailing word characters from previous EQUAL
                let prefixFromBefore = '';
                let remainingBefore = '';
                if (pointer > 0 && diffs[pointer - 1][0] === DIFF_EQUAL) {
                    const beforeText = diffs[pointer - 1][1];
                    const match = beforeText.match(/(\w+)$/);
                    if (match) {
                        prefixFromBefore = match[1];
                        remainingBefore = beforeText.substring(0, beforeText.length - prefixFromBefore.length);
                    } else {
                        remainingBefore = beforeText;
                    }
                }

                // Look forward to get leading word characters from next EQUAL
                let suffixFromAfter = '';
                let remainingAfter = '';
                if (pointer + 3 < diffs.length && diffs[pointer + 3][0] === DIFF_EQUAL) {
                    const afterText = diffs[pointer + 3][1];
                    const match = afterText.match(/^(\w+)/);
                    if (match) {
                        suffixFromAfter = match[1];
                        remainingAfter = afterText.substring(suffixFromAfter.length);
                    } else {
                        remainingAfter = afterText;
                    }
                }

                // Build complete words
                const originalWord = prefixFromBefore + equalPart + suffixFromAfter;
                const newWord = prefixFromBefore + firstInsert + equalPart + secondInsert + suffixFromAfter;

                // Update diffs array
                // Add remaining before part if exists
                if (pointer > 0 && diffs[pointer - 1][0] === DIFF_EQUAL && remainingBefore) {
                    diffs[pointer - 1][1] = remainingBefore;
                } else if (pointer > 0 && diffs[pointer - 1][0] === DIFF_EQUAL && !remainingBefore) {
                    // Remove the empty before element later
                    diffs[pointer - 1][1] = '';
                }

                // Replace INSERT-EQUAL-INSERT with DELETE-INSERT
                diffs[pointer][0] = DIFF_DELETE;
                diffs[pointer][1] = originalWord;
                diffs[pointer + 1][0] = DIFF_INSERT;
                diffs[pointer + 1][1] = newWord;

                // Remove the second INSERT (it's now merged)
                diffs.splice(pointer + 2, 1);

                // Update or remove the after part if exists
                if (pointer + 2 < diffs.length && diffs[pointer + 2][0] === DIFF_EQUAL) {
                    if (remainingAfter) {
                        diffs[pointer + 2][1] = remainingAfter;
                    } else {
                        diffs[pointer + 2][1] = '';
                    }
                }
            }
        }

        pointer++;
    }

    // Clean up any empty diffs that may have been created
    for (let i = diffs.length - 1; i >= 0; i--) {
        if (diffs[i][1].length === 0) {
            diffs.splice(i, 1);
        }
    }
}

function generateAdvancedDiff(text1, text2) {
    try {
        // Use diff-match-patch - it's designed for exactly this use case
        const dmp = new diff_match_patch();
        
        // Configure for prose comparison
        dmp.Diff_Timeout = 2.0; // Allow more time for accuracy
        dmp.Diff_EditCost = 6;  // Higher = treat larger blocks as units (was 4, now 6)
        
        // Generate the diff
        const diffs = dmp.diff_main(text1, text2);
        
        // This is the magic - it semantically groups related changes
        dmp.diff_cleanupSemantic(diffs);
        
        // Further cleanup - merge small changes with neighbors
        dmp.diff_cleanupEfficiency(diffs);
        
        // Custom cleanup: Fix broken words
        fixBrokenWords(diffs);
        
        let html = '';
        
        for (let i = 0; i < diffs.length; i++) {
            const [operation, text] = diffs[i];
            const level = determineRevisionLevel(text);
            
            if (operation === 0) {
                // No change
                html += escapeHtml(text);
            } else if (operation === -1) {
                // Deletion
                html += `<span class="deletion ${level}-level">${escapeHtml(text)}</span>`;
            } else if (operation === 1) {
                // Addition
                html += `<span class="addition ${level}-level">${escapeHtml(text)}</span>`;
            }
        }
        
        return html;
        
    } catch (error) {
        console.error('Diff error:', error);
        // If all else fails, just show the new text
        return escapeHtml(text2);
    }
}


// Helper to escape HTML
function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}




// Replace the existing formatText function with this:
        function formatText(text) {
            // If the text already has paragraph breaks (double newlines), preserve them
            if (text.includes('\n\n')) {
                return text; // Return as-is, the paragraph structure is already there
            }
            
            // Otherwise, fallback to the old behavior for backward compatibility
            const sentences = text.match(/[^\.!?]+[\.!?]+/g) || [text];
            let formattedText = '';
            
            for (let i = 0; i < sentences.length; i++) {
                formattedText += sentences[i].trim();
                if ((i + 1) % 3 === 0 && i < sentences.length - 1) {
                    formattedText += '\n\n';
                } else if (i < sentences.length - 1) {
                    formattedText += ' ';
                }
            }
            
            return formattedText;
        }

        // File upload functionality
let uploadedFiles = [];

// Replace the existing handleFileUpload function with this corrected version:

function handleFileUpload(files) {
    const fileList = document.getElementById('fileList');
    const compareBtn = document.getElementById('compareFiles');
    
    for (let file of files) {
        if (file.type === 'text/plain' || 
            file.name.endsWith('.txt') || 
            file.name.endsWith('.docx') ||
            file.type === 'application/vnd.openxmlformats-officedocument.wordprocessingml.document') {
            uploadedFiles.push(file);
            addFileToList(file);
        } else {
            showError(`File "${file.name}" is not supported. Please upload .txt or .docx files only.`);
        }
    }
    
    if (uploadedFiles.length > 0) {
        fileList.style.display = 'block';
        
        // Fixed: Show the compare button when 2 or more files are uploaded
        if (uploadedFiles.length >= 2) {
            compareBtn.style.display = 'block';
        } else {
            compareBtn.style.display = 'none';
            showError('Please upload at least 2 files to compare.');
        }
    }

     // Save files to localStorage
     if (uploadedFiles.length > 0) {
        saveFileContents(uploadedFiles);
    }
}

function addFileToList(file) {
    const fileList = document.getElementById('fileList');
    const fileItem = document.createElement('div');
    fileItem.className = 'file-item';
    fileItem.innerHTML = `
        <div>
            <div class="file-name">${file.name}</div>
            <div class="file-size">${(file.size / 1024).toFixed(1)} KB</div>
        </div>
        <button class="remove-file" onclick="removeFile('${file.name}')">Ã—</button>
    `;
    fileList.appendChild(fileItem);
}

function removeFile(fileName) {
    uploadedFiles = uploadedFiles.filter(file => file.name !== fileName);
    refreshFileList();
}

// Also ensure the refreshFileList function properly handles the button visibility:
function refreshFileList() {
    const fileList = document.getElementById('fileList');
    const compareBtn = document.getElementById('compareFiles');
    
    fileList.innerHTML = '';
    
    if (uploadedFiles.length === 0) {
        fileList.style.display = 'none';
        compareBtn.style.display = 'none';
    } else {
        uploadedFiles.forEach(addFileToList);
        fileList.style.display = 'block';
        // Show compare button only when 2 or more files are uploaded
        compareBtn.style.display = uploadedFiles.length >= 2 ? 'block' : 'none';
    }
}

async function compareUploadedFiles() {
    // Show spinner
    document.getElementById('loadingSpinner').style.display = 'flex';
    
    if (uploadedFiles.length < 2) {
        document.getElementById('loadingSpinner').style.display = 'none';
        showError('Please upload at least 2 files to compare.');
        return;
    }
    
    try {
        const fileContents = [];
        for (let file of uploadedFiles) {
            const text = await readFileContent(file);
            const fileName = file.name.replace(/\.(txt|docx)$/, '');
            fileContents.push({
                version: fileName,
                text: text
            });
        }
        
        const uploadedEssay = {
            title: "Uploaded Files Comparison",
            author: "User Upload", 
            description: "Comparison of uploaded text files",
            drafts: fileContents
        };
        
        currentEssay = uploadedEssay;
        const panelInfo = createPanels(uploadedEssay);
        totalPanels = panelInfo.length;
        currentPosition = 0;
        
        // Hide upload section
        const uploadSection = document.querySelector('.upload-section');
        if (uploadSection) uploadSection.classList.add('hidden');
        
        const comparisonResults = document.getElementById('comparisonResults');
        comparisonResults.style.display = 'block';
        updateSliderPosition();
        updateNavigationInfo(panelInfo);
        
        setupNewComparisonButton();
        
        // Hide spinner - moved to end
        document.getElementById('loadingSpinner').style.display = 'none';
        
    } catch (error) {
        document.getElementById('loadingSpinner').style.display = 'none';
        showError('Error reading files: ' + error.message);
    }

        // Save state after successful comparison
        saveState();
}
    

async function comparePastedText() {
    // Show spinner
    document.getElementById('loadingSpinner').style.display = 'flex';
    
    // Collect pasted drafts - check all possible fields dynamically
    const drafts = [];
    
    // Get all paste draft sections
    const sections = document.querySelectorAll('.paste-draft-section');
    sections.forEach(section => {
        const draftNum = section.getAttribute('data-draft-num');
        const label = document.getElementById(`paste-label-${draftNum}`).value.trim();
        const text = document.getElementById(`paste-text-${draftNum}`).value.trim();
        
        if (text) {
            drafts.push({
                version: label || `Draft ${draftNum}`,
                text: text
            });
        }
    });
    
    // Validate
    if (drafts.length < 2) {
        document.getElementById('loadingSpinner').style.display = 'none';
        showError('Please paste at least 2 drafts to compare.');
        return;
    }
    
    try {
        const pastedEssay = {
            title: "Pasted Text Comparison",
            author: "User Input",
            description: "Comparison of pasted text drafts",
            drafts: drafts
        };
        
        currentEssay = pastedEssay;
        const panelInfo = createPanels(pastedEssay);
        totalPanels = panelInfo.length;
        currentPosition = 0;
        
        // Hide upload section
        const uploadSection = document.querySelector('.upload-section');
        if (uploadSection) uploadSection.classList.add('hidden');
        
        const comparisonResults = document.getElementById('comparisonResults');
        comparisonResults.style.display = 'block';
        updateSliderPosition();
        updateNavigationInfo(panelInfo);
        
        setupNewComparisonButton();
        
        // Hide spinner
        document.getElementById('loadingSpinner').style.display = 'none';
        
        // Save state
        saveState();
        
    } catch (error) {
        document.getElementById('loadingSpinner').style.display = 'none';
        showError('Error comparing pasted text: ' + error.message);
    }
}

async function readFileContent(file) {
    return new Promise((resolve, reject) => {
        if (file.name.endsWith('.docx') || file.type === 'application/vnd.openxmlformats-officedocument.wordprocessingml.document') {
            // Handle .docx files with mammoth
            const reader = new FileReader();
            reader.onload = async function(e) {
                try {
                    const arrayBuffer = e.target.result;
                    const result = await mammoth.extractRawText({arrayBuffer: arrayBuffer});
                    resolve(result.value);
                } catch (error) {
                    reject(new Error('Failed to read .docx file: ' + error.message));
                }
            };
            reader.onerror = () => reject(new Error('Failed to read file'));
            reader.readAsArrayBuffer(file);
        } else {
            // Handle .txt files
            const reader = new FileReader();
            reader.onload = e => resolve(e.target.result);
            reader.onerror = () => reject(new Error('Failed to read file'));
            reader.readAsText(file);
        }
    });
}


        
        // Sample essay data with more realistic content
        const exampleEssays = {
            essay1: {
                title: "Ping! Panic! Repeat!",
                author: "Braden Ou",
                description: "An ethnographic study exploring smartphone use",
                drafts: [
                { 
                version: "Draft 1", 
                text: `Ping! Panic! Repeat!
Picture a late-night subway ride on the F subway line: fluorescent lights flicker overhead, a half-empty car rattles through the tunnel, and every few seconds somebody's phone buzzes. "Armed robberyâ€”Upper East Side," flashes one push notification. "Man shoved onto tracks in Midtown," warns another. A teenager beside you scrolls an endless reel of grainy security-camera clips, often with some unsuspecting victim about to be assaulted; a middle-aged commuter checks the Citizen app, its red map pins pulsing like fresh wounds across the city grid. Even the PA system crackles with an "If you see something, say something" reminder. Surrounded by screens and alerts, the train car feels poised for disaster, and instinctively, you tighten your grip on the handrail, eyes darting toward every stranger who wanders too close.

Yet that sense of imminent danger is becoming mostly a digital mirage. According to the NYPD's first-quarter 2025 report, subway crime is down double digits, with zero murdersâ€”the safest start to a year in at least seven years and among the lowest violent-crime tallies ever recorded on the system (New York Daily News). What makes the ride feel dangerous isn't an epidemic of violence but the smartphone in every pocket, collapsing the city's rare worst moments into a relentless real-time news crawl. The very device that lets us summon help also directs each tragedy straight into our brains, inflating our perceived risk on an otherwise routine commute. This paradox creates an interesting question: How does the tension between smartphones' designed purpose of connection and their more often actual use of distraction and social shielding reflect more profound anxieties in modern society? To investigate this, I spent three weeks in February of 2025 riding numerous subway lines and bus routes, documenting episodes of public phone use.

Smartphones were never meant to play this role. When Steve Jobs unveiled the iPhone in 2007, he called it "a widescreen iPod with touch controls; a revolutionary mobile phone; and a breakthrough Internet communications device" (Pangambam). In the years since, ownership of this powerful device has soared to 91 percent of American adults. (Pew Research Center). Today, it constructs personal media bubbles that double as social shields, offering connection while encouraging retreat.

Technology sociologist Sherry Turkle, a professor of social studies of science and technology at Massachusetts Institute of Technology, has coined the term "tethered self," which illustrates this phenomenon. According to Turkle, smartphones have created a state of society where we are "always-on/always-on-you," a reference to how smartphones are always readily available to us as a society (Turkle 121). This "tethered self" creates a world where we maintain a constant psychological readiness for the connections that matter to us digitally. But many people embrace this "tethered self," actively choosing to escape into this digital world even if not called upon by their connections in the digital world. This, as Turkle continues, creates a "liminal space between the physical real and its digital lives on multiple screens" (Turkle 122). We are never fully here, yet never fully elsewhere either.

Turkle's concept describes exactly what my field notes expose: riders feel safest the moment they retreat into a device that simultaneously stokes their fear. Riding the M103 down Third Avenue, I watched two friends chat easily. They had a nice, long conversation, talking about their daily lives, with neither of them holding a smartphone at all. After a while, it seemed like one of the friends had reached his stop. He said goodbye to his friend and left the bus, leaving the other friend to ride alone. The moment the remaining rider was alone, he cast a cautious glance around, made brief eye contact with me, and fled into his phone. When I made eye contact, I also felt a similar urge, pulling out my phone to start playing video games on it. Interestingly enough, this seems to indicate that this urge is contagious in a sense. In my mind, eye contact with a stranger was uncomfortable, and I felt a need to intentionally distract myself with a phone to try to relieve myself of the awkward situation. I imagine that the stranger also felt the same way, suddenly feeling a void that was once filled with conversation with his friend. Part of this does have a cultural backing to it; there are plenty of folktales on the New York City subway about how making momentary eye contact with a stranger resulted in an altercation. As such, it has become a social norm for people to actively avoid eye contact, and the smartphone has been repurposed as a tool for this use. I could be doing absolutely nothing on my phone, just staring at the weather for the hundredth time, yet it creates the sense of safety that I will not accidentally stare right into someone's eyes, possibly creating an unsettling and tense situation. This incident revealed a profound irony: devices engineered to enhance connection have become tools that help us avoid human contact. The smartphone's design makes it an ideal shieldâ€”its screen demands attention and signals busyness to others, creating a socially acceptable way to opt out of physical presence while maintaining the appearance of productivity.  This is the crux of Turkle's point about technology: We have become so attached to our tethers that not only do the tethers hold us tightly, but we also hold the tethers tightly as well.

This protective shield extends to more threatening situations as well. In another one of my observations, I noticed that there was a woman in a subway station, and a man approached her asking for money. As I watched this interaction unfold, I could see his extended hand and hear his repeated requests for "spare change" and mentions of homelessnessâ€”common signs of panhandling in NYC. She started quickly walking away while looking at her phone, very intentionally trying not to look at him while moving herself towards the station's main area, likely to find more people in case the man was to cause her any harm. What I found really interesting was that the woman was on her phone the whole time. She stared at it the whole time, even though the more probable threat was the person behind her rather than her smartphone. I feel like it would've been much smarter for her to look at the person and make sure he wasn't going to endanger her. I suppose there is the chance that staring at the man would have further antagonized him, but in a case where someone is already following you in an almost empty station, I think that's a risk worth taking to protect yourself. Staring at your phone, even superficially by not paying attention to the content on it, still heavily limits her ability to react in case things escalate. Once again, another example of being not fully here, but not really being fully elsewhere either.

Interestingly, this behavior reveals a psychological protective mechanism. One reason why I think she might be doing this is because her mind wanted to actively distract herself to avoid the trauma that she is actually being stalked. The human mind seems to have an ability to forcibly block things that it does not want to think about by moving you to somewhere else mentally, spending your mind's resources associating yourself with another environment. Having fewer resources in your mind telling you how bad the current situation is limits the total pain it could cause you, according to a study done by Dr. Denise M. Sloan, an associate director at the National Center for PTSD (Swaim 5). Here is another example of the smartphone functioning as a social shield â€“ providing a visual barrier, a reason not to engage, and an escape portal from an uncomfortable reality. Her behavior demonstrates what Turkle calls the "tethered self" â€“ being physically present but mentally elsewhere. The woman's smartphone allowed her to psychologically escape a dangerous situation by tethering mind to a safer digital space, placing herself within the liminal space of reality and the digital world. The dual existence of these two worlds plays an interesting role in this situation: while her body remained vulnerable in the subway station, her attention ran away from the threat. This demonstrates how smartphones can function as psychological protection devices, not just from potential physical threats but from the emotional discomfort of confrontation. This protective function was never explicitly designed into smartphones, yet it has become one of their most common uses in public spaces.

But here lies the central paradox of smartphone use in urban spaces. If phones can soothe discomfort, they just as readily stoke it. In the moment, a vibrating phone offers a reassuring ritual: glancing down lets us escape awkward eye contact, confirm a train's ETA, or signal to friends that we're still alive in the tunnel dead zone. Yet the very streams that calm us also keep our anxiety circuits primed. Citizen, Twitter, and 24-hour push notifications bombard New Yorkers with every robbery, shove, and scuffle, however rare. Each red banner lights up the brain's threat-detection pathways, triggering the same cortisol spike we'd feel if the incident were unfolding a few feet away. Doom-scrolling further reinforces the loop: every swipe delivers fresh jolts of negative stimulus and a hit of dopamine for "staying informed," so users oscillate between dread and reward. The result is what researchers call hyper-vigilant fatigue: the body's fight-or-flight switch remains half-pressed, so even the ordinary clang of closing doors feels ominous (Gotter). In a city that never sleeps, the phone that never rests ensures anxiety never fully powers down.

The gap between how smartphones were designed and how they're actually used raises important questions for technology designers. When Jobs unveiled the iPhone, he emphasized productivity, entertainment, and communication, not social avoidance or psychological self-protection, a common norm in the confines of New York City. This disconnect is a great example of what Langdon Winner, the Chair of Humanities and Social Studies at Rensselaer Polytechnic Institute, described as "technological somnambulism" â€“ a societal tendency to sleepwalk through technological changes that fundamentally reshape our societal activities. As Winner argues, "technologies are not merely aids to human activity, but also powerful forces acting to reshape that activity and its meaning" (Winner 4). We adopt smartphones without fully examining their side effects, and we only stumble into how deeply they have altered our social behaviors and norms. Yet my observations suggest these unintended functions fulfill genuine human needs in an increasingly crowded, stimulating world. How might technology be designed differently if engineers acknowledged these actual usage patterns? What ethical responsibility do designers have when creating tools that so profoundly shape social behavior?

My observations reveal that smartphones have evolved beyond their designers' intentions into sophisticated social tools that help manage modern anxieties. The gap between designed purpose and actual use reflects our paradoxical desires: we crave both connection and isolation, productivity and distraction, social engagement and personal retreat. This causes us to be increasingly uncomfortable with our social moments and the humanity and vulnerability such interactions require. This tension places significant ethical responsibility on technology designers, who must recognize that their creations don't simply serve stated functions but actively reshape social norms and human behavior. Understanding this relationship requires moving beyond simple narratives of addiction or convenience to recognize how we actively repurpose technology to manage complex social realities. As we design future technologies, acknowledging how these tensions are developed might help create tools that better align with genuine human needs rather than inadvertently amplifying our social anxieties.`
            },
            { 
    version: "Draft 2", 
    text: `Ping! Panic! Repeat!

Picture a late-night subway ride on the F subway line: fluorescent lights flicker overhead, a half-empty car rattles through the tunnel, and every few seconds somebody's phone buzzes. "Armed robberyâ€”Upper East Side," flashes one push notification. "Man shoved onto tracks in Midtown," warns another. A teenager beside you scrolls an endless reel of grainy security-camera clips, often with some unsuspecting victim about to be assaulted; a middle-aged commuter checks the Citizen app, its red map pins pulsing like fresh wounds across the city grid. Even the PA system crackles with an "If you see something, say something" reminder. Surrounded by screens and alerts, the train car feels poised for disaster, and instinctively, you tighten your grip on the handrail, eyes darting toward every stranger who wanders too close.

Yet that sense of imminent danger is becoming mostly a digital mirage. According to the NYPD's first-quarter 2025 report, subway crime is down double digits, with zero murdersâ€”the safest start to a year in at least seven years and among the lowest violent-crime tallies ever recorded on the system (New York Daily News). If crime is at historic lows, what explains the persistent feeling of danger that permeates subway cars? The answer may lie in the device nearly every rider carries: Smartphones. While smartphones were designed to connect us and keep us informed, their actual use in public spaces reveals a more complex aspect of how we navigate modern urban anxieties. To investigate this, I spent three weeks in February of 2025 riding numerous subway lines and bus routes, documenting episodes of public phone use.

The patterns I observed would have surprised even Steve Jobs, who envisioned this device bringing people together rather than helping them avoid each other. When Jobs unveiled the iPhone in 2007, Jobs spoke of seamless communication and instant connection (Pangambam). Today, it constructs personal media bubbles that double as social shields, offering connection while encouraging retreat.

Technology sociologist Sherry Turkle, a professor of social studies of science and technology at Massachusetts Institute of Technology, has coined the term "tethered self," which illustrates this phenomenon. This "tethered self" creates a world where we maintain a constant psychological readiness for the connections that matter to us digitally. According to Turkle, smartphones have created a state of society where we are "always-on/always-on-you," a reference to how smartphones are always readily available to us as a society (Turkle 121). But many people embrace this "tethered self," actively choosing to escape into this digital world even if not called upon by their connections in the digital world. This, as Turkle continues, creates a "liminal space between the physical real and its digital lives on multiple screens" (Turkle 122). We are never fully here, yet never fully elsewhere either.

This liminal space helps explain what I observed in my field notes: riders repeatedly chose digital retreat over physical engagement when faced with social uncertainties. The tether acts as a quick way for users to create psychological buffers, a protection against the demands of human interaction. Riding the M103 down Third Avenue, I watched two friends chat easily. They had a nice, long conversation, talking about their daily lives, with neither of them holding a smartphone at all. After a while, it seemed like one of the friends had reached his stop. He said goodbye to his friend and left the bus, leaving the other friend to ride alone. The moment the remaining rider was alone, he cast a cautious glance around, made brief eye contact with me, and fled into his phone. When I made eye contact, I also felt a similar urge, pulling out my phone to start playing video games. This simultaneous retreat made me wonder whether digital avoidance might be socially contagious. Maybe when one person withdraws into their device, it signals to others that the digital escape is both accepted and expected. In my mind, eye contact with a stranger was uncomfortable, and I felt a need to intentionally distract myself with a phone to try to relieve myself of the awkward situation. I imagine that the stranger also felt the same way, suddenly feeling a void that was once filled with conversation with his friend. Part of this does have a cultural backing to it; there are plenty of folktales on the New York City subway about how making momentary eye contact with a stranger resulted in an altercation. As such, it has become a social norm for people to actively avoid eye contact, and the smartphone has been repurposed as a tool for this use. I could be doing absolutely nothing on my phone, just staring at the weather for the hundredth time, yet it creates the sense of safety that I will not accidentally stare right into someone's eyes, possibly creating an unsettling and tense situation. This incident revealed a profound irony: devices engineered to enhance connection can also become tools that dissuade it just as easily. The smartphone's design makes it an ideal shieldâ€”its screen demands attention and signals busyness to others, creating a socially acceptable way to opt out of physical presence while maintaining the appearance of productivity. This is the crux of Turkle's point about technology: We have become so attached to our tethers that not only do the tethers hold us tightly, but we also hold the tethers tightly as well.

This protective shield extends to more threatening situations as well. In another one of my observations, I noticed that there was a woman in a subway station, and a man approached her asking for money. As I watched this interaction unfold, I could see his extended hand and hear his repeated requests for "spare change" and mentions of homelessnessâ€”common signs of panhandling in NYC. She started quickly walking away while looking at her phone, keeping her eyes fixed on the screen rather than looking at him while moving herself towards the station's main area, where more people were present. What I found really interesting was that the woman was on her phone the whole time. She stared at it the whole time, even though the more probable threat was the person behind her rather than her smartphone. I feel like it would've been much smarter for her to look at the person and make sure he wasn't going to endanger her. I suppose there is the chance that staring at the man would have further antagonized him, but in a case where someone is already following you in an almost empty station, I think that's a risk worth taking to protect yourself. Staring at your phone, even superficially by not paying attention to the content on it, still heavily limits her ability to react in case things escalate. Once again, another example of being not fully here, but not really being fully elsewhere either.

Interestingly, this behavior reveals a psychological protective mechanism. One reason why I think she might be doing this is because her mind wanted to actively distract herself to avoid the trauma that she is actively being followed. The human mind has the ability to forcibly block things it does not want to think about by mentally shifting you to another place, thereby allocating your mental resources to associate with a different environment. Her mind may have been using what researchers call "peritraumatic dissociation," which is a psychological response that can include emotional numbness and altered perception during stressful events, according to an observational study done by analyzing responses to standardized questionnaires by Dr. Denise M. Sloan, an associate director at the National Center for PTSD (Swaim 5). Here is another example of the smartphone functioning as a social shield â€“ providing a visual barrier, a reason not to engage, and an escape portal from an uncomfortable reality. Her behavior demonstrates what Turkle calls the "tethered self" â€“ being physically present but mentally elsewhere. The woman's smartphone allowed her to psychologically escape a dangerous situation by tethering her mind to a safer digital space, placing herself within the liminal space of reality and the digital world. The dual existence of these two worlds plays an interesting role in this situation: while her body remained vulnerable in the subway station, her attention ran away from the threat. This situation demonstrates how smartphones can function as psychological protection devices, not just from potential physical threats but from the emotional discomfort of confrontation. This protective function was never explicitly designed into smartphones, yet it has become one of their most common uses in public spaces.

But this protective function shows a troubling irony. While phones shield us from immediate discomfort, they also amplify our broader anxieties about urban danger. These devices simultaneously serve as shields from present realities and sources for the constant stream of crime alerts, push notifications, and security footage that make public spaces feel perpetually unsafe (Riddell, 34). This creates the central paradox of smartphone use in urban spaces. If phones can soothe discomfort, they just as readily stoke it. In the moment, a vibrating phone offers a reassuring ritual: glancing down lets us escape awkward eye contact, confirm a train's ETA, or signal to friends that we're still alive in the tunnel dead zone. Yet the very streams that calm us also keep our anxiety circuits primed. Citizen, Twitter, and 24-hour push notifications bombard New Yorkers with every robbery, shove, and scuffle, however rare. Each red banner lights up the brain's triggers the same stress response we'd feel if the incident were unfolding a few feet away (Intravia). Doom-scrolling further reinforces the loop: every swipe delivers fresh jolts of negative stimulus and a hit of dopamine for "staying informed," so users oscillate between dread and reward (Dolgoff). The result is what experts like Dr. Timothy J. Legg, adjunct professor in the Pepperdine Graduate School of Education and Psychology, call hyper-vigilant fatigue: the body's fight-or-flight switch remains half-pressed, so even the ordinary clang of closing doors feels ominous (Gotter). In a city that never sleeps, the phone that never rests ensures anxiety never fully powers down.

The gap between how smartphones were designed and how they're actually used raises important questions for technology designers. When Jobs unveiled the iPhone, he emphasized productivity, entertainment, and communication, not social avoidance or psychological self-protection, a common norm in the confines of New York City. This disconnect is a great example of what Langdon Winner, the Chair of Humanities and Social Studies at Rensselaer Polytechnic Institute, described as "technological somnambulism" â€“ a societal tendency to sleepwalk through technological changes that fundamentally reshape our societal activities. As Winner argues, "technologies are not merely aids to human activity, but also powerful forces acting to reshape that activity and its meaning" (Winner 4). Published in 1973, Winner cites numerous archaic examples, but clearly he was a man ahead of his time, as these thoughts apply equally well to the world we live in today and the newest technologies that actively change society. We adopted smartphones without fully examining their side effects, and we only stumbled into how deeply they have altered our social behaviors and norms. Yet my observations suggest these unintended functions fulfill genuine human needs in an increasingly crowded, stimulating world. How might technology be designed differently if engineers acknowledged these actual usage patterns? What ethical responsibility do designers have when creating tools that so profoundly shape social behavior?

My observations suggest that smartphones have evolved beyond their designers' intentions into sophisticated social tools that help manage modern anxieties. The gap between designed purpose and actual use reflects our paradoxical desires: we crave both connection and isolation, productivity and distraction, social engagement and personal retreat. This causes us to be increasingly uncomfortable with our social moments and the humanity and vulnerability such interactions require. This tension places significant ethical responsibility on technology designers, who must recognize that their creations don't simply serve stated functions but actively reshape social norms and human behavior. Understanding this relationship requires moving beyond simple narratives of addiction or convenience to recognize how we actively repurpose technology to manage complex social realities. As we design future technologies, acknowledging how these tensions are developed might help create tools that better align with genuine human needs rather than inadvertently amplifying our social anxieties.`
},
{ 
    version: "Draft 3", 
    text: `Ping! Panic! Repeat!

Picture a late-night subway ride on the F subway line: fluorescent lights flicker overhead, a half-empty car rattles through the tunnel, and every few seconds somebody's phone buzzes. "Armed robberyâ€”Upper East Side," flashes one push notification. "Man shoved onto tracks in Midtown," warns another. A teenager beside you scrolls an endless reel of grainy security-camera clips, often with some unsuspecting victim about to be assaulted. A middle-aged commuter checks the Citizen app, its red map pins pulsing like fresh wounds across the city grid. Even the PA system crackles with an "if you see something, say something" reminder. Surrounded by screens and alerts, the train car feels poised for disaster, and instinctively, you tighten your grip on the handrail, eyes darting toward every stranger who wanders too close.

Yet that sense of danger may be a digital mirage. According to the NYPD's first-quarter 2025 report, subway crime is down double digits, with zero murdersâ€”the safest start to a year in at least seven years and among the lowest violent-crime tallies ever recorded on the system (New York Daily News). Maybe can make an ordinary ride feel dangerous is not an epidemic of violence in the smartphones in our pocket. To investigate this possibility, I spent three weeks in February of 2025 riding numerous subway lines and bus routes, documenting episodes of public phone use. More broadly, I began to see that while smartphones were designed to connect us and keep us informed, their actual use in public spaces also reveals their complex role in how we navigate modern urban anxieties.

The patterns I observed might have surprised even Steve Jobs, the founder of Apple, who envisioned his smartphone bringing people together rather than helping them avoid each other. When Jobs unveiled his ideas for the iPhone in 2007, Jobs spoke of seamless communication and instant connection (Pangambam). But that's not the way I saw smartphones being used on transit. There, I began to think of them as constructing what I call "social shields," digital barriers that allow users to avoid physical interactions in a socially acceptable way, the antithesis to Job's vision. By staring at a screen, users can avoid eye contact, deflect unwanted conversations, and, perhaps, create psychological distance from their immediate environment while maintaining the appearance of productivity.

My idea of a "social shield" emerged from what technology sociologist Sherry Turkle coined the "tethered self" in her essay "Always-On/Always-On-You: The Tethered Self." Writing in 2008, just one year after the release of the iPhone, Turkle predicted with remarkable precision about how these devices could reshape social life. She described how smartphones were creating a state of society where we are "always-on/always-on-you," a reference to how smartphones are always readily available to us as a society (Turkle 121). Turkle, a professor of social studies of science and technology at Massachusetts Institute of Technology, describes how our "tethered self" can maintain a constant psychological readiness for the connections that matter to us digitally (121). The smartphone creates a "liminal space between the physical real and its digital lives on multiple screens" (122). We are never fully here, yet never fully elsewhere either.

Based on my observations, many people embrace this "tethered self," actively choosing to turn to their digital worlds during moments of social discomfort, regardless of whether they have actual messages or notifications to address. Riding the M103 down Third Avenue, I watched two friends chat easily. They had a nice, long conversation, talking about their daily lives, with neither of them holding a smartphone at all. After a while, it seemed like one of the friends had reached his stop. He said goodbye to his friend and left the bus, leaving the other friend to ride alone. The moment the remaining rider was alone, he cast a cautious glance around, made brief eye contact with me, and fled into his phone. When I made eye contact, I also felt a similar urge, pulling out my phone to start playing video games. Maybe when one person withdraws into their device, it signals to others that the digital escape is both accepted and expected. In my mind, eye contact with a stranger was uncomfortable, and I felt a need to intentionally distract myself with a phone to try to relieve myself of the awkward situation. Maybe the stranger felt the same way.

The tether can act as more than a quick way for users to create psychological buffers. On the subway, the smartphones are also repurposed as a means to actively avoid eye contact. I could be doing absolutely nothing on my phone, just staring at the weather for the hundredth time, yet it creates the sense of safety that I will not accidentally stare right into someone's eyes, possibly creating an unsettling and tense situation. There's a cultural backing behind my behavior; there are plenty of folktales on the New York City subway about how making momentary eye contact with a stranger resulted in an altercation. Ironically, devices engineered to enhance connection can also become tools that dissuade it just as easily. The smartphone's design makes it an ideal shieldâ€”its screen demands attention and signals busyness to others, creating a socially acceptable way to opt out of physical presence while maintaining the appearance of productivity.

This is the crux of Turkle's point about technology: We have become so attached to these devices that not only control our attention and behavior, but we also actively choose to depend on them for psychological comfort and social protection (Turkle 122). In other words, we have become so attached to our tethers that not only do the tethers hold us tightly, but we also hold the tethers tightly as well.

Using smartphones as protective shields can extend to more threatening situations. In another one of my observations, I noticed that there was a woman in a subway station, and a man approached her asking for money. As I watched the interaction unfold, I could see his extended hand and hear his repeated requests for "spare change" and mentions of his homelessness. She started quickly walking away while looking at her phone, keeping her eyes fixed on the screen rather than looking at him, while moving herself towards the station's main area, where more people were present. What I found really interesting was that the woman was on her phone the whole time, staring at it even though, I thought, the more probable pressing matter was the person behind her. I suppose there was the chance that staring at the man could have antagonized him, but staring at your phone, even superficially by not paying attention to the content on it, still heavily limits a person's ability to react should things escalate.

It's impossible to know if the woman was staring at her phone to avoid the trauma that might come with being followed. But if she were, there is some grounding in research. She may have been experiencing what researchers like Dr. Denise M. Sloan, associate director at the National Center for PTSD, calls "peritraumatic dissociation", a phenomenon characterized by emotional numbness and altered perception during stressful events (Swaim 5). A defense mechanism, peritraumatic dissociation allows the mind to protect itself by creating a mental escape when physical escape isn't possible, as fewer mental resources are dedicated to processing how scary or painful a situation feels (Swaim 5). In this case, the smartphone functions as a social shield, providing a visual barrier and a reason not to engage. One can go as far as to say it's an escape portal from an uncomfortable reality. In such a case, a person's behavior could demonstrate Turkle's concept of the "tethered self" in an extreme context, where being mentally elsewhere became part of a survival strategy rather than merely social avoidance. The dual existence of these two worlds, as Turkle frames them, could plays an interesting role here: while a person's body remains vulnerable in a subway station, their attention is elsewhere, away from the threat. Research by Dr. John Hunter, assistant professor of psychology at Chapman University, finds that smartphones can act as a "digital security blanket" that buffers against psychological stress (Hunter et al. 346). Their mere presence can decrease stress levels in people, as the study showed that people without access to smartphones had significantly increased levels of stress (Hunter et al. 349). It's a protective function that was never explicitly designed into smartphones, yet it seems to have become a common use in public spaces.

While phones shield us from immediate discomfort, they may ironically also amplify our broader anxieties about urban danger. These devices are sources for the constant stream of crime alerts, push notifications, and security footage that make public spaces feel perpetually unsafe (Riddell 34). If phones can soothe discomfort, they just as readily stoke it. In the moment, a vibrating phone offers a reassuring ritual: glancing down lets us escape awkward eye contact, confirm a train's ETA, or signal to friends that we're still alive in the tunnel dead zone. Yet the very streams that calm us also keep our anxiety circuits primed. 24-hour push notifications bombard New Yorkers with every robbery, shove, and scuffle, however rare. Each red banner lights up the brain's triggers the same stress response we'd feel if the incident were unfolding a few feet away (Intravia). Doom-scrolling, a recent trend defined by people spending excessive time scrolling through content made to make them feel sad, anxious, or angry, further reinforces this loop (Doomscroll): every swipe delivers fresh jolts of negative stimulus and a hit of dopamine for "staying informed," so users oscillate between dread and reward (Dolgoff). The result is what experts like Dr. Timothy J. Legg, adjunct professor in the Pepperdine Graduate School of Education and Psychology, called hyper-vigilant fatigue: the body's fight-or-flight switch remains half-pressed, so even the ordinary clang of closing doors feels ominous (Gotter). In urban environments like New York City, these algorithmic notifications inadvertently create chronically stressed commuters who constantly perceive danger where little exists. While it is important for commuters to be aware of real, tangible threats nearby, current smartphone designs lack a balance between providing adequate safety information and psychological well-being. In a city that never sleeps, the phone that never rests ensures anxiety never fully powers down.

The disconnect between how smartphones were designed and how they're actually used raises important questions for technology designers. When Jobs unveiled the iPhone, he emphasized productivity, entertainment, and communication, not social avoidance or psychological self-protection. Yet my observations suggest these unintended functions fulfill genuine human needs in an increasingly crowded, stimulating world. The difference between Job's intentions for the iPhone and what we currently use them for is a great example of what Langdon Winner, a professor at Rensselaer Polytechnic Institute, described as "technological somnambulism" â€“ a societal tendency for us to sleepwalk through technological changes that fundamentally reshape our societal activities. Winner was writing in 1973, but clearly he was a man ahead of his time, as these thoughts apply to how the smartphone, one of the most fundamental technologies of the 21st century, has changed society. We adopted smartphones without fully examining their side effects, and only later did we truly realize the true side effects they have in our world (Winner 53). How might technology be designed differently if engineers acknowledged these actual usage patterns? What ethical responsibility do designers have when creating tools that so profoundly shape social behavior?

Technology designers must recognize that their creations don't simply serve stated functions but actively reshape social norms and human behavior, now bearing a significant ethical responsibility. As we design future technologies, acknowledging how these tensions are developed might help create tools that better align with genuine human needs rather than inadvertently amplifying our social anxieties.`
},
{ 
    version: "Draft 4", 
    text: `Ping! Panic! Repeat!

Picture a late-night subway ride on the F subway line: fluorescent lights flicker overhead, a half-empty car rattles through the tunnel, and every few seconds somebody's phone buzzes. "Armed robberyâ€”Upper East Side," flashes one push notification. "Man shoved onto tracks in Midtown," warns another. A teenager beside you scrolls an endless reel of grainy security-camera clips, often with some unsuspecting victim about to be assaulted. A middle-aged commuter checks the Citizen app, its red map pins pulsing like fresh wounds across the city grid. Even the PA system crackles with an "if you see something, say something" reminder. Surrounded by screens and alerts, the train car feels poised for disaster, and instinctively, you tighten your grip on the handrail, eyes darting toward every stranger who wanders too close.

Yet that sense of danger may be a digital mirage. According to the NYPD's first-quarter 2025 report, subway crime is down double digits, with zero murdersâ€”the safest start to a year in at least seven years and among the lowest violent-crime tallies ever recorded on the system (NYPD). Maybe what can make an ordinary ride feel dangerous is not an epidemic of violence but the smartphones in our pocket. I spent three weeks in February of 2025 riding numerous subway lines and bus routes, documenting episodes of public phone use. More broadly, I began to see that while smartphones were designed to connect us and keep us informed, they have evolved into sophisticated social tools that help manage our anxieties while navigating urban spaces.

The patterns I observed Steve Jobs, the founder of Apple, who envisioned his smartphone bringing people together. When Jobs unveiled his ideas for the first iPhone in 2007, Jobs spoke of seamless communication and instant connection (Pangambam). But that's not the way I saw smartphones being used on transit. There, I began to think of them as constructing what I call "social shields," digital barriers that allow users to avoid physical interactions in a socially acceptable way, the antithesis to Job's vision. By staring at a screen, users can avoid eye contact, deflect unwanted conversations, and, perhaps, create psychological distance from their immediate environment while maintaining the appearance of productivity.

My idea of a "social shield" emerged from what technology sociologist Sherry Turkle coined the "tethered self" in her essay "Always-On/Always-On-You: The Tethered Self." Writing in 2008, just one year after the release of the iPhone, Turkle predicted with remarkable precision about how these devices could reshape social life. She described how smartphones were creating a state of society where we are "always-on/always-on-you," a reference to how smartphones are always readily available (Turkle 121). Turkle, a professor of social studies of science and technology at Massachusetts Institute of Technology, describes how our "tethered self" can maintain a constant psychological readiness for the connections that matter to us digitally (121). The smartphone creates a "liminal space between the physical real and its digital lives on multiple screens," Turkle writes (122). We are never fully here, yet never fully elsewhere either.

Based on my observations, many people embrace this "tethered self," actively choosing to turn to their digital worlds during moments of social discomfort, regardless of whether they have actual messages or notifications to address. Riding the M103 down Third Avenue, I watched two friends chat easily. They had a nice, long conversation, talking about their daily lives, with neither of them holding a smartphone at all. After a while, it seemed like one of the friends had reached his stop. He said goodbye to his friend and left the bus, leaving the other friend to ride alone. The moment the remaining rider was alone, he cast a cautious glance around, made brief eye contact with me, and fled into his phone. When I made eye contact, I also felt a similar urge, pulling out my phone to start playing video games. Maybe when one person withdraws into their device, it signals to others that the digital escape is both accepted and expected. In my mind, eye contact with a stranger was uncomfortable, and I felt a need to intentionally distract myself with a phone to try to relieve myself of the awkward situation. Maybe the stranger felt the same way.

The tether can act as more than a quick way for users to create psychological buffers. On the subway, the smartphones are also repurposed as a means to actively avoid eye contact. I could be doing absolutely nothing on my phone, just staring at the weather for the hundredth time, yet it creates the sense of safety that I will not accidentally stare right into someone's eyes, possibly creating an unsettling and tense situation. There's a cultural backing behind my behavior; there are plenty of folktales on the New York City subway about how making momentary eye contact with a stranger resulted in an altercation. Ironically, devices engineered to enhance connection can also become tools that dissuade it just as easily. The smartphone's design makes it an ideal shieldâ€”its screen demands attention and signals busyness to others, creating a socially acceptable way to opt out of physical presence while maintaining the appearance of productivity.

This is the crux of Turkle's point about technology: We have become so attached to these devices that not only control our attention and behavior, but we also actively choose to depend on them for psychological comfort and social protection (Turkle 122). In other words, we have become so attached to our tethers that not only do the tethers hold us tightly, but we also hold the tethers tightly as well.

Using smartphones as protective shields can extend to more threatening situations. In another one of my observations, I noticed that there was a woman in a subway station, and a man approached her asking for money. As I watched the interaction unfold, I could see his extended hand and hear his repeated requests for "spare change" and mentions of his homelessness. She started quickly walking away while looking at her phone, keeping her eyes fixed on the screen rather than looking at him, while moving herself towards the station's main area, where more people were present. What I found really interesting was that the woman was on her phone the whole time, staring at it even though, I thought, the more probable pressing matter was the person behind her. I suppose there was the chance that staring at the man could have antagonized him, but staring at your phone, even superficially by not paying attention to the content on it, still heavily limits a person's ability to react should things escalate.

The dual existence of these two worlds, as Turkle frames them, could play an interesting role here: while a person's body remains vulnerable in a subway station, their attention is elsewhere, away from the threat. Research by Dr. John Hunter, assistant professor of psychology at Chapman University, finds that smartphones can act as a "digital security blanket" that buffers against psychological stress (Hunter et al. 346). Their mere presence can decrease stress levels in people, as the study showed that people without access to smartphones had significantly increased levels of stress (Hunter et al. 349). It's a protective function that was never explicitly designed into smartphones, yet it seems to have become a common use in public spaces.

While phones shield us from immediate discomfort, they may ironically also amplify our broader anxieties about urban danger. These devices are sources for the constant stream of crime alerts, push notifications, and security footage that make public spaces feel perpetually unsafe (Riddell 34). If phones can soothe discomfort, they just as readily stoke it. In the moment, a vibrating phone offers a reassuring ritual: glancing down lets us escape awkward eye contact, confirm a train's ETA, or signal to friends that we're still alive in the tunnel dead zone. Yet the very streams that calm us also keep our anxiety circuits primed. 24-hour push notifications bombard New Yorkers with every robbery, shove, and scuffle, however rare. Doom-scrolling, a recent trend defined by people spending excessive time scrolling through content made to make them feel sad, anxious, or angry, further reinforces this loop (Doomscroll): every swipe delivers fresh jolts of negative stimulus and a hit of dopamine for "staying informed," so users oscillate between dread and reward (Dolgoff). The result is what experts like Dr. Timothy J. Legg, adjunct professor in the Pepperdine Graduate School of Education and Psychology, called hyper-vigilant fatigue: the body's fight-or-flight switch remains half-pressed, so even the ordinary clang of closing doors feels ominous (Gotter). In urban environments like New York City, these algorithmic notifications inadvertently create chronically stressed commuters who constantly perceive danger where little exists. While it is important for commuters to be aware of real, tangible threats nearby, current smartphone designs lack a balance between providing adequate safety information and psychological well-being. In a city that never sleeps, the phone that never rests ensures anxiety never fully powers down.

The disconnect between how smartphones were designed and how they're actually used raises important questions for technology designers. When Jobs unveiled the iPhone, he emphasized productivity, entertainment, and communication, not social avoidance or psychological self-protection. Yet my observations suggest these unintended functions fulfill genuine human needs in an increasingly crowded, stimulating world. The difference between Job's intentions for the iPhone and what we currently use them for is a great example of what Langdon Winner, a professor at Rensselaer Polytechnic Institute, described as "technological somnambulism" â€“ a societal tendency for us to sleepwalk through technological changes that fundamentally reshape our societal activities. Winner was writing in 1973, but clearly he was a man ahead of his time, as these thoughts apply to how the smartphone, one of the most fundamental technologies of the 21st century, has changed society. We adopted smartphones without fully examining their side effects, and only later did we truly realize the true side effects they have in our world (Winner 53). My observations suggest these unintended functions fulfill genuine human needs in an increasingly crowded, stimulating world. The gap between smartphones' designed purpose and actual use reflects our conflicting desires: we crave both connection and isolation, productivity and distraction, social engagement and personal retreat. How might technology be designed differently if engineers acknowledged these actual usage patterns? What ethical responsibility do designers have when creating tools that so profoundly shape social behavior?

Technology designers must recognize that their creations don't simply serve stated functions but actively reshape social norms and human behavior, now bearing a significant ethical responsibility. As we design future technologies, acknowledging how these tensions are developed might help create tools that better align with genuine human needs rather than inadvertently amplifying our social anxieties.`
},

{ 
    version: "Final Draft", 
    text: `Ping! Panic! Repeat!

Back in February, there was a stabbing near High Street at Tandon, but I didn't realize anything had happened until I got the alert on my Citizen app hours later, and I felt retroactively scared. Without it, I would never have known anything dangerous had occurred near me that day. When I first downloaded the Citizen app back in November, I'd already been riding the subways for two or three months without incident. On the subway, I never noticed anything dangerous around me, but once I had the app, I could see a massive map with countless different crimes happening across the city, curating all of these incidents for me. I was certainly a lot more worried after downloading the app, even though I was never actually a victim of crime. Was it better that I didn't know before? This experience with Citizen made me wonder how much our phones might be shaping our perception of urban danger, and what all these alerts and notifications were doing to me.

That realization sparked broader research questions about cellphone use that I brought to an ethnographic study I conducted last Spring, as a computer science major at Tandon. Coming from California, I was struck by how much people used their phones on New York subways. For millions of New Yorkers, the subway isn't just transportationâ€”it's a lifeline carrying people to work, school, and social gatherings, and almost everyone I saw traveled peering at their cellphones. This ubiquitous phone usage made me curious about what was driving this behavior: Were phones simply entertainment, or were they serving a deeper psychological function in navigating urban society? I spent three weeks in February 2025 riding three subway lines and two bus routes within the Metropolitan Transportation Authority (MTA), documenting over ten hours of public phone use. I began to see that while smartphones were designed to connect us and keep us informed, they have evolved into sophisticated social tools that help manage our anxieties while navigating urban spaces. But in some cases, they may spark those anxieties as well.

The patterns I observed reveal how we've collectively chosen to use smartphones in ways its creators apparently advertised. When Steve Jobs introduced the iPhone in a speech in 2007, he described it as a revolutionary combination of three devices: "a widescreen iPod with touch controls," "a revolutionary mobile phone," and "a breakthrough Internet communications device." He focused on its groundbreaking capabilities, creating phones that had "the Internet in your pocket" (Jobs qtd. in Pangambam). Jobs was positioning the iPhone as a productivity and connectivity tool, designed to make communication, web browsing, and media consumption more efficient and seamless. His presentation was about what the technology could do, but not about what we would use the technology to do. Riding the subway in 2025, I witnessed users actively adapting the cellphone to avoid, rather than make, connections.

Riding the M103 down Third Avenue, I watched two friends chat easily. They had a nice, long conversation, talking about their daily lives, with neither of them holding a smartphone at all. After a while, it seemed like one of the friends had reached his stop. He said goodbye to his friend and left the bus, leaving the other friend to ride alone. The moment the remaining rider was alone, he cast a cautious glance around, made brief eye contact with me, and fled into his phone. When I made eye contact, I also felt a similar urge, pulling out my phone to start playing video games. Maybe when one person withdraws into their device, it signals to others that the digital escape is both accepted and expected. In my mind, eye contact with a stranger was uncomfortable, and I felt a need to intentionally distract myself with a phone to try to relieve myself of the awkward situation. Maybe the stranger felt the same way. Our phones had become what I began to call a 'social shield.'

My idea of a 'social shield' emerged from the "tethered self," a term technology sociologist Sherry Turkle coined in her essay "Always-On/Always-On-You: The Tethered Self". Writing in 2008, just one year after the release of the iPhone, Turkle predicted with remarkable precision about how these devices could reshape social life. She described how smartphones were creating a state of society where we are "always-on/always-on-you," a reference to how smartphones are always readily available (Turkle 121). Turkle, a professor of the social studies of science and technology at Massachusetts Institute of Technology, describes how our "tethered self" can maintain a constant psychological readiness for the connections that matter to us digitally (121). The smartphone creates a "liminal space between the physical real and its digital lives on multiple screens," Turkle writes paraphrasing Dr. Victor Turner, a professor of anthology at the University of Virginia (122). We are never fully here, yet never fully elsewhere either.

Based on my observations on the M103 bus and elsewhere, many people embrace this "tethered self," actively choosing to turn to their digital worlds during moments of social discomfort, regardless of whether they have actual messages or notifications to address. The tether can act as more than a quick way for users to create psychological buffers. On the subway, the smartphones are also repurposed as a means to actively avoid eye contact. I could be doing absolutely nothing on my phone, just staring at the weather for the hundredth time, yet it created the sense of safety that I would not accidentally stare right into someone's eyes, possibly creating an unsettling and tense situation. There's a cultural backing behind my behavior. Moving to New York City, I heard plenty of folktales on the New York City subway about how making momentary eye contact with a stranger resulted in an altercation. Jeremy McCarthy, a New Yorker with a Masters in Applied Psychology, has reflected on this issue, considering how the big city environment of New York City forces us to be more risk-averse, and that making eye contact creates risk and vulnerability; to do so would require us to feel confident and safe with the strangers around us (McCarthy). However, in a city with eight million different personalities, such a premise is impossible to guarantee. As such, a 2023 New York Times article explicitly listed "no eye contact" as one of the fundamental "unwritten rules" of the subway (Ley). So, by allowing us to avoid eye contact, smartphones engineered to enhance connection can also become tools that dissuade it just as easily, creating a socially acceptable way to opt out of physical presence while maintaining the appearance of productivity.

This is the crux of Turkle's point about technology: We have become so attached to these devices that not only control our attention and behavior, but we also actively choose to depend on them for psychological comfort and social protection (Turkle 122). In other words, we have become so attached to our tethers that not only do they hold us tightly, but we also hold the tethers tightly as well.

Using smartphones as protective shields can extend to more threatening situations. In another one of my observations, I noticed that there was a woman in a subway station, and a man approached her asking for money. As I watched the interaction unfold, I could see his extended hand and hear his repeated requests for "spare change" and mentions of his homelessness. She started quickly walking away while looking at her phone, keeping her eyes fixed on the screen rather than looking at him, while moving herself towards the station's main area, where more people were present. What I found really interesting was that the woman was on her phone the whole time, staring at it the whole time. As I saw it, the smartphone was functioning as a social shield, providing a visual barrier and a reason for her not to engage. While the woman physically remained in the subway station, it seemed like her attention had wandered elsewhere. Did the woman's smartphone allow her to psychologically escape a potentially threatening situation by tethering her mind to a safer digital space? I wondered if Turkle's concept of the "tethered self" could extend to an extreme context, where a person being mentally elsewhere could become part of a survival strategy rather than merely social avoidance.

While phones shield us from immediate discomfort, they may ironically also amplify our broader anxieties about urban danger. Researcher Alice Riddell conducted an eight-month ethnographic study in Brooklyn neighborhoods to investigate how Citizen's crime-tracking app was affecting residents' sense of safety and community. Using participant observation and interviews with more than seventy people, Riddell found that while Citizen can serve as a tool for community building, it simultaneously creates fear and mistrust. She wrote, "Apps with maps are powerful, making users feel small yet significant, creating reference points of relation with the self always at the centre. Citizen creates an overwhelming map of your area that gives the impression that your neighbourhood is constantly under siege and therefore a space to be mistrustful of" (Riddell 37). While it is important for commuters to be aware of real, tangible threats nearby, I believe that current smartphone apps like Citizen lack a balance between providing adequate safety information as well as psychological well-being. In a city that never sleeps, the phone that never rests may ensure anxiety that never fully powers down.

The disconnect between how smartphones were designed and how they're actually used raises important questions for technology designers. When Jobs unveiled the iPhone, he emphasized productivity, entertainment, and communication, not social avoidance nor psychological self-protection. The difference between Job's stated intentions for the iPhone and what we currently use them for is a great example of what Langdon Winner, a professor at Rensselaer Polytechnic Institute, described as "technological somnambulism"â€”a societal tendency for us to sleepwalk through technological changes that fundamentally reshape our societal activities. Winner was writing in 1973, reflecting on how cars and televisions had radically changed societal functions, but clearly, he was a man ahead of his time. His thoughts clearly apply to how the smartphone, one of the most fundamental technologies of the twenty-first century, has also changed society. "Only later does the broader significance of the choice become clear, typically as a series of surprising 'side effects' or 'secondary consequences'" (Winner 53). The gap between smartphones' designed purpose and actual use reflects our conflicting desires: we crave both connection and isolation, productivity and distraction, social engagement and personal retreat. We use them for both, and in doing so, they shape our behaviors.

Yet it would be far too simplistic and deterministic to say that people just passively let technology change them. As Winner puts it, this idea "does little justice to the genuine choices that arise, in both principle and practice, in the course of technical and social transformation" (Winner 53). The key insight Winner identifies is that we, as a society, must recognize our active role in shaping our society through technology. "Throughout their lives people come together to renew the fabric of relationships, transactions, and meanings that sustain their common existence" (Winner 59). Technology is a tool we use to create this social fabric, but we remain the weavers. This perspective leads Winner to pose the crucial question: "What kind of world are we making?" (Winner 59).

For those of us who find ourselves tethered to our devices on daily commutes, the answer is that we need to realize we have more agency than we think we do. The simple advice to "look up" feels inadequate given how deeply these patterns run. It's hard for me to remember the last time I left my dorm without my phone. But recognizing that we may be using technology to manage urban anxiety, rather than being controlled by our phones, opens possibilities for more intentional engagement. Understanding our phones as 'social shields' rather than inevitable dependencies can help us make more conscious choices about when and how we engage with our devices. This doesn't mean forcing ourselves into uncomfortable eye contact with strangers or abandoning the psychological comfort our phones provide. Instead, it means becoming more aware of the trade-offs we're making. My experience with the Citizen app taught me that sometimes ignorance can be a form of peace, but for others, a conscious choice to consume information about their surroundings may also be a form of peace. The goal is not to decrease or eliminate smartphone usage, but to use them more deliberately.

For technology designers, these questions carry greater weight. Designers must recognize that our creations don't simply serve stated functions, but also actively reshape social norms and human behavior, bearing significant ethical responsibility. Designers must not simply seek to avoid harm but to actively consider the social and psychological conditions being created, asking questions before widespread adoption rather than discovering problematic effects afterward. Winner is clear about this obligation, writing: "Much more than we have acknowledged in the past, we must admit our responsibility for what we are making" (Winner 59). Importantly, Winner is speaking to society as a whole, as our own interactions with technology also fuel these changes. At the end of the day, we all bear some responsibility for examining how new technologies impact our collective lives. As we move forward with technological innovation, acknowledging these tensions might help create tools that better align with genuine human needs rather than inadvertently amplifying our social anxieties.`
}
                ]
            },


          essay2: {
    title: "Simulated Systems and the Limits of Intuitive Learning",
    author: "Srinivas Harish",
    description: "Examining how simulations shape our understanding of complex systems",
    drafts: [
        { 
            version: "Draft 1", 
            text: `However, this reduction in extraneous load comes at a cost. Sweller posits that while managing extraneous load is essential, there is a risk of oversimplification. By reducing unnecessary cognitive strain, KSP may strip away the intrinsic complexity of space travel and compromise germane cognitive load. As such, the simplified interface could reduce deep learning and schema development (Sweller, 2011) by reducing the opportunities for the mental struggle necessary for true scientific understanding. The player does not have to calculate rocket trajectories or orbital mechanics manually and the game alone might not help in developing robust mental schemas needed for independent problem-solving, which involves expending mental effort in reorganizing and internalizing information. This also ties into Sweller's expertise reversal effect, where techniques that help novices may become counterproductive as learners gain more experience. As players grow more proficient at KSP, they may begin to rely too heavily on the game's interface and structure, potentially hindering their ability to tackle real-world, unstructured problems. Perhaps then, this suggests that instructional techniques that were once helpful can become detrimental. For novices, KSP's structured guidance is invaluable, but for experts, the same guidance may become redundant in more complex learning.

Interestingly, however, while KSP's interface facilitates initial learning, it also sparked my curiosity to dive deeper into the science behind space exploration. This led me to calculate interplanetary Hohmann transfer trajectories manually and write a paper on the topic. The game acted as an inspiration, providing a stepping stone from simple, guided experimentation to more advanced, independent scientific inquiry. This suggests that while KSP reduces the cognitive load in the early stages, it can also catalyze deeper learning, where the player can tackle more complex, real-world calculations outside the game's simplified and structured framework.

While this structured environment of KSP is ideal for teaching fundamental principles, it starkly contrasts with the unpredictability and risk inherent to real-world scientific exploration and discovery. A pre-configured structure lacks the messiness that Ann-Sophie Barwich identifies as crucial for scientific discovery in her essay, "The Value of Failure in Science" Barwich argues that failure is not merely an impediment but a driving force for progress, stating, "Science fails... at a high rate and with regularity, [it is not] successful despite such prevalent failures... it is successful because of them." (Barwich, 2019) Barwich values cognitive load and failure as mechanisms for discovery, while Sweller would argue that too much cognitive load can hinder learning. This perspective highlights a key limitation of KSP: its deterministic framework undermines the role of serendipity, anomalies, and long-term consequences in fostering paradigm shifts. Barwich's analysis of the flawed grandmother cell theory illustrates the value of such chaosâ€”errors and unanticipated results often provoke questions and reshape understanding. In real-world science, serendipity and ambiguity often force researchers to explore paths they hadn't anticipated. For example, the discovery of penicillin resulted from a serendipitous failure (Ban, 2006), and the theory of cosmic microwave background radiation emerged from unintentional noise in radio antenna data (Oliver, 2020). These paradigm shifts represent the very essence of revolutionary science and were an accidental result of unpredictable failure.

These discoveries show that considering the type of failure matters as much as the failure itself--catastrophic failures often halt progress entirely, while inspirational failures provoke further questions, and serendipitous failures lead to unexpected breakthroughs. Thomas Edison's thousands (Goodman, 2013) of unsuccessful attempts at designing a light bulb built resilience, and ethical implications underscore the fact that science does not exist in a vacuum: catastrophic failures can lead to societal harm, environmental destruction, or controversial technological applications, as seen with disasters like the Challenger (NASA, 2024) explosion. Yet, in KSP, progress is neatly packaged into a closed-loop feedback system where players rebuild and retry within the bounds of predetermined solutions, where failure is not just acceptable, but entertaining. As such, no deeper questioning of assumptions is required as no anomalies would ever force a reconsideration of the game's underlying logic. Thus, the absence of epistemological upheaval renders the game a simplified approximation of scientific progress, devoid of the intellectual chaos and cognitive complexity that fuels genuine breakthroughs. Barwich might contend this is an exercise in following rules encouraging fixed patterns of thought rather than exploring the unknown with adaptive expertise, a limitation that Sweller's CLT overlooks in its quest for simplified learning. Sweller, however, would likely respond that the struggle inherent to Barwich's model, while beneficial for true discovery, could overwhelm learners at a foundational level, pushing them toward frustration rather than motivation. Barwich implicitly suggests that the cognitive strain imposed by failureâ€”what might be classified as intrinsic or even germane loadâ€”plays a critical role in cultivating higher-order thinking and epistemic innovation. However, KSP and similar simulations cannot fully replicate the raw epistemology of science, as they remain confined within pre-defined structures, incapable of capturing the unpredictable and ethically complex nature of genuine scientific discovery.`
        },
        { 
            version: "Draft 2", 
            text: `However, this reduction in extraneous load comes at a cost. Sweller emphasizes that instructional design must "reduce extraneous cognitive load without altering [its] intrinsic nature" (Sweller, 2011). In KSP, there is a risk of oversimplification. By removing the need to calculate trajectories or manipulate equations, it strips some of the inherent complexity of space travel. This could compromise germane load by limiting the mental struggle needed to build deep, transferable schemas necessary for scientific discovery. This also ties into Sweller's "expertise reversal effect" (Sweller, 2011), where techniques that help novices may become counterproductive as learners gain more experience. As players grow more proficient at KSP, they may begin to rely too heavily on the simulation's interface and structure, potentially hindering their ability to tackle real-world, unstructured problems. Perhaps then, this suggests that instructional techniques that were once helpful can become detrimental. For novices, KSP's structured guidance is invaluable, but for experts, the same guidance may become a hindrance to more complex learning.

But even beyond the risks of over-structuring, there's a deeper complication: what KSP defines as "failure" isn't failure in a practical sense. It's intuitive failure that's bounded and easily correctedâ€”more of a design loop than an epistemic disruption. This stands in contrast to the messy, high-stakes failure that drives scientific discovery, as German cognitive scientist Ann-Sophie Barwich argues in her essay, "The Value of Failure in Science." Barwich says failure is not merely an impediment but a driving force for progress, stating, "Science fails... at a high rate and with regularity, [it is not] successful despite such prevalent failures... it is successful because of them" (Barwich, 2019). If we take failure as a mechanism that increases cognitive load, then Sweller's warning that excessive cognitive strain can overwhelm learners and hinder schema formation stands in tension with Barwich's view that failure, and thus the cognitive strain from it, is epistemically generative.

However, Barwich's epistemic view of failure highlights a key limitation of KSP: its deterministic framework undermines the role of serendipity, anomalies, and long-term consequences in fostering paradigm shifts. In her critique of the grandmother cell theory, Barwich shows how scientific progress emerged only after anomalies forced a rejection of this overly simplistic view. The collapse of the theory led to a deeper understanding of distributed neural processing, illustrating how failure can provoke conceptual change rather than just iterative refinement. In real-world science, serendipity and ambiguity often force researchers to explore paths they hadn't anticipated. For example, the discovery of penicillin resulted from a serendipitous failure (Ban, 2006), and the theory of cosmic microwave background radiation emerged from unintentional noise in radio antenna data (Oliver, 2020). These paradigm shifts represent the very essence of revolutionary science and were an accidental result of unpredictable failure. Some failures, I'd argue, are more epistemically productive than others: catastrophic failures may halt progress entirely, while inspirational failures provoke new questions, and serendipitous failures yield unanticipated breakthroughs. Edison's thousands (Goodman, 2013) of unsuccessful attempts at designing a light bulb built resilience, and ethical implications underscore the fact that science does not exist in a vacuum: catastrophic failures can lead to societal harm, environmental destruction, or controversial technological applications, as seen with disasters like the Challenger (NASA, 2024) explosion.

Yet such epistemically rich failures require conditions that KSP does not provide. In KSP, failure is intuitive, recoverable, and ultimately entertainingâ€”a design feature rather than a disruption. Progress is neatly packaged into a closed-loop feedback system where players rebuild and retry within the bounds of predetermined solutions. As such, no deeper questioning of assumptions is required, since no anomalies ever force a reconsideration of the game's underlying logic. The absence of epistemological upheaval renders KSP a simplified approximation of scientific progress, one devoid of the intellectual chaos, conceptual instability, and open-ended failure that often fuels scientific discovery. Barwich emphasizes that failure is not merely a pedagogical inconvenience but a necessary condition for challenging and refining scientific frameworks as they lead to "active engagement with the limits of understanding" (Barwich, 2019). This perspective helps illuminate the limits of KSP as a learning tool: while the simulation enables iterative trial and error, it does so within a stable, rule-bound environment. There are no paradigm-breaking anomalies, only errors that can be corrected by better optimization within a closed system. As such, the type of failure KSP enables does not compel players to rethink assumptions or confront epistemological uncertainty. Barwich's insight casts KSP as an exercise in following rules rather than exploring the unknown, and reveals how its structured feedback system encourages fixed patterns of thought rather than adaptive expertise. From a Swellerian perspective, this would be seen as a feature, not a flawâ€”one that reduces extraneous load and supports efficient schema formation. However, Barwich's framework reveals that this very efficiency might come at the cost of scientific creativity.`
        },
        { 
            version: "Final Draft", 
            text: `KSP's oversimplification may also come at a cost to STEM students later in their careers. In his essay, Sweller introduced the "expertise-reversal effect," which occurs when learning scaffolds that support novices start to hinder more advanced learners as those scaffolds themselves become an extra load (Sweller 131). In KSP, every maneuver node, thrust readout, and on-screen trajectory cue serves as that kind of scaffold. The longer a player uses those aids, the more the aids become baked into the problem-solving routine, resulting in a kind of cognitive overadjustment to the simulation. When the real world no longer shows a blue maneuver node or a perfect delta-v readout, what began for the player as a learning aid can become a surprisingly hard-to-escape cage. The player receives inputs, updates internal schemas through feedback, and iteratively builds a model of the world. Over time, the game's interface and cues act like learned priors, scaffolding intuitive responses that feel like mastery, but may not generalize beyond the simulation. In that sense, what KSP cultivates is not so much deep understanding, but a self-model conditioned on success within a closed system. A constrained self-modelâ€”a learner's internal representation of what they can do and how the system worksâ€”becomes brittle: optimized for success within a closed loop, but unprepared for the noise of real-world science.

Yet oversimplification is only half the problem. As a simulation, KSP teaches you to succeed in its rule space but not necessarily to question the assumptions that world is built on. In KSP, failure is a bounded design loop, but true scientific progress often stems from failures that break the framework itself. In her essay "The Value of Failure in Science," cognitive scientist Ann-Sophie Barwich introduces and analyzes case studies in which scientists' failures led to deeper learning, including the discarded grandmother-cell theory. This theory proposed that single neurons could encode specific complex concepts, including recognizing one's grandmother. The theory gained traction before evidence was found suggesting that complex concepts are distributed across neural networks, leading researchers to adopt a new, distributed model of neural representation (Barwich 3). Barwich writes, "Science fails. It seems to fail at a high rate and with regularity. . . . One may wonder why science is so successful despite such prevalent failures. The alternative is to suggest that it is successful because of them" (Barwich 1).

Barwich's arguments about failure being integral to scientific discovery align with another core feature of scientific research: the importance of uncertainty and happy accidents. Paradigm-level disruption often begins with an unexpected result. Penicillin emerged when Alexander Fleming noticed that a mold contaminating his Petri dishes killed nearby bacteria, and what looked like ruined cultures revealed an antibiotic (Ban 337-338). The detection of the cosmic microwave background followed a similar pattern: Arno Penzias and Robert Wilson tried to eliminate a persistent background hiss in their radio antenna, only to discover the remnant radiation of the Big Bang (Oliver). Neither event was an error to be 'fixed.' Each anomaly called the prevailing explanatory framework into question and compelled scientists to build a deeper oneâ€”or a new framework altogether.

Barwich's view of failure as a kind of "epistemic" disturbanceâ€”what she calls "active engagement with the limits of understanding" (Barwich 2)â€”is precisely what a deterministic simulation like KSP cannot supply. In KSP, failure is intuitive, recoverable, and ultimately entertainingâ€”a design feature rather than a disruption. Progress is neatly packaged into a closed-loop feedback system where players rebuild and retry within the bounds of predetermined solutions. There are no paradigm-breaking anomalies that force a reconsideration of the game's underlying logic, only errors that can be corrected by better optimization within a closed system. As such, the type of failure KSP enables does not compel players to rethink assumptions or confront epistemological uncertainty. Barwich's insight casts KSP as an exercise in following rules rather than exploring the unknown, and reveals how its structured feedback system encourages fixed patterns of thought rather than adaptive expertise. From a Swellerian perspective, KSP's avoidance of real failure might be seen as a pedagogical strength at an early stage of learning by removing epistemic friction and reducing extraneous load and making a difficult subject more approachable. But Barwich's view reframes this very efficiency as a limitation. By insulating players from paradigm-level disruptions, KSP risks flattening the intrinsic complexity of spaceflight into something that feels merely iterative. Without anomalies that violate the rules, learners practice refinement within a fixed systemâ€”but never confront the kind of disorientation that sparks new frameworks and deeper insight.`
        }
    ]
}
};
       
        
        function createPanels(essay) {
            const slider = document.getElementById('comparisonSlider');
            slider.innerHTML = ''; // Clear existing panels
            
            const panels = [];
            
            // Create panels: Draft 1, Diff 1â†’2, Draft 2, Diff 2â†’3, Draft 3, etc.
            for (let i = 0; i < essay.drafts.length; i++) {
                // Add draft panel
                const draftPanel = document.createElement('div');
                draftPanel.className = 'panel';
                const formattedText = formatText(essay.drafts[i].text);

                // Check if feedback exists for this draft
                const feedbackId = getFeedbackId(essay.title, essay.drafts[i].version);
                const hasFeedback = draftFeedback[feedbackId] !== undefined;
                const feedbackText = 'Manage Feedback';
                const feedbackClass = hasFeedback ? 'has-feedback' : '';

                draftPanel.innerHTML = `
                    <h3>
                        ${essay.drafts[i].version}
                        <button class="feedback-button ${feedbackClass}"
                                onclick="showFeedbackModal('${essay.title.replace(/'/g, "\\'")}', '${essay.drafts[i].version.replace(/'/g, "\\'")}')">
                            ${feedbackText}
                        </button>
                    </h3>
                    <div class="panel-content">${formattedText}</div>
                `;
                slider.appendChild(draftPanel);
                panels.push({ type: 'draft', index: i });
                
                if (i < essay.drafts.length - 1) {
                    const diffPanel = document.createElement('div');
                    diffPanel.className = 'panel diff-panel';
                    const formattedText1 = formatText(essay.drafts[i].text);
                    const formattedText2 = formatText(essay.drafts[i + 1].text);
                    const diffContent = generateAdvancedDiff(formattedText1, formattedText2);
                    diffPanel.innerHTML = `
                        <h3>Changes: ${essay.drafts[i].version} â†’ ${essay.drafts[i + 1].version}</h3>
                       <div class="diff-legend">
                            <span class="legend-item"><span class="deletion word-level">Deleted</span></span>
                            <span class="legend-item"><span class="addition word-level">Added</span></span>
                        </div>
                        <div class="panel-content">${diffContent}</div>
                    `;
                    slider.appendChild(diffPanel);
                    panels.push({ type: 'diff', fromIndex: i, toIndex: i + 1 });
                }
            }
            
            // At the end of createPanels function, before 'return panels;'
            // Enable annotations after a short delay to ensure DOM is ready
            setTimeout(() => {
                if (panels[0].type === 'diff') {
                    makeAnnotatable(
                        essay.title,
                        essay.drafts[panels[0].fromIndex].version,
                        essay.drafts[panels[0].toIndex].version
                    );
                }
            }, 100);


            return panels;
        }
        
        function loadExampleEssay(essayId) {
    // Show spinner
    document.getElementById('loadingSpinner').style.display = 'flex';
    
    const essay = exampleEssays[essayId];
    if (!essay || !essay.drafts) {
        document.getElementById('loadingSpinner').style.display = 'none';
        showError('Example essay not found.');
        return;
    }
            
            currentEssay = essay;
            
            // Clear any previous errors
            const errorMessage = document.getElementById('errorMessage');
            if (errorMessage) errorMessage.style.display = 'none';
            
            // Hide upload section
            const uploadSection = document.querySelector('.upload-section');
            if (uploadSection) uploadSection.classList.add('hidden');
            
            // Create all panels
            const panelInfo = createPanels(essay);
            totalPanels = panelInfo.length;
            currentPosition = 0;
            
            // Display results
            const comparisonResults = document.getElementById('comparisonResults');
            if (comparisonResults) {
                comparisonResults.style.display = 'block';
                updateSliderPosition();
                updateNavigationInfo(panelInfo);
            }
            
            // Add event listener for new comparison button
            setupNewComparisonButton();

            // Hide spinner
            document.getElementById('loadingSpinner').style.display = 'none';

              // Save state
        saveState();
        }
        
        function updateNavigationInfo(panelInfo) {
    const navInfo = document.getElementById('navigationInfo');
    if (navInfo) {
        // Check if current panel is the complete transformation panel
        const currentPanel = document.querySelector('.comparison-slider').children[currentPosition];
        if (currentPanel) {
            const heading = currentPanel.querySelector('h3');
            if (heading && heading.textContent.includes('Complete Transformation')) {
                navInfo.textContent = heading.textContent.replace('ðŸ“Š ', '');
                return;
            }
        }
        
        // Otherwise use standard logic
        if (panelInfo[currentPosition]) {
            const panel = panelInfo[currentPosition];
            if (panel.type === 'draft') {
                navInfo.textContent = currentEssay.drafts[panel.index].version;
            } else if (panel.type === 'diff') {
                navInfo.textContent = `Changes: ${currentEssay.drafts[panel.fromIndex].version} â†’ ${currentEssay.drafts[panel.toIndex].version}`;
            }
        }
    }
}

function setupNewComparisonButton() {
    const headerNewComparisonBtn = document.getElementById('headerNewComparisonBtn');
    if (headerNewComparisonBtn) {
        headerNewComparisonBtn.classList.remove('hidden');
        headerNewComparisonBtn.replaceWith(headerNewComparisonBtn.cloneNode(true));
        
        const freshBtn = document.getElementById('headerNewComparisonBtn');
        freshBtn.addEventListener('click', function() {
            freshBtn.classList.add('hidden');
            
            const uploadSection = document.querySelector('.upload-section');
            if (uploadSection) uploadSection.classList.remove('hidden');
            
            const comparisonResults = document.getElementById('comparisonResults');
            if (comparisonResults) comparisonResults.style.display = 'none';
            
            // Clear file inputs
            const file1Input = document.getElementById('file1');
            const file2Input = document.getElementById('file2');
            if (file1Input) file1Input.value = '';
            if (file2Input) file2Input.value = '';
            
            if (typeof uploadedFiles !== 'undefined') {
                uploadedFiles = [];
            }
            
            const fileList = document.getElementById('fileList');
            const compareBtn = document.getElementById('compareFiles');
            if (fileList) fileList.style.display = 'none';
            if (compareBtn) compareBtn.style.display = 'none';
            
            // Clear pasted text fields and reset to 2 drafts
            const pasteContainer = document.getElementById('pasteContainer');
            if (pasteContainer) {
                // Remove all sections except first 2
                const allSections = pasteContainer.querySelectorAll('.paste-draft-section');
                allSections.forEach((section, index) => {
                    if (index >= 2) {
                        section.remove();
                    } else {
                        // Clear the first 2
                        const draftNum = section.getAttribute('data-draft-num');
                        const labelInput = document.getElementById(`paste-label-${draftNum}`);
                        const textArea = document.getElementById(`paste-text-${draftNum}`);
                        if (labelInput) labelInput.value = '';
                        if (textArea) textArea.value = '';
                    }
                });
                
                // Reset draft count
                currentDraftCount = 2;
                const addDraftBtn = document.getElementById('addDraftBtn');
                const limitMsg = document.getElementById('draftLimitMessage');
                if (addDraftBtn) addDraftBtn.style.display = 'inline-block';
                if (limitMsg) limitMsg.style.display = 'none';
            }
            
            const errorMessage = document.getElementById('errorMessage');
            if (errorMessage) errorMessage.style.display = 'none';
            
            currentEssay = null;
            
            window.scrollTo({ top: 0, behavior: 'smooth' });
        });
    }
}


        function updateSliderPosition() {
            const translateX = -100 * currentPosition;
            document.getElementById('comparisonSlider').style.transform = `translateX(${translateX}%)`;
            
            // Update arrow states
            const leftArrow = document.getElementById('leftArrow');
            const rightArrow = document.getElementById('rightArrow');
            
            leftArrow.style.opacity = currentPosition === 0 ? '0.3' : '1';
            rightArrow.style.opacity = currentPosition >= totalPanels - 1 ? '0.3' : '1';
            
            // Update navigation info
            if (currentEssay) {
                const slider = document.getElementById('comparisonSlider');
                const panels = Array.from(slider.children);
                const panelInfo = [];
                
                // Reconstruct panel info
                let draftIndex = 0;
                for (let i = 0; i < panels.length; i++) {
                    if (i % 2 === 0) { // Draft panel
                        panelInfo.push({ type: 'draft', index: draftIndex });
                        draftIndex++;
                    } else { // Diff panel
                        panelInfo.push({ type: 'diff', fromIndex: draftIndex - 1, toIndex: draftIndex });
                    }
                }
                
                updateNavigationInfo(panelInfo);
            }
            // At the end of updateSliderPosition function
            // Enable annotations for diff panels
            setTimeout(() => {
                const panelInfo = getPanelInfo();
                const currentPanelInfo = panelInfo[currentPosition];
                
                if (currentPanelInfo && currentPanelInfo.type === 'diff' && currentEssay) {
                    makeAnnotatable(
                        currentEssay.title,
                        currentEssay.drafts[currentPanelInfo.fromIndex].version,
                        currentEssay.drafts[currentPanelInfo.toIndex].version
                    );
                }
            }, 100);

            if (currentEssay) {
        saveState();
    }
    startTutorialIfNeeded();
        }
        
        function switchTab(activeTabId, activeContentId) {
            document.querySelectorAll('.tab-btn').forEach(tab => {
                tab.classList.remove('active');
            });
            document.querySelectorAll('.tab-content').forEach(content => {
                content.classList.remove('active');
            });
            
            document.getElementById(activeTabId).classList.add('active');
            document.getElementById(activeContentId).classList.add('active');
        }
        
    
       

// Initialize on page load
window.addEventListener('load', () => {
    gapiLoaded();
    gisLoaded();
});



document.addEventListener('DOMContentLoaded', function() {

     // Load saved data
     loadAnnotations();
     loadDraftFeedback();

    // Show restore banner if there's saved data
    showRestoreBanner();

    // Clear data button
    const clearDataButton = document.getElementById('clearDataButton');
    if (clearDataButton) {
        clearDataButton.addEventListener('click', clearAllData);
    }

    // Project Management Buttons
    const saveProjectButton = document.getElementById('saveProjectButton');
    const loadProjectButton = document.getElementById('loadProjectButton');

    if (saveProjectButton) {
        saveProjectButton.addEventListener('click', showSaveProjectModal);
    }

    if (loadProjectButton) {
        loadProjectButton.addEventListener('click', showLoadProjectModal);
    }

    // Save Project Modal Events
    const saveProjectModal = document.getElementById('saveProjectModal');
    const saveProjectModalClose = document.getElementById('saveProjectModalClose');
    const cancelSaveProjectBtn = document.getElementById('cancelSaveProjectBtn');
    const confirmSaveProjectBtn = document.getElementById('confirmSaveProjectBtn');
    const projectNameInput = document.getElementById('projectNameInput');

    if (saveProjectModalClose) {
        saveProjectModalClose.addEventListener('click', function() {
            saveProjectModal.style.display = 'none';
        });
    }

    if (cancelSaveProjectBtn) {
        cancelSaveProjectBtn.addEventListener('click', function() {
            saveProjectModal.style.display = 'none';
        });
    }

    if (confirmSaveProjectBtn) {
        confirmSaveProjectBtn.addEventListener('click', attemptSaveProject);
    }

    if (projectNameInput) {
        projectNameInput.addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                attemptSaveProject();
            }
        });
    }

    // Manage Projects button from Save modal
    const manageProjectsFromSaveBtn = document.getElementById('manageProjectsFromSaveBtn');
    if (manageProjectsFromSaveBtn) {
        manageProjectsFromSaveBtn.addEventListener('click', function() {
            saveProjectModal.style.display = 'none';
            showManageProjectsModal();
        });
    }

    // Load Project Modal Events
    const loadProjectModal = document.getElementById('loadProjectModal');
    const loadProjectModalClose = document.getElementById('loadProjectModalClose');
    const manageProjectsFromLoadBtn = document.getElementById('manageProjectsFromLoadBtn');

    if (loadProjectModalClose) {
        loadProjectModalClose.addEventListener('click', function() {
            loadProjectModal.style.display = 'none';
        });
    }

    if (manageProjectsFromLoadBtn) {
        manageProjectsFromLoadBtn.addEventListener('click', function() {
            loadProjectModal.style.display = 'none';
            showManageProjectsModal();
        });
    }

    // Manage Projects Modal Events
    const manageProjectsModal = document.getElementById('manageProjectsModal');
    const manageProjectsModalClose = document.getElementById('manageProjectsModalClose');
    const cancelManageProjectsBtn = document.getElementById('cancelManageProjectsBtn');
    const backToSaveFromManageBtn = document.getElementById('backToSaveFromManageBtn');

    if (manageProjectsModalClose) {
        manageProjectsModalClose.addEventListener('click', function() {
            manageProjectsModal.style.display = 'none';
        });
    }

    if (cancelManageProjectsBtn) {
        cancelManageProjectsBtn.addEventListener('click', function() {
            manageProjectsModal.style.display = 'none';
        });
    }

    if (backToSaveFromManageBtn) {
        backToSaveFromManageBtn.addEventListener('click', function() {
            manageProjectsModal.style.display = 'none';
            showSaveProjectModal();
        });
    }

    // .bro File Upload Event
    const broFileInput = document.getElementById('broFileInput');
    if (broFileInput) {
        broFileInput.addEventListener('change', function(e) {
            const file = e.target.files[0];
            if (file) {
                importBroFile(file);
                // Clear the input so the same file can be selected again
                e.target.value = '';
            }
        });
    }

    // Feedback Modal Events
    const feedbackModal = document.getElementById('feedbackModal');
    const feedbackModalClose = document.getElementById('feedbackModalClose');
    const feedbackSaveBtn = document.getElementById('feedbackSaveBtn');
    const feedbackCancelBtn = document.getElementById('feedbackCancelBtn');
    const feedbackDeleteBtn = document.getElementById('feedbackDeleteBtn');
    const feedbackAddNewBtn = document.getElementById('feedbackAddNewBtn');

    if (feedbackModalClose) {
        feedbackModalClose.addEventListener('click', closeFeedbackModal);
    }

    if (feedbackSaveBtn) {
        feedbackSaveBtn.addEventListener('click', saveFeedbackFromModal);
    }

    if (feedbackCancelBtn) {
        feedbackCancelBtn.addEventListener('click', cancelFeedbackEntry);
    }

    if (feedbackDeleteBtn) {
        feedbackDeleteBtn.addEventListener('click', deleteFeedbackFromModal);
    }

    // Priority sliders - removed (no longer part of UI)

    if (feedbackAddNewBtn) {
        feedbackAddNewBtn.addEventListener('click', function() {
            showFeedbackEntryForm();
        });
    }

    // Synthesis button
    const feedbackSynthesisBtn = document.getElementById('feedbackSynthesisBtn');
    if (feedbackSynthesisBtn) {
        feedbackSynthesisBtn.addEventListener('click', showSynthesisView);
    }

    // Synthesis back button
    const synthesisBackBtn = document.getElementById('synthesisBackBtn');
    if (synthesisBackBtn) {
        synthesisBackBtn.addEventListener('click', function() {
            document.getElementById('feedbackSynthesisView').style.display = 'none';
            document.getElementById('feedbackListView').style.display = 'block';
        });
    }

    // Synthesis save button
    const synthesisSaveBtn = document.getElementById('synthesisSaveBtn');
    if (synthesisSaveBtn) {
        synthesisSaveBtn.addEventListener('click', saveSynthesisNotes);
    }

    // Add Priority button
    const addPriorityBtn = document.getElementById('addPriorityBtn');
    if (addPriorityBtn) {
        addPriorityBtn.addEventListener('click', addPriority);
    }

    // Priority input - Enter key
    const priorityInput = document.getElementById('priorityInput');
    if (priorityInput) {
        priorityInput.addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                e.preventDefault();
                addPriority();
            }
        });
    }

    // Source selector buttons
    document.querySelectorAll('.source-btn').forEach(btn => {
        btn.addEventListener('click', function() {
            document.querySelectorAll('.source-btn').forEach(b => b.classList.remove('active'));
            this.classList.add('active');

            // Show/hide self-analysis fields
            const selfFields = document.getElementById('selfAnalysisFields');
            const contentLabel = document.getElementById('contentLabel');
            const understandingSection = document.getElementById('understandingSection');

            if (this.dataset.source === 'self') {
                selfFields.style.display = 'block';
                contentLabel.textContent = 'My Self-Assessment:';
                understandingSection.style.display = 'none';  // Hide understanding for self-assessment
            } else {
                selfFields.style.display = 'none';
                contentLabel.textContent = 'Feedback Content:';
                understandingSection.style.display = 'block';  // Show understanding for other sources
            }
        });
    });

    // Rich text toolbar buttons
    document.querySelectorAll('.toolbar-btn').forEach(btn => {
        btn.addEventListener('click', function(e) {
            e.preventDefault();
            const command = this.dataset.command;
            document.execCommand(command, false, null);
            document.getElementById('feedbackContentEditor').focus();
        });
    });

    // Tags input - Enter key
    const tagsInput = document.getElementById('feedbackTagsInput');
    if (tagsInput) {
        tagsInput.addEventListener('keypress', function(e) {
            if (e.key === 'Enter') {
                e.preventDefault();
                addTag(this.value.trim());
                this.value = '';
            }
        });
    }

    // Suggested tags
    document.querySelectorAll('.suggested-tag').forEach(btn => {
        btn.addEventListener('click', function() {
            addTag(this.dataset.tag);
        });
    });

    // File upload button
    const feedbackUploadBtn = document.getElementById('feedbackUploadBtn');
    const feedbackFileInput = document.getElementById('feedbackFileInput');

    if (feedbackUploadBtn) {
        feedbackUploadBtn.addEventListener('click', function() {
            feedbackFileInput.click();
        });
    }

    if (feedbackFileInput) {
        feedbackFileInput.addEventListener('change', handleFeedbackFileUpload);
    }

    // Add input listeners to understanding fields
    const understandingExplanation = document.getElementById('understandingExplanation');
    const understandingActionPlan = document.getElementById('understandingActionPlan');
    const understandingQuestions = document.getElementById('understandingQuestions');

    if (understandingExplanation) {
        understandingExplanation.addEventListener('input', validateUnderstandingFields);
    }
    if (understandingActionPlan) {
        understandingActionPlan.addEventListener('input', validateUnderstandingFields);
    }
    if (understandingQuestions) {
        understandingQuestions.addEventListener('input', validateUnderstandingFields);
    }

    // Validation function for understanding fields
    function validateUnderstandingFields() {
        const explanation = document.getElementById('understandingExplanation').value.trim();
        const actionPlan = document.getElementById('understandingActionPlan').value.trim();
        const questions = document.getElementById('understandingQuestions').value.trim();

        const allValid = explanation.length >= 15 && actionPlan.length >= 15 && questions.length >= 15;

        const checkbox = document.getElementById('feedbackUnderstoodCheckbox');
        const checkboxWrapper = document.querySelector('.understanding-checkbox-wrapper');
        const hint = document.getElementById('understandingCheckboxHint');

        if (allValid) {
            checkbox.disabled = false;
            checkboxWrapper.classList.remove('disabled');
            hint.style.display = 'none';
        } else {
            checkbox.disabled = true;
            checkbox.checked = false;
            checkboxWrapper.classList.add('disabled');
            hint.style.display = 'block';
        }
    }

    // Close modal when clicking outside
    window.addEventListener('click', function(event) {
        if (event.target === feedbackModal) {
            closeFeedbackModal();
        }
    });

// Options Dropdown Toggle
const optionsDropdownBtn = document.getElementById('optionsDropdownBtn');
    const optionsDropdownMenu = document.getElementById('optionsDropdownMenu');
    
    if (optionsDropdownBtn && optionsDropdownMenu) {
        optionsDropdownBtn.addEventListener('click', function(e) {
            e.stopPropagation();
            optionsDropdownMenu.classList.toggle('show');
        });
        
        // Close dropdown when clicking outside
        document.addEventListener('click', function(e) {
            if (!optionsDropdownBtn.contains(e.target) && !optionsDropdownMenu.contains(e.target)) {
                optionsDropdownMenu.classList.remove('show');
            }
        });
        
        // Close dropdown when clicking a menu item
        optionsDropdownMenu.addEventListener('click', function() {
            optionsDropdownMenu.classList.remove('show');
        });
    }

    // Night Mode Toggle
    const nightModeToggle = document.getElementById('nightModeToggle');
    const nightModeStatus = document.getElementById('nightModeStatus');
    const headerLogo = document.getElementById('headerLogo');

    // Logo URLs
    const lightModeLogo = 'https://i.imgur.com/iIODsNl.png';
    const nightModeLogo = 'https://i.imgur.com/NzCTDKg.png';

    // Function to update logo based on mode
    function updateLogo(isNightMode) {
        if (headerLogo) {
            headerLogo.src = isNightMode ? nightModeLogo : lightModeLogo;
        }
    }

    // Load saved night mode preference
    const savedNightMode = localStorage.getItem('nightMode');
    if (savedNightMode === 'enabled') {
        document.body.classList.add('night-mode');
        nightModeStatus.textContent = 'On';
        updateLogo(true);
    }

    // Toggle night mode
    if (nightModeToggle) {
        nightModeToggle.addEventListener('click', function(e) {
            e.stopPropagation();
            document.body.classList.toggle('night-mode');

            if (document.body.classList.contains('night-mode')) {
                nightModeStatus.textContent = 'On';
                localStorage.setItem('nightMode', 'enabled');
                updateLogo(true);
            } else {
                nightModeStatus.textContent = 'Off';
                localStorage.setItem('nightMode', 'disabled');
                updateLogo(false);
            }
        });
    }

    // Quotes Modal functionality
const quotesModal = document.getElementById('quotesModal');
const quotesModalClose = document.getElementById('quotesModalClose');

if (quotesModalClose) {
    quotesModalClose.addEventListener('click', function() {
        quotesModal.style.display = 'none';
    });
}

// Close quotes modal when clicking outside
window.addEventListener('click', function(event) {
    if (event.target === quotesModal) {
        quotesModal.style.display = 'none';
    }
    // Project modals
    const saveProjectModal = document.getElementById('saveProjectModal');
    const loadProjectModal = document.getElementById('loadProjectModal');
    const manageProjectsModal = document.getElementById('manageProjectsModal');
    const feedbackModal = document.getElementById('feedbackModal');

    if (event.target === saveProjectModal) {
        saveProjectModal.style.display = 'none';
    }
    if (event.target === loadProjectModal) {
        loadProjectModal.style.display = 'none';
    }
    if (event.target === manageProjectsModal) {
        manageProjectsModal.style.display = 'none';
    }
    if (event.target === feedbackModal) {
        feedbackModal.style.display = 'none';
    }
});

    // Tab switching
    document.getElementById('uploadTab').addEventListener('click', function() {
        switchTab('uploadTab', 'uploadContent');
    });
    
    document.getElementById('examplesTab').addEventListener('click', function() {
        switchTab('examplesTab', 'examplesContent');
    });

    document.getElementById('pasteTab').addEventListener('click', function() {
    switchTab('pasteTab', 'pasteContent');
    });

    // About modal functionality
    const aboutButton = document.getElementById('aboutButton');
    const aboutModal = document.getElementById('aboutModal');
    const aboutModalClose = document.getElementById('aboutModalClose');

    aboutButton.addEventListener('click', function() {
        aboutModal.style.display = 'block';
    });

    aboutModalClose.addEventListener('click', function() {
        aboutModal.style.display = 'none';
    });

    // File upload event listeners
    const fileInput = document.getElementById('fileInput');
    const fileInputContainer = document.querySelector('.file-input-container');
    const compareFilesBtn = document.getElementById('compareFiles');

    // Pasted text comparison button
        const comparePastedBtn = document.getElementById('comparePastedText');
        if (comparePastedBtn) {
            comparePastedBtn.addEventListener('click', comparePastedText);
        }

    fileInput.addEventListener('change', function(e) {
        handleFileUpload(e.target.files);
    });

    // Drag and drop functionality
    fileInputContainer.addEventListener('dragover', function(e) {
        e.preventDefault();
        this.style.borderColor = 'var(--primary-color)';
        this.style.backgroundColor = 'rgba(87, 6, 140, 0.05)';
    });

    fileInputContainer.addEventListener('dragleave', function(e) {
        e.preventDefault();
        this.style.borderColor = 'var(--accent-light)';
        this.style.backgroundColor = 'transparent';
    });

    fileInputContainer.addEventListener('drop', function(e) {
        e.preventDefault();
        this.style.borderColor = 'var(--accent-light)';
        this.style.backgroundColor = 'transparent';
        handleFileUpload(e.dataTransfer.files);
    });

    compareFilesBtn.addEventListener('click', compareUploadedFiles);
                
    // Example essay functionality
    const exampleCards = document.querySelectorAll('.example-card');
    exampleCards.forEach(card => {
        const analyzeBtn = card.querySelector('.example-btn');
        
        analyzeBtn.addEventListener('click', function() {
            const essayId = card.getAttribute('data-essay');
            loadExampleEssay(essayId);
        });
    });

    // Restart landing tour button
const restartLandingTourBtn = document.getElementById('restartLandingTourBtn');
if (restartLandingTourBtn) {
    restartLandingTourBtn.addEventListener('click', function() {
        // Only show if on upload screen
        const uploadSection = document.querySelector('.upload-section');
        const comparisonResults = document.getElementById('comparisonResults');
        
        if (uploadSection && !uploadSection.classList.contains('hidden')) {
            localStorage.removeItem('landingPageTutorialComplete');
            landingTutorial = new LandingPageTutorial();
            landingTutorial.start();
        } else {
            alert('Return to the upload screen to see the tour.');
        }
    });
}
    
    // Navigation arrows
    document.getElementById('leftArrow').addEventListener('click', function() {
        if (currentPosition > 0) {
            currentPosition--;
            updateSliderPosition();
        }
    });
    
    document.getElementById('rightArrow').addEventListener('click', function() {
        if (currentPosition < totalPanels - 1) {
            currentPosition++;
            updateSliderPosition();
        }
    });
    
    // Keyboard navigation
    document.addEventListener('keydown', function(e) {
        if (document.getElementById('comparisonResults').style.display !== 'none') {
            if (e.key === 'ArrowLeft' && currentPosition > 0) {
                currentPosition--;
                updateSliderPosition();
            } else if (e.key === 'ArrowRight' && currentPosition < totalPanels - 1) {
                currentPosition++;
                updateSliderPosition();
            }
        }
    });

    // Revision Report Modal functionality
    const reportModal = document.getElementById('revisionReportModal');
    const reportModalClose = document.getElementById('reportModalClose');
    
    if (reportModalClose) {
        reportModalClose.addEventListener('click', function() {
            reportModal.style.display = 'none';
        });
    }
    
    // Annotations Modal functionality
    const annotationsModal = document.getElementById('annotationsModal');
    const annotationsModalClose = document.getElementById('annotationsModalClose');
    
    if (annotationsModalClose) {
        annotationsModalClose.addEventListener('click', function() {
            annotationsModal.style.display = 'none';
        });
    }
    
    // Close modals when clicking outside
    window.addEventListener('click', function(event) {
        if (event.target === aboutModal) {
            aboutModal.style.display = 'none';
        }
        if (event.target === reportModal) {
            reportModal.style.display = 'none';
        }
        if (event.target === annotationsModal) {
            annotationsModal.style.display = 'none';
        }
    });


    // PDF Options Modal
    const pdfOptionsModal = document.getElementById('pdfOptionsModal');
    const pdfOptionsClose = document.getElementById('pdfOptionsClose');
    const generatePdfBtn = document.getElementById('generatePdfBtn');
    const pdfCancelBtn = document.getElementById('pdfCancelBtn');
    
    if (pdfOptionsClose) {
        pdfOptionsClose.addEventListener('click', function() {
            pdfOptionsModal.style.display = 'none';
        });
    }
    
    if (generatePdfBtn) {
        generatePdfBtn.addEventListener('click', exportToPdf);
    }
    
    if (pdfCancelBtn) {
        pdfCancelBtn.addEventListener('click', function() {
            pdfOptionsModal.style.display = 'none';
        });
    }
    
    // Close PDF modal when clicking outside
    window.addEventListener('click', function(event) {
        if (event.target === pdfOptionsModal) {
            pdfOptionsModal.style.display = 'none';
        }
    });

    
    // Toggle between table and detail view for revision report
    const tableViewBtn = document.getElementById('tableViewBtn');
    const detailViewBtn = document.getElementById('detailViewBtn');
    
    if (tableViewBtn) {
        tableViewBtn.addEventListener('click', function() {
            this.classList.add('active');
            detailViewBtn.classList.remove('active');
            
            const currentPanel = document.querySelector('.comparison-slider').children[currentPosition];
            if (currentPanel && currentPanel.classList.contains('diff-panel')) {
                const diffContent = currentPanel.querySelector('.panel-content').innerHTML;
                const analysis = analyzeRevisions(diffContent);
                document.getElementById('reportContent').innerHTML = generateTableView(analysis);
            }
        });
    }
    
    if (detailViewBtn) {
        detailViewBtn.addEventListener('click', function() {
            this.classList.add('active');
            tableViewBtn.classList.remove('active');
            
            const currentPanel = document.querySelector('.comparison-slider').children[currentPosition];
            if (currentPanel && currentPanel.classList.contains('diff-panel')) {
                const diffContent = currentPanel.querySelector('.panel-content').innerHTML;
                const analysis = analyzeRevisions(diffContent);
                document.getElementById('reportContent').innerHTML = generateDetailedView(analysis);
            }
        });
    }
    
const addReportButton = () => {
    const container = document.getElementById('comparisonButtonsContainer');
    if (container && !document.getElementById('generateReportBtn')) {
        const btn = document.createElement('button');
        btn.id = 'generateReportBtn';
        btn.className = 'generate-report-btn';
        btn.textContent = 'Generate Revision Report';
        btn.onclick = generateRevisionReport;
        container.appendChild(btn);
    }
};
    
    
const addAnnotationsButton = () => {
    const container = document.getElementById('comparisonButtonsContainer');
    if (container && !document.getElementById('viewAnnotationsBtn')) {
        const btn = document.createElement('button');
        btn.id = 'viewAnnotationsBtn';
        btn.className = 'view-annotations-btn';
        btn.textContent = 'View Annotations';
        btn.onclick = displayAnnotations;
        container.appendChild(btn);
    }
};

const addPdfExportButton = () => {
    const container = document.getElementById('comparisonButtonsContainer');
    if (container && !document.getElementById('exportPdfBtn')) {
        const btn = document.createElement('button');
        btn.id = 'exportPdfBtn';
        btn.className = 'export-pdf-btn';
        btn.textContent = 'ðŸ“„ Export as PDF';
        btn.onclick = showPdfOptions;
        container.appendChild(btn);
    }
};

const addCompleteTransformationButton = () => {
    const container = document.getElementById('comparisonButtonsContainer');
    if (container && !document.getElementById('completeTransformationBtn')) {
        // Only show if there are 3+ drafts
        if (currentEssay && currentEssay.drafts && currentEssay.drafts.length >= 3) {
            const btn = document.createElement('button');
            btn.id = 'completeTransformationBtn';
            btn.className = 'generate-report-btn';
            btn.textContent = 'Compare First and Final Drafts';
            btn.onclick = showCompleteTransformation;
            container.appendChild(btn);
        }
    }
};


function showCompleteTransformation() {
    if (!currentEssay || currentEssay.drafts.length < 2) {
        alert('Not enough drafts to compare.');
        return;
    }
    
    const firstDraft = currentEssay.drafts[0];
    const finalDraft = currentEssay.drafts[currentEssay.drafts.length - 1];
    
    // Check if panel already exists
    const slider = document.getElementById('comparisonSlider');
    let existingPanelIndex = -1;
    
    Array.from(slider.children).forEach((panel, index) => {
        const heading = panel.querySelector('h3');
        if (heading && heading.textContent.includes('Complete Transformation') &&
            heading.textContent.includes(firstDraft.version) && 
            heading.textContent.includes(finalDraft.version)) {
            existingPanelIndex = index;
        }
    });
    
    // If panel exists, jump to it
    if (existingPanelIndex !== -1) {
        currentPosition = existingPanelIndex;
        updateSliderPosition();
        return;
    }
    
    // Create new panel
    const transformationPanel = document.createElement('div');
    transformationPanel.className = 'panel diff-panel';
    
    const formattedText1 = formatText(firstDraft.text);
    const formattedText2 = formatText(finalDraft.text);
    const diffContent = generateAdvancedDiff(formattedText1, formattedText2);
    
    transformationPanel.innerHTML = `
    <div style="background: var(--accent-lighter); 
                    padding: 15px; margin: -30px -25px 20px -25px; border-radius: 0;">
                    <h3 style="margin: 0; color: var(--primary-dark);">
                ðŸ“Š Complete Transformation: ${firstDraft.version} â†’ ${finalDraft.version}
            </h3>
            <p style="margin: 5px 0 0 0; color: var(--primary-color); font-size: 0.95rem;">
                This view shows all changes from your first draft to your final draft.
            </p>
        </div>
        <div class="diff-legend">
            <span class="legend-item"><span class="deletion word-level">Deleted</span></span>
            <span class="legend-item"><span class="addition word-level">Added</span></span>
        </div>
        <div class="panel-content">${diffContent}</div>
    `;
    
    // Add to end of slider
    slider.appendChild(transformationPanel);
    totalPanels++;
    
    // Jump to new panel
    currentPosition = totalPanels - 1;
    updateSliderPosition();
    
    // Enable annotations after a short delay
    setTimeout(() => {
        makeAnnotatable(
            currentEssay.title,
            firstDraft.version,
            finalDraft.version
        );
    }, 100);
    
    // Save state
    saveState();
}


// Add Draft Button functionality
let currentDraftCount = 2; // Start with 2 drafts
const maxDrafts = 5;

const addDraftBtn = document.getElementById('addDraftBtn');
if (addDraftBtn) {
    addDraftBtn.addEventListener('click', function() {
        if (currentDraftCount >= maxDrafts) {
            return;
        }
        
        currentDraftCount++;
        const container = document.getElementById('pasteContainer');
        
        // Create new draft section
        const newDraftSection = document.createElement('div');
        newDraftSection.className = 'paste-draft-section';
        newDraftSection.setAttribute('data-draft-num', currentDraftCount);
        newDraftSection.style.marginBottom = '30px';
        
        newDraftSection.innerHTML = `
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                <label style="font-weight: 600; color: var(--primary-dark); margin: 0;">
                    Draft ${currentDraftCount} Label:
                </label>
                <button class="remove-draft-btn" onclick="removeDraft(${currentDraftCount})" 
                    style="background: #dc3545; color: white; border: none; border-radius: 50%; 
                    width: 28px; height: 28px; cursor: pointer; font-size: 1.1rem; line-height: 1; 
                    transition: var(--transition-standard);"
                    onmouseover="this.style.transform='scale(1.1)'" 
                    onmouseout="this.style.transform='scale(1)'">Ã—</button>
            </div>
            <input type="text" id="paste-label-${currentDraftCount}" 
                placeholder="e.g., Draft ${currentDraftCount}, Final Draft" 
                style="width: 100%; padding: 10px; border: 2px solid var(--border-color); border-radius: 8px; 
                font-size: 1rem; margin-bottom: 10px;">
            
            <label style="display: block; font-weight: 600; color: var(--primary-dark); margin-bottom: 8px;">
                Draft ${currentDraftCount} Text:
            </label>
            <textarea id="paste-text-${currentDraftCount}" 
                placeholder="Paste your draft here..." 
                style="width: 100%; min-height: 200px; padding: 15px; border: 2px solid var(--border-color); 
                border-radius: 8px; font-family: 'Segoe UI', sans-serif; font-size: 1rem; line-height: 1.6; 
                resize: vertical;"></textarea>
        `;
        
        container.appendChild(newDraftSection);
        
        // Update button state
        if (currentDraftCount >= maxDrafts) {
            addDraftBtn.style.display = 'none';
            document.getElementById('draftLimitMessage').style.display = 'block';
        }
        
        // Scroll to new field
        newDraftSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
    });
}

// Remove draft function (global scope)
window.removeDraft = function(draftNum) {
    const section = document.querySelector(`.paste-draft-section[data-draft-num="${draftNum}"]`);
    if (section) {
        section.remove();
        currentDraftCount--;
        
        // Show add button again if we're under max
        if (currentDraftCount < maxDrafts) {
            document.getElementById('addDraftBtn').style.display = 'inline-block';
            document.getElementById('draftLimitMessage').style.display = 'none';
        }
    }
};

const observer = new MutationObserver(() => {
    if (document.getElementById('comparisonResults').style.display !== 'none') {
        addReportButton();
        addAnnotationsButton();
        addPdfExportButton();
        addCompleteTransformationButton(); // ADD THIS LINE
    }
});

observer.observe(document.getElementById('comparisonResults'), {
    attributes: true,
    attributeFilter: ['style']
})
    // Start landing page tutorial after a short delay
    setTimeout(() => {
        landingTutorial = new LandingPageTutorial();
        landingTutorial.start();
    }, 1000);

});

        // Data structure to store revision analysis
        let revisionAnalysis = {
            additions: { word: [], phrase: [], sentence: [], paragraph: [] },
            deletions: { word: [], phrase: [], sentence: [], paragraph: [] }
        };






// Enhanced Data Persistence System
let annotations = {};
let draftFeedback = {}; // Store feedback for each draft
let savedState = null;

// Save state to localStorage
function saveState() {
    try {
        const state = {
            currentEssay: currentEssay,
            currentPosition: currentPosition,
            uploadedFiles: uploadedFiles.map(file => ({
                name: file.name,
                type: file.type,
                size: file.size
            })),
            timestamp: new Date().toISOString()
        };
        
        localStorage.setItem('revisionToolState', JSON.stringify(state));
        showDataStatus('State saved âœ“');
    } catch (e) {
        console.error('Error saving state:', e);
        if (e.name === 'QuotaExceededError') {
            showDataStatus('Storage full - please clear old data', true);
        }
    }
}

// Save file contents to localStorage
async function saveFileContents(files) {
    try {
        const fileData = [];
        
        for (let file of files) {
            const content = await readFileContent(file);
            fileData.push({
                name: file.name,
                type: file.type,
                content: content,
                size: file.size
            });
        }
        
        localStorage.setItem('revisionToolFiles', JSON.stringify(fileData));
        showDataStatus('Files saved âœ“');
    } catch (e) {
        console.error('Error saving files:', e);
        if (e.name === 'QuotaExceededError') {
            showDataStatus('Files too large for storage', true);
        }
    }
}

// Load file contents from localStorage
function loadFileContents() {
    try {
        const stored = localStorage.getItem('revisionToolFiles');
        if (stored) {
            return JSON.parse(stored);
        }
    } catch (e) {
        console.error('Error loading files:', e);
    }
    return null;
}

// Load state from localStorage
function loadState() {
    try {
        const stored = localStorage.getItem('revisionToolState');
        if (stored) {
            savedState = JSON.parse(stored);
            return savedState;
        }
    } catch (e) {
        console.error('Error loading state:', e);
    }
    return null;
}

// Load annotations from localStorage
function loadAnnotations() {
    try {
        const stored = localStorage.getItem('revisionAnnotations');
        if (stored) {
            annotations = JSON.parse(stored);
        }
    } catch (e) {
        console.error('Error loading annotations:', e);
        annotations = {};
    }
}

// Save annotations to localStorage
function saveAnnotations() {
    try {
        localStorage.setItem('revisionAnnotations', JSON.stringify(annotations));
        showDataStatus('Annotations saved âœ“');
    } catch (e) {
        console.error('Error saving annotations:', e);
    }
}

// ===== DRAFT FEEDBACK FUNCTIONS =====

// Generate unique ID for feedback based on essay and draft
function getFeedbackId(essayTitle, draftVersion) {
    return `${essayTitle}|${draftVersion}`;
}

// Generate UUID for feedback items
function generateUUID() {
    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
        const r = Math.random() * 16 | 0;
        const v = c === 'x' ? r : (r & 0x3 | 0x8);
        return v.toString(16);
    });
}

// Migrate old feedback format to new format
function migrateFeedbackData(oldData) {
    const newData = {};

    for (const [key, value] of Object.entries(oldData)) {
        // Check if already in new format
        if (typeof value === 'object' && value.items) {
            newData[key] = value;
        } else if (typeof value === 'string' && value.trim()) {
            // Migrate old string format to new structure
            newData[key] = {
                items: [{
                    id: generateUUID(),
                    source: 'other',
                    sourceName: '',
                    date: new Date().toISOString().split('T')[0],
                    content: value,
                    tags: [],
                    attachments: []
                }]
            };
        }
    }

    return newData;
}

// Load feedback from localStorage
function loadDraftFeedback() {
    try {
        const stored = localStorage.getItem('revisionDraftFeedback');
        if (stored) {
            const parsed = JSON.parse(stored);
            draftFeedback = migrateFeedbackData(parsed);

            // Save migrated data back to localStorage
            if (JSON.stringify(parsed) !== JSON.stringify(draftFeedback)) {
                saveDraftFeedback();
                console.log('Feedback data migrated to new format');
            }
        }
    } catch (e) {
        console.error('Error loading feedback:', e);
        draftFeedback = {};
    }
}

// Save feedback to localStorage
function saveDraftFeedback() {
    try {
        localStorage.setItem('revisionDraftFeedback', JSON.stringify(draftFeedback));
        showDataStatus('Feedback saved âœ“');
    } catch (e) {
        console.error('Error saving feedback:', e);
    }
}

// Enhanced Feedback Modal State
let currentFeedbackId = null;
let currentEditingFeedbackItemId = null;
let currentFeedbackTags = [];
let currentFeedbackAttachments = [];

// Show feedback modal for a draft (List View)
function showFeedbackModal(essayTitle, draftVersion) {
    currentFeedbackId = getFeedbackId(essayTitle, draftVersion);
    const modal = document.getElementById('feedbackModal');
    const listView = document.getElementById('feedbackListView');
    const entryForm = document.getElementById('feedbackEntryForm');
    const draftNameSpan = document.getElementById('feedbackDraftName');

    // Set draft name
    draftNameSpan.textContent = draftVersion;

    // Show list view, hide entry form
    listView.style.display = 'block';
    entryForm.style.display = 'none';

    // Render feedback list
    renderFeedbackList();

    // Show modal
    modal.style.display = 'block';
}

// Render feedback list for current draft
function renderFeedbackList() {
    const feedbackListEl = document.getElementById('feedbackItemsList');
    const feedbackData = draftFeedback[currentFeedbackId];

    if (!feedbackData || !feedbackData.items || feedbackData.items.length === 0) {
        feedbackListEl.innerHTML = `
            <div class="feedback-item-empty">
                <p>No feedback yet for this draft.</p>
                <p>Click "+ Add Feedback" to get started.</p>
            </div>
        `;
        return;
    }

    // Calculate understanding progress
    const totalItems = feedbackData.items.length;
    const understoodItems = feedbackData.items.filter(item => item.understood).length;
    const progressPercent = Math.round((understoodItems / totalItems) * 100);

    // Sort by date (most recent first)
    const items = [...feedbackData.items].sort((a, b) =>
        new Date(b.date) - new Date(a.date)
    );

    // Build progress bar
    let progressHTML = '';
    if (totalItems > 0) {
        const progressColor = progressPercent === 100 ? '#57068c' :
                             progressPercent >= 50 ? '#702b9d' : '#6c757d';

        progressHTML = `
            <div class="feedback-progress-container">
                <div class="feedback-progress-header">
                    <span class="feedback-progress-label">Understanding Progress</span>
                    <span class="feedback-progress-count">${understoodItems} of ${totalItems} understood</span>
                </div>
                <div class="feedback-progress-bar">
                    <div class="feedback-progress-fill" style="width: ${progressPercent}%; background-color: ${progressColor};"></div>
                </div>
            </div>
        `;
    }

    const itemsHTML = items.map(item => {
        const sourceIcons = {
            'instructor': 'ðŸ“š',
            'peer': 'ðŸ‘¥',
            'writing-center': 'ðŸ“',
            'self': 'ðŸ’­',
            'other': 'ðŸ“Œ'
        };

        const sourceLabels = {
            'instructor': 'Instructor',
            'peer': 'Peer',
            'writing-center': 'Writing Center',
            'self': 'Self-Analysis',
            'other': 'Other'
        };

        const icon = sourceIcons[item.source] || 'ðŸ“Œ';
        const label = sourceLabels[item.source] || 'Other';
        const displayName = item.sourceName ? ` (${item.sourceName})` : '';

        // Strip HTML tags and truncate content for preview
        const textContent = item.content.replace(/<[^>]*>/g, ' ').replace(/\s+/g, ' ').trim();
        const contentPreview = textContent.length > 150
            ? textContent.substring(0, 150) + '...'
            : textContent;

        // Format date
        const formattedDate = new Date(item.date).toLocaleDateString('en-US', {
            month: 'short',
            day: 'numeric',
            year: 'numeric'
        });

        // Understanding status badge
        const understoodBadge = item.understood
            ? '<span class="understanding-badge understood">âœ“ Understood</span>'
            : '<span class="understanding-badge not-understood">âš ï¸ Not Yet</span>';

        return `
            <div class="feedback-item ${item.understood ? 'item-understood' : ''}" onclick="editFeedbackItem('${item.id}')">
                <div class="feedback-item-header">
                    <div class="feedback-item-source">
                        <span>${icon}</span>
                        <span>${label}${displayName}</span>
                    </div>
                    <div style="display: flex; align-items: center; gap: 10px;">
                        ${understoodBadge}
                        <div class="feedback-item-date">${formattedDate}</div>
                    </div>
                </div>
                <div class="feedback-item-content">${contentPreview}</div>
                ${item.tags && item.tags.length > 0 ? `
                    <div class="feedback-item-tags">
                        ${item.tags.map(tag => `<span class="feedback-item-tag">${tag}</span>`).join('')}
                    </div>
                ` : ''}
            </div>
        `;
    }).join('');

    feedbackListEl.innerHTML = progressHTML + itemsHTML;
}

// Show feedback entry form (for new or edit)
function showFeedbackEntryForm(itemId = null) {
    const listView = document.getElementById('feedbackListView');
    const entryForm = document.getElementById('feedbackEntryForm');
    const formTitle = document.getElementById('feedbackFormTitle');
    const deleteBtn = document.getElementById('feedbackDeleteBtn');

    // Hide list, show form
    listView.style.display = 'none';
    entryForm.style.display = 'block';

    // Reset form
    resetFeedbackForm();

    if (itemId) {
        // Edit mode
        currentEditingFeedbackItemId = itemId;
        formTitle.textContent = 'Edit Feedback';
        deleteBtn.style.display = 'block';
        loadFeedbackItemForEditing(itemId);
    } else {
        // New mode
        currentEditingFeedbackItemId = null;
        formTitle.textContent = 'Add New Feedback';
        deleteBtn.style.display = 'none';

        // Set today's date
        document.getElementById('feedbackDate').valueAsDate = new Date();
    }
}

// Edit feedback item
function editFeedbackItem(itemId) {
    showFeedbackEntryForm(itemId);
}

// Update priority slider display values
function updateScopeDisplay(value) {
    const scopeValue = document.getElementById('scopeValue');
    if (!scopeValue) return;

    if (value < 33) {
        scopeValue.textContent = 'Local';
    } else if (value < 67) {
        scopeValue.textContent = 'Local â† â†’ Global';
    } else {
        scopeValue.textContent = 'Global';
    }
}

function updateImpactDisplay(value) {
    const impactValue = document.getElementById('impactValue');
    if (!impactValue) return;

    if (value < 33) {
        impactValue.textContent = 'Low Impact';
    } else if (value < 67) {
        impactValue.textContent = 'Low â† â†’ High';
    } else {
        impactValue.textContent = 'High Impact';
    }
}

// Load feedback item for editing
function loadFeedbackItemForEditing(itemId) {
    const feedbackData = draftFeedback[currentFeedbackId];
    if (!feedbackData || !feedbackData.items) return;

    const item = feedbackData.items.find(i => i.id === itemId);
    if (!item) return;

    // Set source
    const sourceBtn = document.querySelector(`.source-btn[data-source="${item.source}"]`);
    if (sourceBtn) sourceBtn.click();

    // Set source name and date
    document.getElementById('feedbackSourceName').value = item.sourceName || '';
    document.getElementById('feedbackDate').value = item.date;

    // Set content
    document.getElementById('feedbackContentEditor').innerHTML = item.content;

    // Set self-analysis fields if applicable
    if (item.source === 'self' && item.goals) {
        document.getElementById('selfGoals').value = item.goals || '';
        document.getElementById('selfImproving').value = item.tryingToImprove || '';
    }

    // Set tags
    currentFeedbackTags = [...(item.tags || [])];
    renderTags();

    // Set attachments
    currentFeedbackAttachments = [...(item.attachments || [])];
    renderAttachments();

    // Show/hide understanding section based on source
    const understandingSection = document.getElementById('understandingSection');
    if (item.source !== 'self') {
        understandingSection.style.display = 'block';

        // Set understanding fields
        const understoodCheckbox = document.getElementById('feedbackUnderstoodCheckbox');
        understoodCheckbox.checked = item.understood || false;

        document.getElementById('understandingExplanation').value = item.understandingExplanation || '';
        document.getElementById('understandingActionPlan').value = item.understandingActionPlan || '';
        document.getElementById('understandingQuestions').value = item.understandingQuestions || '';

        // Validate understanding fields to enable/disable checkbox
        validateUnderstandingFields();
    } else {
        understandingSection.style.display = 'none';
    }
}

// Reset feedback form
function resetFeedbackForm() {
    // Hide any error messages
    hideFeedbackModalError();

    // Deselect all source buttons
    document.querySelectorAll('.source-btn').forEach(btn => btn.classList.remove('active'));

    // Clear inputs
    document.getElementById('feedbackSourceName').value = '';
    document.getElementById('feedbackDate').value = '';
    document.getElementById('feedbackContentEditor').innerHTML = '';
    document.getElementById('selfGoals').value = '';
    document.getElementById('selfImproving').value = '';
    document.getElementById('feedbackTagsInput').value = '';

    // Clear state
    currentFeedbackTags = [];
    currentFeedbackAttachments = [];
    currentEditingFeedbackItemId = null;

    // Render empty tags and attachments
    renderTags();
    renderAttachments();

    // Hide self-analysis fields
    document.getElementById('selfAnalysisFields').style.display = 'none';

    // Reset understanding section
    document.getElementById('understandingSection').style.display = 'none';
    document.getElementById('feedbackUnderstoodCheckbox').checked = false;
    document.getElementById('understandingExplanation').value = '';
    document.getElementById('understandingActionPlan').value = '';
    document.getElementById('understandingQuestions').value = '';
}

// Cancel feedback entry (return to list)
function cancelFeedbackEntry() {
    // Hide any error messages
    hideFeedbackModalError();

    const listView = document.getElementById('feedbackListView');
    const entryForm = document.getElementById('feedbackEntryForm');

    // Show list, hide form
    listView.style.display = 'block';
    entryForm.style.display = 'none';

    // Re-render list
    renderFeedbackList();
}

// Show synthesis view
function showSynthesisView() {
    const listView = document.getElementById('feedbackListView');
    const synthesisView = document.getElementById('feedbackSynthesisView');

    // Hide list, show synthesis
    listView.style.display = 'none';
    synthesisView.style.display = 'block';

    // Load synthesis notes
    loadSynthesisNotes();

    // Render priorities list
    renderPriorities();
}

// Load synthesis notes
function loadSynthesisNotes() {
    const feedbackData = draftFeedback[currentFeedbackId];
    if (feedbackData && feedbackData.synthesis) {
        document.getElementById('synthesisConvergence').value = feedbackData.synthesis.convergence || '';
        document.getElementById('synthesisDivergence').value = feedbackData.synthesis.divergence || '';
    } else {
        document.getElementById('synthesisConvergence').value = '';
        document.getElementById('synthesisDivergence').value = '';
    }
}

// Save synthesis notes
function saveSynthesisNotes() {
    const convergence = document.getElementById('synthesisConvergence').value.trim();
    const divergence = document.getElementById('synthesisDivergence').value.trim();

    // Initialize feedback data structure if needed
    if (!draftFeedback[currentFeedbackId]) {
        draftFeedback[currentFeedbackId] = { items: [] };
    }

    // Get existing priorities (don't overwrite them here)
    const existingPriorities = draftFeedback[currentFeedbackId].synthesis?.priorities || [];

    // Save synthesis notes
    draftFeedback[currentFeedbackId].synthesis = {
        convergence: convergence,
        divergence: divergence,
        priorities: existingPriorities
    };

    // Save to localStorage
    saveDraftFeedback();

    // Show confirmation (optional)
    showSuccess('Synthesis notes saved!');
}

// Add a new priority
function addPriority() {
    const input = document.getElementById('priorityInput');
    const priorityText = input.value.trim();

    if (!priorityText) {
        return; // Don't add empty priorities
    }

    // Get selected scope and impact
    const scopeRadio = document.querySelector('input[name="priorityScope"]:checked');
    const impactRadio = document.querySelector('input[name="priorityImpact"]:checked');

    const scope = scopeRadio ? scopeRadio.value : 'local';
    const impact = impactRadio ? impactRadio.value : 'low';

    // Initialize feedback data structure if needed
    if (!draftFeedback[currentFeedbackId]) {
        draftFeedback[currentFeedbackId] = { items: [] };
    }
    if (!draftFeedback[currentFeedbackId].synthesis) {
        draftFeedback[currentFeedbackId].synthesis = {
            convergence: '',
            divergence: '',
            priorities: []
        };
    }
    if (!draftFeedback[currentFeedbackId].synthesis.priorities) {
        draftFeedback[currentFeedbackId].synthesis.priorities = [];
    }

    // Create priority object
    const priority = {
        id: generateUUID(),
        text: priorityText,
        scope: scope,
        impact: impact
    };

    // Add to priorities array
    draftFeedback[currentFeedbackId].synthesis.priorities.push(priority);

    // Save to localStorage
    saveDraftFeedback();

    // Re-render the list
    renderPriorities();

    // Clear input and reset radio buttons
    input.value = '';
    const defaultScopeRadio = document.querySelector('input[name="priorityScope"][value="local"]');
    const defaultImpactRadio = document.querySelector('input[name="priorityImpact"][value="low"]');
    if (defaultScopeRadio) defaultScopeRadio.checked = true;
    if (defaultImpactRadio) defaultImpactRadio.checked = true;

    // Focus back on input
    input.focus();
}

// Render priorities list
function renderPriorities() {
    const prioritiesList = document.getElementById('prioritiesList');
    if (!prioritiesList) return;

    const feedbackData = draftFeedback[currentFeedbackId];
    const priorities = feedbackData?.synthesis?.priorities || [];

    if (priorities.length === 0) {
        prioritiesList.innerHTML = '<p class="empty-priorities">No priorities added yet. Add your first revision priority above.</p>';
        return;
    }

    prioritiesList.innerHTML = priorities.map((priority, index) => `
        <div class="priority-item" data-priority-id="${priority.id}">
            <span class="priority-drag-handle">â‹®â‹®</span>
            <div class="priority-content">
                <p class="priority-text">${priority.text}</p>
                <div class="priority-tags">
                    <span class="priority-tag scope-${priority.scope}">${priority.scope === 'local' ? 'Local (word/sentence)' : 'Global (structure/argument)'}</span>
                    <span class="priority-tag impact-${priority.impact}">${priority.impact === 'low' ? 'Low Impact' : 'High Impact'}</span>
                </div>
            </div>
            <button class="priority-delete-btn" onclick="deletePriority('${priority.id}')" title="Delete this priority">Ã—</button>
        </div>
    `).join('');
}

// Delete a priority
function deletePriority(priorityId) {
    const feedbackData = draftFeedback[currentFeedbackId];
    if (!feedbackData || !feedbackData.synthesis || !feedbackData.synthesis.priorities) return;

    // Remove the priority from the array
    feedbackData.synthesis.priorities = feedbackData.synthesis.priorities.filter(
        p => p.id !== priorityId
    );

    // Save to localStorage
    saveDraftFeedback();

    // Re-render the list
    renderPriorities();
}

// Render priority matrix (keep for backward compatibility, but no longer used in UI)
function renderPriorityMatrix() {
    const feedbackData = draftFeedback[currentFeedbackId];
    if (!feedbackData || !feedbackData.items) return;

    // Clear all quadrants
    for (let i = 1; i <= 4; i++) {
        const quadrant = document.getElementById(`matrixQuadrant${i}`);
        if (quadrant) quadrant.innerHTML = '';
    }

    // Determine which quadrant each feedback item belongs to
    feedbackData.items.forEach(item => {
        const scope = item.scope || 50;  // default to middle
        const impact = item.impact || 50; // default to middle

        // Determine quadrant:
        // scope < 50 = Local (left), scope >= 50 = Global (right)
        // impact < 50 = Low (bottom), impact >= 50 = High (top)
        let quadrantNum;
        if (scope < 50 && impact >= 50) {
            quadrantNum = 1; // Top-left: Local & High Impact
        } else if (scope >= 50 && impact >= 50) {
            quadrantNum = 2; // Top-right: Global & High Impact
        } else if (scope < 50 && impact < 50) {
            quadrantNum = 3; // Bottom-left: Local & Low Impact
        } else {
            quadrantNum = 4; // Bottom-right: Global & Low Impact
        }

        // Create feedback card
        const card = document.createElement('div');
        card.className = 'matrix-feedback-card';
        card.dataset.itemId = item.id;

        // Get source badge
        const sourceColors = {
            'instructor': '#7c4dff',
            'peer': '#26a69a',
            'writing-center': '#42a5f5',
            'self': '#ffa726',
            'other': '#78909c'
        };
        const sourceLabels = {
            'instructor': 'Instructor',
            'peer': 'Peer',
            'writing-center': 'Writing Center',
            'self': 'Self-Analysis',
            'other': item.sourceName || 'Other'
        };

        const sourceBadge = document.createElement('div');
        sourceBadge.className = 'matrix-card-source';
        sourceBadge.style.backgroundColor = sourceColors[item.source] || sourceColors['other'];
        sourceBadge.style.color = 'white';
        sourceBadge.textContent = sourceLabels[item.source] || 'Feedback';

        // Get content preview
        const textContent = item.content.replace(/<[^>]*>/g, ' ').replace(/\s+/g, ' ').trim();
        const contentPreview = textContent.length > 60
            ? textContent.substring(0, 60) + '...'
            : textContent;

        const contentDiv = document.createElement('div');
        contentDiv.className = 'matrix-card-content';
        contentDiv.textContent = contentPreview;

        card.appendChild(sourceBadge);
        card.appendChild(contentDiv);

        // Add click handler to view/edit feedback
        card.addEventListener('click', function() {
            // Close synthesis view, open entry form to edit this item
            document.getElementById('feedbackSynthesisView').style.display = 'none';
            showFeedbackEntryForm(item.id);
        });

        // Add to quadrant
        const quadrant = document.getElementById(`matrixQuadrant${quadrantNum}`);
        if (quadrant) {
            quadrant.appendChild(card);
        }
    });
}

// Close feedback modal
function closeFeedbackModal() {
    document.getElementById('feedbackModal').style.display = 'none';

    // Refresh panels to update button icon
    if (currentEssay) {
        const panelInfo = createPanels(currentEssay);
        updateSliderPosition();
        updateNavigationInfo(panelInfo);
    }
}

// Show error in feedback modal
function showFeedbackModalError(message) {
    const errorEl = document.getElementById('feedbackModalError');
    if (errorEl) {
        errorEl.textContent = message;
        errorEl.style.display = 'block';

        // Scroll to top of form to show error
        const entryForm = document.getElementById('feedbackEntryForm');
        if (entryForm) {
            entryForm.scrollTop = 0;
        }

        // Auto-hide after 5 seconds
        setTimeout(() => {
            errorEl.style.display = 'none';
        }, 5000);
    }
}

// Hide modal error
function hideFeedbackModalError() {
    const errorEl = document.getElementById('feedbackModalError');
    if (errorEl) {
        errorEl.style.display = 'none';
    }
}

// Save feedback from modal
function saveFeedbackFromModal() {
    // Hide any existing error
    hideFeedbackModalError();

    // Get selected source
    const selectedSourceBtn = document.querySelector('.source-btn.active');
    if (!selectedSourceBtn) {
        showFeedbackModalError('Please select a feedback source');
        return;
    }

    const source = selectedSourceBtn.dataset.source;
    const sourceName = document.getElementById('feedbackSourceName').value.trim();
    let date = document.getElementById('feedbackDate').value;
    const content = document.getElementById('feedbackContentEditor').innerHTML.trim();

    // Validate content - check if there's actual text after stripping HTML
    const textContent = content.replace(/<[^>]*>/g, '').trim();
    if (!textContent) {
        showFeedbackModalError('Please enter feedback content');
        return;
    }

    // Use today's date if not provided
    if (!date) {
        date = new Date().toISOString().split('T')[0];
    }

    // Build feedback item
    const feedbackItem = {
        id: currentEditingFeedbackItemId || generateUUID(),
        source: source,
        sourceName: sourceName,
        date: date,
        content: content,
        tags: [...currentFeedbackTags],
        attachments: [...currentFeedbackAttachments]
    };

    // Add self-analysis fields if applicable
    if (source === 'self') {
        feedbackItem.goals = document.getElementById('selfGoals').value.trim();
        feedbackItem.tryingToImprove = document.getElementById('selfImproving').value.trim();
    }

    // Add understanding fields (for non-self sources)
    if (source !== 'self') {
        feedbackItem.understood = document.getElementById('feedbackUnderstoodCheckbox').checked;
        feedbackItem.understandingExplanation = document.getElementById('understandingExplanation').value.trim();
        feedbackItem.understandingActionPlan = document.getElementById('understandingActionPlan').value.trim();
        feedbackItem.understandingQuestions = document.getElementById('understandingQuestions').value.trim();
    }

    // Initialize feedback data structure if needed
    if (!draftFeedback[currentFeedbackId]) {
        draftFeedback[currentFeedbackId] = { items: [] };
    }

    // Add or update item
    if (currentEditingFeedbackItemId) {
        // Update existing
        const index = draftFeedback[currentFeedbackId].items.findIndex(
            item => item.id === currentEditingFeedbackItemId
        );
        if (index !== -1) {
            draftFeedback[currentFeedbackId].items[index] = feedbackItem;
        }
    } else {
        // Add new
        draftFeedback[currentFeedbackId].items.push(feedbackItem);
    }

    // Save to localStorage
    saveDraftFeedback();

    // Return to list view
    cancelFeedbackEntry();
}

// Delete feedback item
function deleteFeedbackFromModal() {
    if (!confirm('Delete this feedback item?')) {
        return;
    }

    if (!currentEditingFeedbackItemId) return;

    // Remove item
    const feedbackData = draftFeedback[currentFeedbackId];
    if (feedbackData && feedbackData.items) {
        feedbackData.items = feedbackData.items.filter(
            item => item.id !== currentEditingFeedbackItemId
        );

        // If no items left, remove the entire entry
        if (feedbackData.items.length === 0) {
            delete draftFeedback[currentFeedbackId];
        }
    }

    // Save to localStorage
    saveDraftFeedback();

    // Return to list view
    cancelFeedbackEntry();
}

// Tags Management
function addTag(tagName) {
    if (!tagName || currentFeedbackTags.includes(tagName)) return;

    currentFeedbackTags.push(tagName);
    renderTags();
}

function removeTag(tagName) {
    currentFeedbackTags = currentFeedbackTags.filter(t => t !== tagName);
    renderTags();
}

function renderTags() {
    const tagsDisplay = document.getElementById('feedbackTagsDisplay');
    tagsDisplay.innerHTML = currentFeedbackTags.map(tag => `
        <span class="tag-item">
            ${tag}
            <span class="tag-remove" onclick="removeTag('${tag}')">Ã—</span>
        </span>
    `).join('');
}

// File Attachments Management
function handleFeedbackFileUpload(event) {
    const files = Array.from(event.target.files);

    files.forEach(file => {
        const reader = new FileReader();
        reader.onload = function(e) {
            currentFeedbackAttachments.push({
                name: file.name,
                type: file.type,
                size: file.size,
                data: e.target.result
            });
            renderAttachments();
        };
        reader.readAsDataURL(file);
    });

    // Clear input
    event.target.value = '';
}

function removeAttachment(index) {
    currentFeedbackAttachments.splice(index, 1);
    renderAttachments();
}

function renderAttachments() {
    const attachmentsList = document.getElementById('feedbackAttachmentsList');

    if (currentFeedbackAttachments.length === 0) {
        attachmentsList.innerHTML = '';
        return;
    }

    attachmentsList.innerHTML = currentFeedbackAttachments.map((attachment, index) => {
        const sizeKB = (attachment.size / 1024).toFixed(1);
        const icon = attachment.type.includes('pdf') ? 'ðŸ“„' :
                     attachment.type.includes('image') ? 'ðŸ–¼ï¸' : 'ðŸ“Ž';

        return `
            <div class="attachment-item">
                <div class="attachment-info">
                    <span class="attachment-icon">${icon}</span>
                    <span class="attachment-name">${attachment.name}</span>
                    <span class="attachment-size">(${sizeKB} KB)</span>
                </div>
                <button type="button" class="attachment-remove" onclick="removeAttachment(${index})">Ã—</button>
            </div>
        `;
    }).join('');
}

// ===== END DRAFT FEEDBACK FUNCTIONS =====

// Show data status message
function showDataStatus(message, isError = false) {
    const statusEl = document.getElementById('dataStatus');
    if (!statusEl) return;
    
    statusEl.textContent = message;
    statusEl.style.borderColor = isError ? '#dc3545' : 'var(--primary-color)';
    statusEl.style.color = isError ? '#dc3545' : 'var(--primary-dark)';
    statusEl.classList.add('show');
    
    setTimeout(() => {
        statusEl.classList.remove('show');
    }, 3000);
}

// Show restore modal
function showRestoreBanner() {
    const state = loadState();
    const files = loadFileContents();

    if (!state && !files) return;

    // Build message
    let message = 'Previous session found! ';
    if (state && state.currentEssay) {
        const date = new Date(state.timestamp).toLocaleString();
        message += `You were working on "${state.currentEssay.title}" (${date}).`;
    } else if (files) {
        message += `You have ${files.length} saved file(s).`;
    }

    // Update modal message and show it
    const modal = document.getElementById('restoreSessionModal');
    const messageEl = document.getElementById('restoreSessionMessage');
    messageEl.textContent = message;
    modal.style.display = 'flex';
    modal.style.alignItems = 'center';
    modal.style.justifyContent = 'center';

    // Restore button
    const restoreBtn = document.getElementById('restoreSessionBtn');
    const newRestoreBtn = restoreBtn.cloneNode(true);
    restoreBtn.parentNode.replaceChild(newRestoreBtn, restoreBtn);
    newRestoreBtn.addEventListener('click', async function() {
        await restoreSession();
        modal.style.display = 'none';
    });

    // Start fresh button
    const startFreshBtn = document.getElementById('startFreshBtn');
    const newStartFreshBtn = startFreshBtn.cloneNode(true);
    startFreshBtn.parentNode.replaceChild(newStartFreshBtn, startFreshBtn);
    newStartFreshBtn.addEventListener('click', function() {
        modal.style.display = 'none';
    });

    // Close button
    const closeBtn = document.getElementById('restoreSessionModalClose');
    const newCloseBtn = closeBtn.cloneNode(true);
    closeBtn.parentNode.replaceChild(newCloseBtn, closeBtn);
    newCloseBtn.addEventListener('click', function() {
        modal.style.display = 'none';
    });

    // Close on outside click
    modal.addEventListener('click', function(event) {
        if (event.target === modal) {
            modal.style.display = 'none';
        }
    });
}

// Restore previous session
async function restoreSession() {
    const state = loadState();
    const files = loadFileContents();
    
    if (!state && !files) {
        showDataStatus('No saved session found', true);
        return;
    }
    
    // Show loading
    document.getElementById('loadingSpinner').style.display = 'flex';
    
    try {
        if (state && state.currentEssay) {
            currentEssay = state.currentEssay;
            
            // Hide upload section
            const uploadSection = document.querySelector('.upload-section');
            if (uploadSection) uploadSection.classList.add('hidden');
            
            // Recreate panels
            const panelInfo = createPanels(currentEssay);
            totalPanels = panelInfo.length;
            currentPosition = state.currentPosition || 0;
            
            // Show comparison results
            const comparisonResults = document.getElementById('comparisonResults');
            comparisonResults.style.display = 'block';
            updateSliderPosition();
            updateNavigationInfo(panelInfo);
            
            setupNewComparisonButton();
            
            showDataStatus('Session restored! âœ“');
        } else if (files && files.length > 0) {
            // Restore uploaded files
            uploadedFiles = files;
            
            // Show file list
            const fileList = document.getElementById('fileList');
            const compareBtn = document.getElementById('compareFiles');
            
            fileList.innerHTML = '';
            files.forEach(fileData => {
                const fileItem = document.createElement('div');
                fileItem.className = 'file-item';
                fileItem.innerHTML = `
                    <div>
                        <div class="file-name">${fileData.name}</div>
                        <div class="file-size">${(fileData.size / 1024).toFixed(1)} KB</div>
                    </div>
                    <button class="remove-file" onclick="removeRestoredFile('${fileData.name}')">Ã—</button>
                `;
                fileList.appendChild(fileItem);
            });
            
            fileList.style.display = 'block';
            if (files.length >= 2) {
                compareBtn.style.display = 'block';
            }
            
            showDataStatus(`${files.length} file(s) restored âœ“`);
        }
    } catch (error) {
        console.error('Error restoring session:', error);
        showDataStatus('Error restoring session', true);
    } finally {
        document.getElementById('loadingSpinner').style.display = 'none';
    }
}

// Remove restored file
window.removeRestoredFile = function(fileName) {
    uploadedFiles = uploadedFiles.filter(file => file.name !== fileName);
    
    const fileList = document.getElementById('fileList');
    const compareBtn = document.getElementById('compareFiles');
    
    fileList.innerHTML = '';
    
    if (uploadedFiles.length === 0) {
        fileList.style.display = 'none';
        compareBtn.style.display = 'none';
        localStorage.removeItem('revisionToolFiles');
    } else {
        uploadedFiles.forEach(fileData => {
            const fileItem = document.createElement('div');
            fileItem.className = 'file-item';
            fileItem.innerHTML = `
                <div>
                    <div class="file-name">${fileData.name}</div>
                    <div class="file-size">${(fileData.size / 1024).toFixed(1)} KB</div>
                </div>
                <button class="remove-file" onclick="removeRestoredFile('${fileData.name}')">Ã—</button>
            `;
            fileList.appendChild(fileItem);
        });
        compareBtn.style.display = uploadedFiles.length >= 2 ? 'block' : 'none';
        saveFileContents(uploadedFiles);
    }
};

// Clear all saved data
// ===== PROJECT MANAGEMENT FUNCTIONS =====

const MAX_PROJECTS = 5;

function getProjects() {
    const projectsData = localStorage.getItem('revisionToolProjects');
    const savedProjects = projectsData ? JSON.parse(projectsData) : [];

    // Add hardcoded sample project if it doesn't already exist
    const sampleProject = {
        name: "ðŸ“˜ Sample Project: SNL Rhetorical Analysis",
        savedDate: "2024-01-01T00:00:00.000Z",
        essay: {
            title: "When Did We Decide This Was Fine?",
            author: "Sample Essay",
            description: "How satire exploits exigence, audience, and constraints to critique normalized age gaps",
            drafts: [
                {
                    version: "Draft 1",
                    text: `Tina Fey and Amy Poehler stand behind a podium bathed in gameshow lighting, introducing three middle-aged contestantsâ€”a professor, a software engineer, a financial analystâ€”to "America's favorite new show." The audience knows what's coming. The men don't. When the first contestant meets his future second wife, she's five years old, holding up her fingers to show her age. The laughter in the studio shifts register, nervous and strangled. By the time we reach the ultrasoundâ€”one contestant's future wife hasn't even been born yetâ€”the discomfort is palpable. This is Saturday Night Live's "Meet Your Second Wife," a sketch that has lived online ever since, resurfacing whenever a celebrity with a much younger partner makes headlines. The premise weaponizes a simple temporal shift: show us today what we'll accept tomorrow, and suddenly what seemed normal reveals itself as grotesque.

But here's the problem the sketch creates even as it critiques: Does making us laugh at age-gap relationships actually challenge them, or does comedy just give us permission to enjoy the spectacle while changing nothing? When we share the sketch on social media with crying-laughing emojis, are we engaging in cultural criticism or participating in the very normalization we claim to oppose? The sketch positions itself as confrontational satire, but it might be something more ambiguousâ€”a rhetorical move that exposes a cultural problem while simultaneously defusing the discomfort necessary to address it.

Lloyd Bitzer's 1968 essay "The Rhetorical Situation" offers a framework for understanding how discourse responds toâ€”and attempts to modifyâ€”social problems. For Bitzer, effective rhetoric requires three elements working in concert: an exigence (a problem discourse can address), an audience capable of creating change, and constraints that shape how the message must be delivered. "Meet Your Second Wife" assembles all three elements with precision, but it also reveals the paradox inherent in satirizing behavior that's already widely accepted. The sketch doesn't just critique age-gap relationships; it exposes our collective willingness to tolerate them, which raises an uncomfortable question about whether we're laughing with recognition or laughing to avoid reckoning.

The exigence here is both obvious and invisible. We all knowâ€”in that abstract, unconsidered way we "know" many thingsâ€”that middle-aged men often date women young enough to be their daughters. We've seen it celebrated in celebrity culture, joked about in sitcoms, naturalized through repetition until it registers as just another fact of contemporary life. A fifty-year-old actor with a twenty-eight-year-old girlfriend occasions at most a raised eyebrow, often accompanied by a winking comment about him "still having it." The sketch's brilliance lies in its refusal to moralize. It simply asks: what's the moral difference between that relationship and the one we're watching, other than timing? If we find the five-year-old holding up her fingers unconscionableâ€”if the ultrasound makes us deeply uncomfortableâ€”what does it mean that we'll find the same relationship unremarkable twenty or thirty years hence?

This is what Bitzer would call making the exigence visible. The problem isn't illegalâ€”laws already prohibit relationships with minorsâ€”but it exists in that murky zone where what's permissible and what's ethical don't quite align. No social mechanism challenges the appropriateness of these age gaps between consenting adults, which means the issue lives in the realm of cultural attitudes rather than policy. And cultural attitudes, Bitzer argues, are precisely what rhetoric can modify. The sketch forces viewers to confront discomfort they've been trained to ignore, turning the normalized into the newly strange.

Who, exactly, is meant to see this? Bitzer would call them "mediators of change"â€”people with the power to shift the cultural ground beneath a problem. SNL's audience trends educated, politically engaged, predominantly under fifty. Many of them participate in the very dating culture the sketch indicts, or at least swim in its waters. They've swiped past age preferences on dating apps, laughed at sitcom jokes about "trading up," scrolled through celebrity gossip that treats a forty-five-year-old actor's twenty-three-year-old girlfriend as aspirational rather than alarming. The sketch doesn't target individual men who date younger women; it targets all of us who've normalized the behavior through our consumption and repetition of these cultural scripts.

The sketch's genius lies in its understanding of what its audience already believes. We find relationships between adults and children unconscionableâ€”this is bedrock, the common ground Bitzer says rhetoric must build on. What "Meet Your Second Wife" does is draw a line connecting that uncontroversial disapproval to something we've been perfectly comfortable ignoring. The temporal trick makes the connection visceral rather than intellectual. We don't need to be convinced that showing a man his five-year-old future wife represents a boundary violation; we already know it. The ultrasound pushes even furtherâ€”we're watching a man meet someone who doesn't exist yet, and the absurdity forces us to ask why the same age gap, decades later, will barely register. The sketch plants cognitive dissonance where none existed before, and then trusts us to feel uncomfortable about the gap between what we condemn and what we tolerate.

Then there are the constraintsâ€”what Bitzer calls the beliefs, attitudes, and traditions that shape how a message must be delivered. Comedy imposes the most obvious one: the sketch must be funny. But this limitation becomes an advantage. Satire can say things a straightforward opinion piece cannot. Imagine if an editorial argued that "men who date much younger women are essentially waiting for children to grow up." You can already hear the dismissals: hyperbolic, preachy, puritanical. But when SNL dramatizes this exact scenario, the absurdist premise creates just enough distance that we can laugh our way into acknowledging what we'd otherwise reject. The comedy provides plausible deniability. We're not laughing at ourselvesâ€”we're laughing at the joke.

Except, of course, we are laughing at ourselves, and the sketch knows it. This is where it navigates another constraint: cultural relativism, the deeply held progressive belief that consenting adults should date whomever they want without judgment. SNL's audience would recoil from any sketch that explicitly moralizes or demands prohibition. So the sketch doesn't argue; it simply invites discomfort and trusts us to sit with it. There's no narrator explaining why this is wrong, no policy recommendation at the end. Just three middle-aged professionals meeting their kindergarten-aged future wives, an ultrasound image on a screen, and the audience's nervous laughter that says: we get it, and we're implicated.

The gameshow format itself does rhetorical work. Gameshows traffic in commodificationâ€”prizes to be won, contestants performing enthusiasm, romantic partners presented like products on a showroom floor. By placing its critique within this structure, the sketch taps into associations we already have about what gameshows represent. The format isn't just a convenient vehicle for the joke; it reinforces the sketch's unstated argument about what happens when we treat younger women as status symbols rather than people. Everything is for sale, everything is a transaction, and the only thing that matters is whether you can afford the upgrade.

The sketch also navigates the risk of backlash. Satire that critiques normalized behavior always risks alienating the people who engage in it. By showing literal children rather than young adults, the sketch gives itself plausible deniabilityâ€”a thirty-five-year-old dating a fifty-year-old can watch and think, "Well, I'm not a child, so this doesn't apply to me." But the seed has been planted. The sketch establishes that timing is what separates "normal" from "creepy," then invites us to wonder where, exactly, that line should fall.

The contestants' reactions matter here. The men aren't predators; they're just as horrified as we are when they meet their "future wives." One of the men protests: "She's in elementary school!" No one is the villain, which is precisely the point. The sketch's real target isn't individual men but the culture that graduallyâ€”imperceptiblyâ€”transforms the unthinkable into the unremarkable. We're all complicit, it suggests, in the slow erosion of boundaries we'd swear we'd never cross.

This is what Bitzer means by "the fitting response"â€”rhetoric that addresses an exigence in a way that matches both audience and constraints. "Meet Your Second Wife" couldn't be a lecture; its audience would tune out. It couldn't be a policy proposal; the problem doesn't live in the legal realm. Instead, it creates what Bitzer calls a "rhetorical audience"â€”people who didn't know they were part of the situation until the sketch made them aware. Before watching, you might have scrolled past celebrity age gaps without a second thought. After, you can't unsee the pattern. The sketch doesn't change your behavior; it changes what you notice, which is often how cultural shifts begin.

But we should be honest about what satire can and cannot do. Bitzer argues that rhetoric modifies exigences, but can four minutes of comedy actually change dating behavior? The sketch might make us uncomfortable, but discomfort has a short half-life. Someone can laugh, recognize the critique, and then continue swiping through dating apps where age preferences implicitly endorse the very patterns the sketch mocks. Awareness doesn't guarantee action. Recognition doesn't require reckoning.

And there's another problem, the one I raised at the beginning: Does turning age-gap relationships into entertainment ultimately reinforce them rather than challenging them? When we share the sketch on social media with crying-laughing emojis, are we engaging in cultural criticism or just enjoying the spectacle? The sketch positions itself as confrontational, but comedy always offers an escape valve. We can laugh without having to actually do anything about what we're laughing at. This might be why the sketch has been shared millions of timesâ€”it allows us to feel morally enlightened while remaining comfortably passive.

Still, I think the sketch succeeds in a way that matters. It's given people language. When celebrities with significant age gaps make headlines now, you'll see "Meet Your Second Wife" referenced in the Twitter repliesâ€”shorthand for a discomfort that didn't have a name before. The sketch doesn't solve the problem, but it makes the invisible visible, which is often where change begins. It asks a question we'd rather not answer: at what point does an age gap stop being a neutral preference and start being something that should make us queasy? The fact that the question now exists in the cultural conversation, even if we're still avoiding the answer, suggests the sketch understood its rhetorical situation better than we might want to admit.

After all, rhetoric that makes us uncomfortable rarely feels like it's working. It's supposed to make us want to dismiss it, to find reasons why it doesn't apply, to laugh and move on. The measure of its success isn't whether it changes us immediately, but whether it plants something that grows. Whether we keep coming back to it, sharing it, using it to explain a feeling we couldn't quite articulate before. Whether, when we see that forty-five-year-old actor with his twenty-two-year-old girlfriend, we pause just long enough to remember a five-year-old holding up her fingers, and wonder when, exactly, we decided this was fine.`
                },
                {
                    version: "Draft 2",
                    text: `Tina Fey and Amy Poehler stand behind a podium bathed in gameshow lighting, introducing three middle-aged contestantsâ€”a professor, a software engineer, a financial analystâ€”to "America's favorite new show." The audience knows what's coming. The men don't. When the first contestant meets his future second wife, she's five years old, holding up her fingers to show her age. The laughter in the studio shifts register, nervous and strangled. By the time we reach the ultrasoundâ€”one contestant's future wife hasn't even been born yetâ€”the discomfort is palpable. This is Saturday Night Live's "Meet Your Second Wife," a sketch that has lived online ever since, resurfacing whenever a celebrity with a much younger partner makes headlines. The premise weaponizes a simple temporal shift: show us today what we'll accept tomorrow, and suddenly what seemed normal reveals itself as grotesque.

But here's the problem comedy creates when it takes on social critique: Does making us laugh at age-gap relationships actually challenge them, or does humor just turn serious issues into entertainment? We might share this sketch on social media with crying-laughing emojis, pat ourselves on the back for being culturally aware, and then continue scrolling past the same patterns we just finished mocking. Comedy offers an escape valveâ€”we can laugh at a problem without ever having to confront our complicity in it.

Yet I'd argue that "Meet Your Second Wife" succeeds precisely because it refuses to let us off the hook. Unlike satire that allows the audience to feel morally superior while laughing at someone else's behavior, this piece implicates the viewer. It doesn't mock men who date younger women; it mocks *all of us* who've normalized these relationships through our consumption and repetition of cultural scripts that treat them as unremarkable. The sketch's rhetorical power comes from strategic discomfortâ€”it denies us the distance we'd need to laugh guilt-free, and in doing so, it accomplishes what straightforward criticism never could.

To understand how this works, it helps to look at Lloyd Bitzer's 1968 essay "The Rhetorical Situation." Bitzer argues that effective rhetoric emerges in response to specific situationsâ€”not just any circumstance, but ones where discourse can actually make a difference. A rhetorical situation, in his framework, requires three elements: an *exigence* (a problem that discourse can help solve), an *audience* (people capable of being influenced to create change), and *constraints* (factors that shape how the message must be delivered, including beliefs, attitudes, and traditions). Think of it this way: a rainstorm is just a situation, but a drought that requires public conservation efforts is rhetoricalâ€”it's a problem where the right words, addressed to the right people, in the right way, might actually change behavior.

What makes SNL's sketch rhetorically sophisticated is how it assembles these three elements to transform discomfort into critique. Each component of Bitzer's framework reveals something about why this particular piece of comedy succeeds where other attempts to address age-gap relationships have failed.

The exigenceâ€”the problem requiring public attentionâ€”is both obvious and invisible. We all know, in that abstract, unconsidered way we "know" many things, that middle-aged men often date women young enough to be their daughters. Celebrity culture celebrates it. Leonardo DiCaprio, famously, has never publicly dated a woman over twenty-five, a pattern so consistent it's become a meme. The actor Jason Statham started dating his current partner when he was forty-three and she was twenty-two. We've seen these relationships joked about in sitcoms, naturalized through repetition until they register as just another fact of contemporary life. A fifty-year-old actor with a twenty-eight-year-old girlfriend occasions at most a raised eyebrow, often accompanied by a winking comment about him "still having it."

SNL's satire refuses to accept this normalization. The sketch's brilliance lies in its refusal to moralize or explain. It simply asks: what's the moral difference between that relationship and the one we're watching, other than timing? When the professor on stage recoils in horrorâ€”"She's in elementary school!" he protestsâ€”we recognize his disgust as appropriate. If we find the five-year-old holding up her fingers unconscionable, if the ultrasound makes us deeply uncomfortable, what does it mean that we'll find the same relationship unremarkable twenty or thirty years later?

This is what Bitzer would call making the exigence visible. The problem isn't illegalâ€”laws already prohibit relationships with minorsâ€”but it exists in that murky zone where what's permissible and what's ethical don't quite align. No social mechanism challenges the appropriateness of these age gaps between consenting adults; the issue lives in the realm of cultural attitudes rather than policy. And cultural attitudes, Bitzer argues, are precisely what rhetoric can modify. By collapsing the temporal distance between "unconscionable" and "unremarkable," the satire forces viewers to confront discomfort they've been trained to ignore.

Consider what an *unfitting* response to this exigence would look like. A scholarly article in an academic journal about power dynamics in age-gap relationships might be intellectually rigorous, but it would reach only people already inclined to think critically about the issueâ€”it wouldn't create new awareness. A straightforward editorial arguing "men who date much younger women are essentially waiting for children to grow up" would be dismissed as hyperbolic and preachy; you can already hear the rebuttals about consenting adults and personal freedom. A documentary interviewing couples with large age gaps might humanize them in ways that accidentally normalize the very pattern it means to question. None of these would work because they're too serious, too direct, or too easily dismissed.

The gameshow format, by contrast, is the perfect vehicle. It's absurd enough to provide plausible deniabilityâ€”we're not really critiquing *your* relationship, just this ridiculous hypotheticalâ€”while being visceral enough to bypass intellectual defenses. The discomfort lands before we can rationalize it away.

This brings us to Bitzer's second element: audience. Who, exactly, is meant to see this, and what power do they have to create change? Bitzer calls them "mediators of change"â€”people with the capacity to shift the cultural ground beneath a problem. SNL's audience trends educated, politically engaged, predominantly under fifty. Many of them participate in the very dating culture this piece indicts, or at least swim in its waters. They've swiped past age preferences on dating apps, laughed at sitcom jokes about "trading up," scrolled through celebrity gossip that treats a forty-five-year-old actor's twenty-three-year-old girlfriend as aspirational rather than alarming.

The satire doesn't target individual men who date younger women; it targets all of us who've normalized the behavior through our consumption and repetition of cultural scripts. And here's where the sketch does something rhetorically sophisticated: it builds on common ground. Bitzer argues that effective rhetoric must start with beliefs the audience already holds. We find relationships between adults and children unconscionableâ€”this is bedrock, the foundation the sketch builds on. What "Meet Your Second Wife" does is draw a line connecting that uncontroversial disapproval to something we've been perfectly comfortable ignoring.

The temporal trick makes the connection visceral rather than intellectual. We don't need to be convinced that showing a man his five-year-old future wife represents a boundary violation; we already know it. The ultrasound pushes the point even furtherâ€”we're watching a man meet someone who doesn't exist yet, and the absurdity forces us to ask why the same age gap, decades later, will barely register. This piece plants cognitive dissonance where none existed before, then trusts us to feel uncomfortable about the gap between what we condemn and what we tolerate. That discomfort is the engine of cultural change.

The third element of Bitzer's frameworkâ€”constraintsâ€”reveals how this satire transforms apparent limitations into rhetorical advantages. Constraints are the beliefs, attitudes, and traditions that shape how a message must be delivered. Comedy imposes the most obvious one: it must be funny. But this limitation becomes a strength. Satire can say things that straightforward opinion pieces cannot. The absurdist premise creates just enough distance that we can laugh our way into acknowledging what we'd otherwise reject. The comedy provides plausible deniability. We're not laughing at ourselvesâ€”or so we tell ourselves at first.

Another constraint: cultural relativism, the deeply held progressive belief that consenting adults should date whomever they want without judgment. SNL's audience would recoil from any sketch that explicitly moralizes or demands prohibition. So the satire doesn't argue; it simply invites discomfort and trusts us to sit with it. There's no narrator explaining why this is wrong, no policy recommendation at the end. When one of the contestants protests in horror, we hear his objection as justifiedâ€”but the sketch never tells us what to think. It just presents the scenario and lets us draw our own uncomfortable conclusions. Just three middle-aged professionals meeting their kindergarten-aged future wives, an ultrasound image on a screen, and the audience's nervous laughter that says: we get it, and we're implicated.

The gameshow format itself does rhetorical work. Gameshows traffic in commodificationâ€”prizes to be won, contestants performing enthusiasm, romantic partners presented like products on a showroom floor. By placing its critique within this structure, the piece taps into associations we already have about what gameshows represent. The format isn't just a convenient vehicle for the joke; it reinforces the unstated argument about what happens when we treat younger women as status symbols rather than people. Everything is for sale, everything is a transaction, and the only thing that matters is whether you can afford the upgrade.

This satirical approach also navigates the risk of backlash. Material that critiques normalized behavior always risks alienating the people who engage in it. By showing literal children rather than young adults, SNL's piece gives itself plausible deniabilityâ€”a thirty-five-year-old dating a fifty-year-old can watch and think, "Well, I'm not a child, so this doesn't apply to me." But the seed has been planted. The satire establishes that timing is what separates "normal" from "creepy," then invites us to wonder where, exactly, that line should fall.

The contestants' reactions matter here. The men aren't predators; they're just as horrified as we are when they meet their "future wives." No one is the villain, which is precisely the point. The real target isn't individual men but the culture that graduallyâ€”imperceptiblyâ€”transforms the unthinkable into the unremarkable. We're all complicit, it suggests, in the slow erosion of boundaries we'd swear we'd never cross.

This is what Bitzer means by "the fitting response"â€”rhetoric that addresses an exigence in a way that matches both audience and constraints. "Meet Your Second Wife" couldn't be a lecture; its audience would tune out. It couldn't be a policy proposal; the problem doesn't live in the legal realm. Instead, it creates what Bitzer calls a "rhetorical audience"â€”people who didn't know they were part of the situation until the discourse made them aware. Before watching, you might have scrolled past celebrity age gaps without a second thought. After, you can't unsee the pattern. This piece doesn't change your behavior directly; it changes what you notice, which is often where cultural shifts begin.

But we should be honest about what satire can and cannot do. Earlier, I acknowledged the risk: comedy might trivialize serious issues by turning them into entertainment. And it's true that Bitzer argues rhetoric modifies exigencesâ€”but can four minutes of comedy actually change dating behavior? The sketch might make us uncomfortable, but discomfort has a short half-life. Someone can laugh, recognize the critique, and then continue swiping through dating apps where age preferences implicitly endorse the very patterns this piece mocks. Awareness doesn't guarantee action; recognition doesn't require reckoning.

Yet I think the satire succeeds in a way that matters. It's given people language. When celebrities with significant age gaps make headlines now, you'll see "Meet Your Second Wife" referenced in Twitter repliesâ€”shorthand for a discomfort that didn't have a name before. SNL's piece doesn't solve the problem, but it makes the invisible visible, which is often where change begins. It asks a question we'd rather not answer: at what point does an age gap stop being a neutral preference and start being something that should make us queasy?

The fact that the question now exists in the cultural conversationâ€”even if we're still avoiding the answerâ€”suggests this satire understood its rhetorical situation better than we might want to admit. Most comedy about social issues lets us feel morally superior to the people being mocked. This piece denies us that comfort. It shows us that we're already participating in what we claim to oppose, simply by treating certain relationships as unremarkable background noise in celebrity culture. That's not entertainment masquerading as critique; that's rhetoric doing exactly what Bitzer says it shouldâ€”changing not just what we believe, but what we're able to see.

After all, rhetoric that makes us uncomfortable rarely feels like it's working. It's supposed to make us want to dismiss it, to find reasons why it doesn't apply, to laugh and move on. The measure of its success isn't whether it changes us immediately, but whether it plants something that growsâ€”whether we keep coming back to it, sharing it, using it to explain a feeling we couldn't quite articulate before. Whether, when we see that forty-five-year-old actor with his twenty-two-year-old girlfriend, we pause just long enough to remember a five-year-old holding up her fingers, and wonder when, exactly, we decided this was fine.`
                },
                {
                    version: "Draft 3",
                    text: `Tina Fey and Amy Poehler stand behind a podium bathed in gameshow lighting, introducing three middle-aged contestantsâ€”a professor, a software engineer, a financial analystâ€”to "America's favorite new show." The audience knows what's coming. The men don't. When the first contestant meets his future second wife, she's five years old, holding up her fingers to show her age. The laughter in the studio shifts register, nervous and strangled. By the time we reach the ultrasoundâ€”one contestant's future wife hasn't even been born yetâ€”the discomfort is palpable. This is Saturday Night Live's "Meet Your Second Wife," a sketch that has lived online ever since, resurfacing whenever a celebrity with a much younger partner makes headlines. The premise weaponizes a simple temporal shift: show us today what we'll accept tomorrow, and suddenly what seemed normal reveals itself as grotesque.

But here's the problem comedy creates when it takes on social critique: Does making us laugh at age-gap relationships actually challenge them, or does humor just turn serious issues into entertainment? We might share this sketch on social media with crying-laughing emojis, pat ourselves on the back for being culturally aware, and then continue scrolling past the same patterns we just finished mocking. Comedy offers an escape valve. We can laugh at a problem without ever having to confront our complicity in it.

Yet I'd argue that "Meet Your Second Wife" succeeds precisely because it refuses to let us off the hook. Unlike satire that allows the audience to feel morally superior while laughing at someone else's behavior, this piece implicates the viewer. It doesn't mock men who date younger women; it mocks all of us who've normalized these relationships through our consumption and repetition of cultural scripts that treat them as unremarkable. The sketch's rhetorical power comes from strategic discomfort. It denies us the distance we'd need to laugh guilt-free, and in doing so, it accomplishes what straightforward criticism never could.

To understand how this works, it helps to look at Lloyd Bitzer's 1968 essay "The Rhetorical Situation." Bitzer argues that effective rhetoric emerges in response to specific situationsâ€”not just any circumstance, but ones where discourse can actually make a difference. A rhetorical situation, in his framework, requires three elements: an exigence (a problem that discourse can help solve), an audience (people capable of being influenced to create change), and constraints (factors that shape how the message must be delivered, including beliefs, attitudes, and traditions). Think of it this way: a rainstorm is just a situation, but a drought that requires public conservation efforts is rhetorical. It's a problem where the right words, addressed to the right people, in the right way, might actually change behavior.

What makes SNL's sketch rhetorically sophisticated is how it assembles these three elements to transform discomfort into critique. Each component of Bitzer's framework reveals something about why this particular piece of comedy succeeds where other attempts to address age-gap relationships have failed.

The exigenceâ€”the problem requiring public attentionâ€”is both obvious and invisible. We all know, in that abstract, unconsidered way we "know" many things, that middle-aged men often date women young enough to be their daughters. Celebrity culture celebrates it. Leonardo DiCaprio, famously, has never publicly dated a woman over twenty-five, a pattern so consistent it's become a meme. The actor Jason Statham started dating his current partner when he was forty-three and she was twenty-two. We've seen these relationships joked about in sitcoms, naturalized through repetition until they register as just another fact of contemporary life. A fifty-year-old actor with a twenty-eight-year-old girlfriend occasions at most a raised eyebrow, often accompanied by a winking comment about him "still having it."

SNL's satire refuses to accept this normalization. It simply asks: what's the moral difference between that relationship and the one we're watching, other than timing? When the professor on stage recoils in horrorâ€”"She's in elementary school!" he protestsâ€”we recognize his disgust as appropriate. If we find the five-year-old holding up her fingers unconscionable, if the ultrasound makes us deeply uncomfortable, what does it mean that we'll find the same relationship unremarkable twenty or thirty years later?

This is what Bitzer would call making the exigence visible. The problem isn't illegalâ€”laws already prohibit relationships with minorsâ€”but it exists in that murky zone where what's permissible and what's ethical don't quite align. No social mechanism challenges the appropriateness of these age gaps between consenting adults; the issue lives in the realm of cultural attitudes rather than policy. And cultural attitudes, Bitzer argues, are precisely what rhetoric can modify.

By collapsing the temporal distance between "unconscionable" and "unremarkable," the satire forces viewers to confront discomfort they've been trained to ignore. Consider what an unfitting response (a response that doesn't match the situation's demands) to this exigence would look like. A scholarly article in an academic journal about power dynamics in age-gap relationships might be intellectually rigorous, but it would reach only people already inclined to think critically about the issue. It wouldn't create new awareness. A straightforward editorial arguing "men who date much younger women are essentially waiting for children to grow up" would be dismissed as hyperbolic and preachy. A documentary interviewing couples with large age gaps might humanize them in ways that accidentally normalize the very pattern it means to question.

None of these would work because they're too serious, too direct, or too easily dismissed. The gameshow format, by contrast, is the perfect vehicle. It's absurd enough to provide plausible deniabilityâ€”we're not really critiquing your relationship, just this ridiculous hypotheticalâ€”while being visceral enough to bypass intellectual defenses. The discomfort lands before we can rationalize it away.

This brings us to Bitzer's second element: audience. Who, exactly, is meant to see this, and what power do they have to create change? Bitzer calls them "mediators of change" (people with the capacity to shift the cultural ground beneath a problem). SNL's audience trends educated, politically engaged, predominantly under fifty. Many of them participate in the very dating culture this piece indicts, or at least swim in its waters. They've swiped past age preferences on dating apps, laughed at sitcom jokes about "trading up," scrolled through celebrity gossip that treats a forty-five-year-old actor's twenty-three-year-old girlfriend as aspirational rather than alarming.

The satire doesn't target individual men who date younger women; it targets all of us who've normalized the behavior through our consumption and repetition of cultural scripts. And here's where the sketch does something rhetorically sophisticated: it builds on common ground. Bitzer argues that effective rhetoric must start with beliefs the audience already holds. We find relationships between adults and children unconscionable. This is bedrock, the foundation the sketch builds on. What "Meet Your Second Wife" does is draw a line connecting that uncontroversial disapproval to something we've been perfectly comfortable ignoring.

The temporal trick makes the connection visceral rather than intellectual. We don't need to be convinced that showing a man his five-year-old future wife represents a boundary violation; we already know it. The ultrasound pushes the point even further. We're watching a man meet someone who doesn't exist yet, and the absurdity forces us to ask why the same age gap, decades later, will barely register. This piece plants cognitive dissonance where none existed before, then trusts us to feel uncomfortable about the gap between what we condemn and what we tolerate. That discomfort is the engine of cultural change.

The third element of Bitzer's frameworkâ€”constraintsâ€”reveals how this satire transforms apparent limitations into rhetorical advantages. Constraints are the beliefs, attitudes, and traditions that shape how a message must be delivered. Comedy imposes the most obvious one: it must be funny. But this limitation becomes a strength. Satire can say things that straightforward opinion pieces cannot. The absurdist premise creates just enough distance that we can laugh our way into acknowledging what we'd otherwise reject. The comedy provides plausible deniability.

Another constraint: cultural relativism, the deeply held progressive belief that consenting adults should date whomever they want without judgment. SNL's audience would recoil from any sketch that explicitly moralizes or demands prohibition. So the satire doesn't argue; it simply invites discomfort and trusts us to sit with it. There's no narrator explaining why this is wrong, no policy recommendation at the end. When one of the contestants protests in horror, we hear his objection as justified, but the sketch never tells us what to think. It just presents the scenario and lets us draw our own uncomfortable conclusions.

The gameshow format itself does rhetorical work. Gameshows traffic in commodificationâ€”prizes to be won, contestants performing enthusiasm, romantic partners presented like products on a showroom floor. By placing its critique within this structure, the piece taps into associations we already have about what gameshows represent. The format isn't just a convenient vehicle for the joke; it reinforces the unstated argument about what happens when we treat younger women as status symbols rather than people.

This satirical approach also navigates the risk of backlash while creating plausible deniability for viewers who might otherwise feel attacked. By showing literal children rather than young adults, SNL's piece gives itself cover, and a thirty-five-year-old dating a fifty-year-old can watch and think, "Well, I'm not a child, so this doesn't apply to me." But the seed has been planted. The satire establishes that timing is what separates "normal" from "creepy," then invites us to wonder where, exactly, that line should fall. The contestants aren't predators; they're just as horrified as we are when they meet their "future wives." No one is the villain, which is precisely the point. The real target isn't individual men but the culture that gradually transforms the unthinkable into the unremarkable.

This is what Bitzer means by "the fitting response" (rhetoric that addresses an exigence in a way that matches both audience and constraints). "Meet Your Second Wife" couldn't be a lecture; its audience would tune out. It couldn't be a policy proposal; the problem doesn't live in the legal realm. Instead, it creates what Bitzer calls a "rhetorical audience" (people who didn't know they were part of the situation until the discourse made them aware). Before watching, you might have scrolled past celebrity age gaps without a second thought. After, you can't unsee the pattern. This piece doesn't change your behavior directly; it changes what you notice, which is often where cultural shifts begin.

But we should be honest about what satire can and cannot do. Earlier, I acknowledged the risk: comedy might trivialize serious issues by turning them into entertainment. And it's true that Bitzer argues rhetoric modifies exigences, but can four minutes of comedy actually change dating behavior?

Consider what's happened since this sketch went viral. In December 2021, when Leonardo DiCaprio (then 47) was photographed with his girlfriend Camila Morrone (then 24), Twitter exploded with "Meet Your Second Wife" references. The comparisons were everywhere. News outlets ran pieces titled "The Internet Can't Stop Thinking About SNL's 'Meet Your Second Wife' Sketch." The sketch had given people a framework, a vocabulary, a way to articulate their discomfort. Thousands of tweets deployed the reference with knowing irony. We'd identified the problem. We were aware. We were calling it out.

And then, in August 2022, DiCaprio and Morrone broke upâ€”right before her twenty-fifth birthday. And by early 2023, DiCaprio was dating a 23-year-old model. The pattern continued exactly as before. All that awareness, all those viral tweets, all that cultural critique, and nothing material changed. The sketch had been shared millions of times. The reference had become shorthand for a particular kind of discomfort. But Leonardo DiCaprio is still Leonardo DiCaprio, and twenty-something models are still considered age-appropriate partners for men in their fifties.

What does this mean for the sketch's rhetorical effectiveness? Has it actually accomplished anything, or has it just given us a clever way to signal our disapproval while accepting the behavior we claim to oppose? This is the uncomfortable question that Bitzer's framework can't quite answer. His theory assumes that making an exigence visible to the right audience, in the right way, leads to change. But what happens when the audience recognizes the exigence, agrees that it's a problem, shares the critique widely, and then... does nothing? When awareness becomes a substitute for action rather than a catalyst for it?

You could argue that viral awareness is itself a form of changeâ€”that shifting what people notice and how they talk about something is the necessary first step. You could point out that cultural transformation is slow, that we won't see the effects for another generation. Maybe young people who've seen this sketch will date differently than their parents did. Maybe.

Or you could argue that comedy has always been the perfect vehicle for defusing discomfort rather than sustaining it. We laugh, we share, we perform awareness, and then the pressure releases. The sketch lets us feel morally superiorâ€”look how critically we're thinking about age gaps!â€”while remaining entirely passive. It's possible that the satire hasn't challenged the normalization of age-gap relationships so much as it's normalized talking about them in a way that requires no actual change.

I don't think I can resolve this tension, and I'm not sure I should try. What I can say is that "Meet Your Second Wife" succeeds in ways that matter, even if those ways are more limited than we might hope. It has given people language. When celebrities with significant age gaps make headlines now, the sketch is referenced in the repliesâ€”shorthand for a discomfort that didn't have a name before. SNL's piece doesn't solve the problem, but it makes the invisible visible, which is often where change begins. It asks a question we'd rather not answer: at what point does an age gap stop being a neutral preference and start being something that should make us queasy?

The fact that the question now exists in the cultural conversation suggests this satire understood its rhetorical situation better than we might want to admit. Most comedy about social issues lets us feel morally superior to the people being mocked. This piece denies us that comfort. It shows us that we're already participating in what we claim to oppose, simply by treating certain relationships as unremarkable background noise in celebrity culture.

That seems worth something. Maybe the problem with satire isn't that it fails to change things, but that we expect it to do the work we're unwilling to do ourselves. The sketch can make the pattern visible; it can make us uncomfortable; it can give us vocabulary and framework. But it can't make us act. That's on us. And maybe that's the real insight here: rhetoric that makes us uncomfortable isn't supposed to feel satisfying. It's supposed to make us want to dismiss it, to find reasons why it doesn't apply, to laugh and move on. The measure of its success isn't whether it changes us immediately. It's whether, when we see that forty-five-year-old actor with his twenty-two-year-old girlfriend, we pause just long enough to remember a five-year-old holding up her fingers, and to wonder when, exactly, we decided this was fineâ€”and what, if anything, we're going to do about it.`
                }
            ]
        },
        annotations: {},
        feedback: {
            "When Did We Decide This Was Fine?|Draft 1": {
                items: [
                    {
                        id: "sample-feedback-1",
                        source: "instructor",
                        sourceName: "Prof. Anderson",
                        date: "2025-01-05",
                        content: "<p><strong>Excellent application of Bitzer's framework!</strong> You clearly understand exigence, audience, and constraints, and you've chosen a genuinely interesting text to analyze. Your point that the sketch 'creates a rhetorical audience' by making people aware of an issue they didn't know required their attention is sophisticated and well-developed.</p><p>However, I'd like to see you <strong>complicate your claim about the sketch's effectiveness</strong>. You acknowledge limitations near the end (\"preaching to the choir\"), but this feels tacked on. Consider integrating counterarguments earlier. For instance, could the sketch actually <em>reinforce</em> the problem by turning it into entertainment? Does making people laugh at age-gap relationships trivialize the issue rather than encouraging serious reflection?</p><p>Also, your discussion of 'constraints' is thorough, but you could push further on <strong>how the sketch transforms constraints into rhetorical advantages</strong>. You mention that comedy allows the sketch to 'say things that a straightforward editorial cannot,' but unpack this more. What specifically can satire do that argument cannot? Use concrete examples from the sketch to illustrate.</p><p>Finally, define 'exigence' and 'constraints' more explicitly when you first introduce themâ€”not all readers will be familiar with Bitzer's technical vocabulary.</p>",
                        tags: ["thesis", "argument", "Bitzer", "counterargument"],
                        attachments: [],
                        understood: true,
                        understandingExplanation: "Prof. Anderson wants me to integrate counterarguments earlier rather than saving them for the end. She questions whether satire might actually trivialize the issue rather than encouraging change. She also wants me to define Bitzer's key terms more clearly and expand on how the sketch turns constraints into rhetorical strengths.",
                        understandingActionPlan: "I'll add a counterargument paragraph earlier in the essay that questions whether comedy is the right mode for this critique. I'll define 'exigence' and 'constraints' in simpler language when I first introduce them. For the constraints section, I'll add specific examples of how the sketch uses its comedic format strategicallyâ€”like how exaggeration creates plausible deniability.",
                        understandingQuestions: "Should I ultimately refute the counterargument that satire trivializes the issue, or leave it as an open tension?",
                        scope: 75,
                        impact: 85
                    },
                    {
                        id: "sample-feedback-2",
                        source: "peer",
                        sourceName: "Jordan Kim",
                        date: "2025-01-07",
                        content: "<p>This was really interesting! I've seen this sketch before but never thought about it this deeply. Your analysis made me realize there's way more going on than just 'haha, creepy guys.'</p><p>One thing that confused me: you spend a lot of time explaining what Bitzer means by 'exigence,' 'audience,' and 'constraints,' but I'm still not 100% sure I understand what makes something a 'rhetorical situation' versus just... a situation? Like, when you say the sketch 'creates a rhetorical situation where one barely existed before,' what does that mean exactly? Maybe a concrete example would help.</p><p>Also, I got a little lost in your discussion of the 'fitting response.' You explain what Bitzer means by it, but then you just assert that the sketch 'fits its rhetorical situation perfectly' without really proving why. What would an <em>unfitting</em> response look like? If I understood the contrast, I'd get your point better.</p><p>Minor thing: you mention Leonardo DiCaprio's dating patterns as an example, but you never explain what those patterns are. I know what you're referring to because I've seen Twitter jokes about it, but not everyone will.</p>",
                        tags: ["clarity", "examples", "Bitzer", "audience"],
                        attachments: [],
                        understood: true,
                        understandingExplanation: "Jordan found the analysis interesting but wants clearer definitions of Bitzer's terms, especially through concrete examples. She doesn't understand what makes a situation 'rhetorical' versus ordinary, and wants me to explain what an unfitting response would look like as a contrast. She also notes I'm assuming readers know about DiCaprio's dating patterns.",
                        understandingActionPlan: "I'll add a simple example early on that illustrates the difference between a 'situation' and a 'rhetorical situation'â€”maybe something like how a rainstorm is just a situation, but a drought that needs public action is rhetorical. For 'fitting response,' I'll give a hypothetical example of what an unfitting response to this exigence would be (like a scholarly article no one reads). I'll also add one sentence explaining DiCaprio's pattern.",
                        understandingQuestions: "",
                        scope: 30,
                        impact: 70
                    },
                    {
                        id: "sample-feedback-3",
                        source: "writing-center",
                        sourceName: "Carlos Rivera",
                        date: "2025-01-08",
                        content: "<p>Strong analytical writing overall! Your integration of Bitzer's concepts is clear and well-organized. A few sentence-level observations:</p><ul><li><strong>Quotation integration:</strong> You use several quotes from the sketch (like Tom Hanks saying \"She's in elementary school!\") but you don't always set them up clearly. Add a brief introduction before each quote so readers know who's speaking and in what context.</li><li><strong>Repetition:</strong> You use the phrase \"the sketch\" 47 times throughout the essay. Vary your references: \"SNL's satire,\" \"this piece,\" \"the gameshow format,\" etc.</li><li><strong>Paragraph transitions:</strong> Several paragraphs start with \"This\" or \"The sketch\" without clearly connecting to what came before. For example, paragraph 8 starts with \"This brings us to Bitzer's third element: constraints.\" What is \"this\"? Add a bridge sentence referencing the previous discussion of audience.</li><li><strong>Comma splices:</strong> Watch for sentences like \"The sketch doesn't target men who date younger women specifically, rather it addresses the broader culture.\" Use a semicolon or split into two sentences.</li></ul><p>These are polish-level fixes that will help your sophisticated analysis read more smoothly.</p>",
                        tags: ["style", "clarity", "grammar", "transitions"],
                        attachments: [],
                        understood: true,
                        understandingExplanation: "Carlos identified sentence-level issues: I need to introduce quotations more clearly, vary my word choice (especially 'the sketch'), strengthen paragraph transitions by being more specific about what 'this' refers to, and fix comma splices.",
                        understandingActionPlan: "I'll do a search for 'the sketch' and replace at least half with varied alternatives. For each quote from the sketch, I'll add context about who's speaking. I'll check the start of each paragraph and make sure transitions explicitly reference the previous idea. I'll also search for comma splices and fix them with semicolons or periods.",
                        understandingQuestions: "",
                        scope: 20,
                        impact: 45
                    },
                    {
                        id: "sample-feedback-4",
                        source: "self",
                        sourceName: "",
                        date: "2025-01-09",
                        content: "<p>Reading this essay again after a few days, I realize I'm doing exactly what Prof. Anderson warned against: I'm so focused on <em>applying</em> Bitzer's framework that I forget to actually <em>argue</em> something. The essay basically says: \"Here's exigence, here's audience, here's constraints, and look, they all fit Bitzer's model perfectly!\" But where's my original insight?</p><p>What I actually want to argue is more specific: <strong>the sketch succeeds rhetorically precisely because it makes people uncomfortable rather than making them feel good.</strong> Most satire about social issues lets the audience feel morally superior, but this sketch implicates the viewer. Even if you've never dated someone way younger, you've probably laughed at jokes about it or consumed media that glamorizes it. The sketch doesn't let you off the hook.</p><p>But I barely develop this idea! It's mentioned once in the constraints section and then kind of dropped. If this is my actual thesis, I need to reorganize the entire essay around it.</p><p>I'm also worried the essay is too defensive. I spend a lot of time acknowledging limitations (\"the sketch may be preaching to the choir,\" \"discomfort doesn't necessarily translate to action\") without really committing to a clear position. Do I think the sketch is effective or not? I need to take a stand.</p>",
                        tags: ["thesis", "argument", "revision strategy"],
                        attachments: [],
                        goals: "Develop a clearer, more specific thesis about what makes this sketch rhetorically effectiveâ€”something beyond just 'it uses Bitzer's three elements well.'",
                        tryingToImprove: "My tendency to describe frameworks without making original arguments, and my habit of hedging instead of taking clear positions.",
                        understood: true,
                        understandingExplanation: "I've realized my essay applies Bitzer's framework without actually arguing anything original. My real insightâ€”that the sketch works because it implicates viewers rather than letting them feel superiorâ€”is underdeveloped. I also hedge too much instead of taking a clear stance on effectiveness.",
                        understandingActionPlan: "I'll revise my thesis to foreground the 'discomfort as rhetorical strategy' argument. Then I'll reorganize to make each Bitzer element support this specific claim rather than just cataloging them. I'll also decide whether I ultimately think the sketch succeeds or fails, and commit to that position while acknowledging complications.",
                        understandingQuestions: "",
                        scope: 85,
                        impact: 90
                    }
                ],
                synthesis: {
                    convergence: "Everyone agrees that I understand Bitzer's framework and apply it correctly, but I'm not doing enough with it. Prof. Anderson wants me to push beyond mere application toward original argument. Jordan wants clearer definitions and examples. I myself recognize that I'm describing the framework without making a real claim.\n\nInterestingly, multiple sources identify the same core problem from different angles: I need a stronger, more specific thesis. Prof. Anderson says I acknowledge limitations but don't integrate them into my argument. Jordan wants me to explain what an 'unfitting' response would look like (which would help clarify what makes this response fitting). My self-assessment realizes I'm hedging instead of committing. These all point to the same issue: I'm being too descriptive and not argumentative enough.",
                    divergence: "There's some tension between different readers' priorities. Prof. Anderson wants me to complicate my claims by integrating counterarguments earlier (does satire trivialize the issue?). Jordan, on the other hand, wants more clarity and simpler explanations of Bitzer's termsâ€”fewer complications, not more.\n\nBut I don't think these are actually opposed. I can define terms clearly AND raise complex questions. Explaining what makes something a 'rhetorical situation' doesn't prevent me from questioning whether comedy is the right rhetorical mode for this topic.\n\nThe writing center feedback is tactical (sentence-level: quotation integration, word variety, comma splices) while my self-reflection and instructor feedback are strategic (developing an original thesis about discomfort as rhetorical strategy). I should address the strategic issues firstâ€”there's no point polishing sentences in an essay that lacks a clear argument.",
                    priorities: [
                        {
                            id: generateUUID(),
                            text: "Revise thesis to foreground the 'discomfort as rhetorical strategy' argumentâ€”that the sketch succeeds because it implicates viewers rather than letting them feel superior. Make this the organizing principle of the entire essay.",
                            scope: "global",
                            impact: "high"
                        },
                        {
                            id: generateUUID(),
                            text: "Integrate the counterargument (does comedy trivialize serious issues?) earlier in the essay, ideally right after introducing Bitzer's framework. Then show how the sketch addresses this concern through strategic use of discomfort.",
                            scope: "global",
                            impact: "high"
                        },
                        {
                            id: generateUUID(),
                            text: "Add clear definitions of Bitzer's key terms ('exigence,' 'constraints,' 'rhetorical situation') using simple language and concrete examples. Include an example of what an 'unfitting' response to this exigence would look like.",
                            scope: "global",
                            impact: "high"
                        },
                        {
                            id: generateUUID(),
                            text: "Strengthen the 'constraints' section by adding specific examples of how the sketch transforms constraints into advantagesâ€”e.g., how exaggeration creates plausible deniability, how the gameshow format reinforces the objectification critique.",
                            scope: "local",
                            impact: "high"
                        },
                        {
                            id: generateUUID(),
                            text: "Vary word choice throughoutâ€”search for 'the sketch' and replace at least half with alternatives like 'SNL's satire,' 'this piece,' 'the gameshow format.' Also introduce all quotations with context about who's speaking.",
                            scope: "local",
                            impact: "high"
                        },
                        {
                            id: generateUUID(),
                            text: "Polish prose: strengthen paragraph transitions (especially those starting with vague 'This'), fix comma splices, and add one sentence explaining DiCaprio's dating pattern for readers unfamiliar with the reference.",
                            scope: "local",
                            impact: "low"
                        }
                    ]
                }
            },
            "When Did We Decide This Was Fine?|Draft 2": {
                items: [
                    {
                        id: "sample-feedback-d2-1",
                        source: "instructor",
                        sourceName: "Prof. Anderson",
                        date: "2025-01-12",
                        content: "<p><strong>Much stronger revision!</strong> You've addressed my main concerns from Draft 1 beautifully. Your thesis is now crystal clear: the sketch succeeds through 'strategic discomfort' that implicates viewers rather than allowing moral superiority. This argument organizes the entire essay, and I can see how each section of Bitzer's framework supports this specific claim. Well done.</p><p>The early integration of the counterargument (paragraph 2) is exactly what I was looking for. You raise the concern that comedy might trivialize serious issues, then spend the rest of the essay showing how this particular satire avoids that trap. This is sophisticated rhetorical analysis.</p><p>Your discussion of constraints has also improved significantly. I particularly like how you show the gameshow format doing 'rhetorical work' beyond just being a vehicle for the jokeâ€”connecting it to commodification and objectification. The examples of 'unfitting' responses (scholarly article, editorial, documentary) are brilliant; they help readers understand why comedy is the right mode here.</p><p>That said, I think you can push even further on one aspect: <strong>the limitations of satirical rhetoric</strong>. You acknowledge in paragraph 18 that 'discomfort has a short half-life' and 'awareness doesn't guarantee action,' which is good. But then you essentially dismiss these concerns in the next paragraph ('Yet I think the satire succeeds...'). I'd like to see you sit with this tension longer. What does it mean that this sketch has been shared millions of times but Leonardo DiCaprio is still dating 25-year-olds? Has the satire actually changed anything material, or has it just given people a clever reference to deploy in Twitter replies? You don't need to resolve thisâ€”productive ambiguity is fineâ€”but you should explore it more deeply.</p><p>Also, your new title is perfect. 'When Did We Decide This Was Fine?' captures the essay's central question and has real punch.</p>",
                        tags: ["thesis", "argument", "counterargument", "limitations"],
                        attachments: [],
                        understood: true,
                        understandingExplanation: "Prof. Anderson is pleased with how I addressed the major concerns from Draft 1â€”clearer thesis, early counterargument integration, better examples. But she wants me to explore the limitations more deeply and not dismiss them so quickly. She's asking whether the satire has actually changed behavior or just given people clever references.",
                        understandingActionPlan: "I'll expand the section on limitations (around paragraphs 18-20) and add more analysis of what it means that the problem persists despite viral awareness. I could bring in a concrete exampleâ€”like a recent celebrity age-gap relationship that got the 'Meet Your Second Wife' treatment on social media but proceeded anyway. I'll resist the urge to definitively resolve whether satire 'works,' and instead explore the productive tension between awareness and action.",
                        understandingQuestions: "",
                        scope: 40,
                        impact: 80
                    },
                    {
                        id: "sample-feedback-d2-2",
                        source: "peer",
                        sourceName: "Jordan Kim",
                        date: "2025-01-13",
                        content: "<p>This is SO much clearer than Draft 1! Thank you for adding the rainstorm vs. drought exampleâ€”I finally understand what makes a situation 'rhetorical.' And the examples of unfitting responses (scholarly article, preachy editorial, documentary) really helped me see why the gameshow format works.</p><p>I also appreciated that you explained the DiCaprio reference this time. That one sentence ('Leonardo DiCaprio, famously, has never publicly dated a woman over twenty-five, a pattern so consistent it's become a meme') was all I needed.</p><p>One thing I'm still confused about: You use a lot of specialized vocabulary from Bitzer's essayâ€”'exigence,' 'mediators of change,' 'fitting response,' 'rhetorical audience.' You define 'exigence' and 'constraints,' but not the other terms. I can figure them out from context, but I'm not 100% sure I'm getting them right. Maybe add brief parenthetical definitions when you first use them? Like 'mediators of change (people with power to shift cultural attitudes)' or something.</p><p>Also, this might just be me, but the essay feels pretty long now. Draft 1 was already substantial, and Draft 2 is even longer. Some of the paragraphs in the middle (especially around the 'constraints' section) feel like they're making similar points. For example, paragraphs 13 and 14 both talk about how the sketch navigates the risk of alienating people. Could these be combined?</p><p>But honestly, these are minor issues. The essay is way more convincing now that you've committed to a clear position.</p>",
                        tags: ["clarity", "jargon", "length", "organization"],
                        attachments: [],
                        understood: true,
                        understandingExplanation: "Jordan appreciates the improvements in clarity and examples from Draft 1, but notes that some of Bitzer's terminology still isn't defined. She also thinks the essay has gotten long and that some paragraphs in the constraints section are repetitive.",
                        understandingActionPlan: "I'll add brief parenthetical definitions for Bitzer's terms when they first appear ('mediators of change,' 'fitting response,' 'rhetorical audience'). I'll also look at the constraints section (paragraphs 12-15) to see if I can tighten or combine redundant points. Jordan specifically flagged paragraphs 13-14 about risk of backlash.",
                        understandingQuestions: "",
                        scope: 35,
                        impact: 60
                    },
                    {
                        id: "sample-feedback-d2-3",
                        source: "writing-center",
                        sourceName: "Carlos Rivera",
                        date: "2025-01-14",
                        content: "<p>Nice work addressing the sentence-level issues from Draft 1! I can see you've made a real effort to:</p><ul><li><strong>Vary word choice:</strong> You now use 'this piece,' 'SNL's satire,' 'the satire,' and 'SNL's piece' alongside 'the sketch.' Much better!</li><li><strong>Introduce quotations:</strong> The quote from the contestant now has context: 'When the professor on stage recoils in horrorâ€”\"She's in elementary school!\" he protests.' This is exactly what I was looking for.</li><li><strong>Strengthen transitions:</strong> Your paragraph transitions are clearer. For example, 'This brings us to Bitzer's second element: audience' explicitly references the framework you've been discussing.</li></ul><p>A few remaining issues:</p><ul><li><strong>Italics usage:</strong> You use italics for emphasis a lot ('all of us,' 'unfitting,' etc.), which can feel heavy-handed. Consider whether each instance really needs emphasis, or whether the sentence structure can do that work.</li><li><strong>Dash usage:</strong> You have a lot of em dashes throughout, which creates a certain rhythm. It works for the essayistic style, but there might be too many. Count them and see if you can replace some with other punctuation or sentence structures.</li><li><strong>Paragraph length:</strong> Paragraphs 6-7 (about the exigence) are quite long. Consider breaking paragraph 7 after 'By collapsing the temporal distance between \"unconscionable\" and \"unremarkable,\" the satire forces viewers to confront discomfort they've been trained to ignore.' That's a natural pause before you introduce the concept of an 'unfitting response.'</li><li><strong>One inconsistency:</strong> In paragraph 7, you write 'SNL's satire' but then in paragraph 8 you write 'the sketch's brilliance.' Pick one way to refer to it per paragraph.</li></ul><p>These are all polish-level concerns. The writing is strong and the style is engaging.</p>",
                        tags: ["style", "punctuation", "clarity", "consistency"],
                        attachments: [],
                        understood: true,
                        understandingExplanation: "Carlos acknowledges I fixed most of the Draft 1 sentence issues (word variety, quote integration, transitions). He's now pointing out polish issues: overuse of italics and em dashes, some paragraphs that could be broken up, and minor inconsistency in how I refer to the sketch.",
                        understandingActionPlan: "I'll do a pass specifically looking for italics and ask whether each one is necessary. I'll count em dashes and see if I'm overusing them. I'll consider breaking up the longer paragraphs, especially paragraph 7. I'll also make sure I'm consistent in referring to the sketch within each paragraph.",
                        understandingQuestions: "",
                        scope: 25,
                        impact: 40
                    },
                    {
                        id: "sample-feedback-d2-4",
                        source: "self",
                        sourceName: "",
                        date: "2025-01-15",
                        content: "<p>This revision addressed the major problems I identified in Draft 1. I have a clear, specific thesis now ('strategic discomfort' as what makes the sketch effective), and I've committed to a position instead of hedging. The essay finally makes an argument rather than just applying a framework.</p><p>But reading it again, I notice I've created a new problem: <strong>the essay is now too confident in its claims</strong>. In trying to avoid hedging, I've swung too far in the other direction. For example, I write things like 'the sketch's genius lies in...' and 'this is exactly what Bitzer means by...' and 'the satire succeeds in a way that matters.' These statements feel overly certain, especially given that Prof. Anderson rightly points out the sketch hasn't actually stopped Leonardo DiCaprio from dating 25-year-olds.</p><p>I think the problem is that I'm still thinking in terms of 'Does the sketch succeed or fail?' as a binary, when the more interesting question is: 'In what ways does it succeed, and what are the limits of that success?' The best essays hold multiple truths in tension.</p><p>I'm also realizing that my conclusion (the last two paragraphs) basically just restates my thesis without adding anything new. After spending 20+ paragraphs analyzing this sketch, what new insight should the conclusion offer? Right now it feels like I'm just landing the plane rather than pushing the thinking one step further.</p><p>Finally, I notice I'm still doing the thing where I imagine hypothetical readers ('You can already hear the rebuttals...' or 'Someone can laugh, recognize the critique, and then continue swiping through dating apps...'). I do this to anticipate counterarguments, which is good. But I wonder if it's too frequent. Does it make the essay feel argumentative in a productive way, or does it make me sound defensive?</p>",
                        tags: ["tone", "argument", "conclusion", "revision strategy"],
                        attachments: [],
                        goals: "Find the right balance between confidence and humilityâ€”making strong claims while acknowledging the complexity and limits of those claims.",
                        tryingToImprove: "My tendency to think in binaries rather than holding tensions. Also working on conclusions that do more than just restate the thesis.",
                        understood: true,
                        understandingExplanation: "I've successfully fixed the Draft 1 problem (unclear thesis, hedging), but now I've overcorrected into overconfidence. I need to find middle ground. My conclusion also just restates rather than pushing further. And I might be anticipating objections too frequently.",
                        understandingActionPlan: "I'll revise to modulate my certaintyâ€”keeping strong claims but acknowledging complexity. For the conclusion, I'll try to offer a new insight that emerges from the analysis rather than just summarizing. I'll also count how often I do the 'you can already hear' move and see if it's excessive.",
                        understandingQuestions: "What should a conclusion do beyond summarizing? How do I know when I've anticipated enough objections vs. too many?",
                        scope: 60,
                        impact: 75
                    }
                ],
                synthesis: {
                    convergence: "All readers agree that Draft 2 is a major improvement over Draft 1. The thesis is clear, the counterargument is integrated early, Bitzer's terms are better defined, and I've committed to a position. Prof. Anderson specifically praises how the essay is now organized around the 'strategic discomfort' argument, and Jordan says it's 'way more convincing.'\n\nInterestingly, there's consensus that I need to work on balance and restraint. Prof. Anderson wants me to sit longer with the limitations of satire instead of dismissing them. Jordan thinks some sections are repetitive and could be tightened. My self-assessment recognizes that I've overcorrected from hedging to overconfidence. Even Carlos notes stylistic overuse (italics, em dashes). Everyone is essentially saying: the substance is there, now refine and modulate.",
                    divergence: "Prof. Anderson wants me to expand the discussion of limitations and sit with ambiguity, while Jordan wants me to tighten and shorten repetitive sections. At first glance, these seem opposedâ€”one wants more, one wants less. But they're targeting different parts of the essay. Anderson wants depth on the 'does satire work?' question specifically. Jordan wants me to cut redundancy in the constraints section.\n\nThere's also a subtle tension between taking a strong position (which Prof. Anderson praised and Jordan found more convincing) and acknowledging limitations (which Anderson wants me to explore more deeply). My self-assessment captures this: I'm trying to find the right balance between confidence and humility.\n\nCarlos's feedback is again mostly tactical (italics, dashes, paragraph breaks) while the other sources focus on argument and structure. But this time the sentence-level issues might actually matter more because they affect toneâ€”overuse of italics and em dashes can make writing feel breathless or try-hard, which connects to my concern about sounding overconfident.",
                    priorities: [
                        {
                            id: generateUUID(),
                            text: "Expand and deepen the discussion of satire's limitations (paragraphs 18-20). Add a concrete recent example of a celebrity age-gap relationship that received 'Meet Your Second Wife' comparisons but continued anyway. Explore the tension between viral awareness and material change without trying to resolve it definitively.",
                            scope: "global",
                            impact: "high"
                        },
                        {
                            id: generateUUID(),
                            text: "Modulate tone throughout to balance confidence with acknowledgment of complexity. Look for overly certain phrases like 'the sketch's genius' or 'this is exactly what Bitzer means' and consider softer formulations that preserve the strong argument while admitting nuance.",
                            scope: "global",
                            impact: "high"
                        },
                        {
                            id: generateUUID(),
                            text: "Revise conclusion to offer new insight rather than just restating thesis. After analyzing how the sketch works, what broader observation can I make about satirical rhetoric, or about how cultural change happens through discomfort?",
                            scope: "global",
                            impact: "high"
                        },
                        {
                            id: generateUUID(),
                            text: "Review constraints section (paragraphs 12-15) for redundancy. Jordan specifically noted paragraphs 13-14 make similar points about risk of alienating people. See if these can be combined or if one can be cut.",
                            scope: "local",
                            impact: "high"
                        },
                        {
                            id: generateUUID(),
                            text: "Add brief parenthetical definitions for remaining Bitzer terms: 'mediators of change,' 'fitting response,' 'rhetorical audience.' These should be unobtrusive but helpful for readers unfamiliar with the terminology.",
                            scope: "local",
                            impact: "high"
                        },
                        {
                            id: generateUUID(),
                            text: "Polish prose: reduce overuse of italics and em dashes, break up longer paragraphs (especially paragraph 7), ensure consistent terminology within paragraphs. Evaluate whether I'm anticipating objections too frequently ('you can already hear...').",
                            scope: "local",
                            impact: "low"
                        }
                    ]
                }
            }
        },
        uploadedFiles: []
    };

    // Check if sample project already exists in saved projects
    const hasSampleProject = savedProjects.some(p => p.name === sampleProject.name);

    // Always include sample project at the beginning
    if (hasSampleProject) {
        // Update the existing sample project to ensure it has the latest version
        const sampleIndex = savedProjects.findIndex(p => p.name === sampleProject.name);
        savedProjects[sampleIndex] = sampleProject;
        return savedProjects;
    } else {
        // Add sample project at the beginning of the list
        return [sampleProject, ...savedProjects];
    }
}

function saveProject(projectName) {
    if (!projectName || projectName.trim() === '') {
        showError('Please enter a project name');
        return false;
    }

    // Prevent overwriting sample project
    if (projectName === "ðŸ“˜ Sample Project: Democracy & Technology") {
        showError('Cannot use this name - it is reserved for the sample project');
        return false;
    }

    if (!currentEssay) {
        showError('No drafts loaded to save');
        return false;
    }

    const projects = getProjects();
    // Filter out sample project when counting user projects
    const userProjects = projects.filter(p => p.name !== "ðŸ“˜ Sample Project: Democracy & Technology");

    // Check if project name already exists
    const existingIndex = userProjects.findIndex(p => p.name === projectName);

    const projectData = {
        name: projectName,
        savedDate: new Date().toISOString(),
        essay: currentEssay,
        annotations: annotations,
        feedback: draftFeedback,
        uploadedFiles: uploadedFiles.map(file => ({
            name: file.name,
            type: file.type,
            lastModified: file.lastModified
        }))
    };

    if (existingIndex >= 0) {
        // Update existing project
        userProjects[existingIndex] = projectData;
        showDataStatus(`Project "${projectName}" updated âœ“`);
    } else {
        // Add new project
        if (userProjects.length >= MAX_PROJECTS) {
            return false; // Will trigger manage projects modal
        }
        userProjects.push(projectData);
        showDataStatus(`Project "${projectName}" saved âœ“`);
    }

    // Only save user projects (not sample project) to localStorage
    localStorage.setItem('revisionToolProjects', JSON.stringify(userProjects));
    return true;
}

function loadProject(projectName) {
    const projects = getProjects();
    const project = projects.find(p => p.name === projectName);

    if (!project) {
        showError('Project not found');
        return;
    }

    // Load the project data
    currentEssay = project.essay;
    annotations = project.annotations || {};
    draftFeedback = project.feedback || {};

    // Recreate the comparison view
    const panelInfo = createPanels(currentEssay);
    totalPanels = panelInfo.length;
    currentPosition = 0;

    // Hide upload section and show results
    const uploadSection = document.querySelector('.upload-section');
    if (uploadSection) uploadSection.classList.add('hidden');

    const comparisonResults = document.getElementById('comparisonResults');
    comparisonResults.style.display = 'block';
    updateSliderPosition();
    updateNavigationInfo(panelInfo);
    setupNewComparisonButton();

    // Display annotations
    displayAnnotations();

    showDataStatus(`Project "${projectName}" loaded âœ“`);

    // Save to current state as well
    saveState();
}

function deleteProject(projectName) {
    // Prevent deletion of sample project
    if (projectName === "ðŸ“˜ Sample Project: Democracy & Technology") {
        showError('Cannot delete the sample project');
        return;
    }

    if (!confirm(`Delete project "${projectName}"? This cannot be undone.`)) {
        return;
    }

    const projects = getProjects();
    const filteredProjects = projects.filter(p => p.name !== projectName);

    // Only save non-sample projects to localStorage
    const savedProjects = filteredProjects.filter(p => p.name !== "ðŸ“˜ Sample Project: Democracy & Technology");
    localStorage.setItem('revisionToolProjects', JSON.stringify(savedProjects));
    showDataStatus(`Project "${projectName}" deleted`);

    // Refresh the projects list if modal is open
    refreshProjectsList();
    refreshManageProjectsList();
}

function showSaveProjectModal() {
    const projects = getProjects();

    // Count only user projects (excluding sample)
    const userProjectCount = projects.filter(p => p.name !== "ðŸ“˜ Sample Project: Democracy & Technology").length;

    // Check if limit reached
    if (userProjectCount >= MAX_PROJECTS) {
        showManageProjectsModal();
        return;
    }

    const modal = document.getElementById('saveProjectModal');
    modal.style.display = 'block';
    document.getElementById('projectNameInput').value = '';
    document.getElementById('projectNameInput').focus();
}

function showLoadProjectModal() {
    const modal = document.getElementById('loadProjectModal');
    modal.style.display = 'block';
    refreshProjectsList();
}

function showManageProjectsModal() {
    const modal = document.getElementById('manageProjectsModal');
    modal.style.display = 'block';
    refreshManageProjectsList();
}

function refreshProjectsList() {
    const projectsList = document.getElementById('projectsList');
    const projects = getProjects();

    if (projects.length === 0) {
        projectsList.innerHTML = '<div class="no-projects-message">No saved projects yet.</div>';
        return;
    }

    projectsList.innerHTML = projects.map(project => `
        <div class="project-item" data-project-name="${project.name}">
            <div class="project-item-info">
                <div class="project-item-name">${project.name}</div>
                <div class="project-item-date">Saved: ${new Date(project.savedDate).toLocaleString()}</div>
            </div>
            <div class="project-item-actions">
                <button class="project-load-btn" onclick="loadProjectFromList('${project.name.replace(/'/g, "\\'")}')">Load</button>
            </div>
        </div>
    `).join('');
}

function refreshManageProjectsList() {
    const projectsList = document.getElementById('manageProjectsList');
    const projectCountMessage = document.getElementById('projectCountMessage');
    const backToSaveBtn = document.getElementById('backToSaveFromManageBtn');
    const projects = getProjects();

    // Count only user projects (excluding sample)
    const userProjectCount = projects.filter(p => p.name !== "ðŸ“˜ Sample Project: Democracy & Technology").length;

    // Update count message
    if (projectCountMessage) {
        const remaining = MAX_PROJECTS - userProjectCount;
        if (userProjectCount >= MAX_PROJECTS) {
            projectCountMessage.innerHTML = `<span style="color: #dc3545;">âš ï¸ Maximum of ${MAX_PROJECTS} projects reached. Delete a project to save new ones.</span>`;
        } else {
            projectCountMessage.innerHTML = `You have ${userProjectCount} of ${MAX_PROJECTS} projects saved. ${remaining} slot${remaining !== 1 ? 's' : ''} remaining.`;
        }
    }

    // Show/hide "Save New Project" button based on whether we have space
    if (backToSaveBtn) {
        backToSaveBtn.style.display = userProjectCount < MAX_PROJECTS ? 'block' : 'none';
    }

    projectsList.innerHTML = projects.map(project => {
        const isSampleProject = project.name === "ðŸ“˜ Sample Project: Democracy & Technology";
        return `
        <div class="project-item" data-project-name="${project.name}">
            <div class="project-item-info">
                <div class="project-item-name">${project.name}${isSampleProject ? ' <span style="font-size: 0.8em; color: #7c4dff;">(read-only)</span>' : ''}</div>
                <div class="project-item-date">Saved: ${new Date(project.savedDate).toLocaleString()}</div>
            </div>
            <div class="project-item-actions">
                <button class="project-load-btn" onclick="downloadProjectAsBro('${project.name.replace(/'/g, "\\'")}')">Download</button>
                ${isSampleProject ? '' : `<button class="project-delete-btn" onclick="deleteProject('${project.name.replace(/'/g, "\\'")}')">Delete</button>`}
            </div>
        </div>
        `;
    }).join('');
}

function loadProjectFromList(projectName) {
    const modal = document.getElementById('loadProjectModal');
    modal.style.display = 'none';
    loadProject(projectName);
}

function attemptSaveProject() {
    const projectName = document.getElementById('projectNameInput').value.trim();
    const projects = getProjects();

    // Count only user projects (excluding sample)
    const userProjects = projects.filter(p => p.name !== "ðŸ“˜ Sample Project: Democracy & Technology");

    // Check if we're at the limit and it's a new project
    const existingProject = userProjects.find(p => p.name === projectName);
    if (!existingProject && userProjects.length >= MAX_PROJECTS) {
        document.getElementById('saveProjectModal').style.display = 'none';
        showManageProjectsModal();
        return;
    }

    const success = saveProject(projectName);
    if (success) {
        document.getElementById('saveProjectModal').style.display = 'none';
    }
}

// ===== .BRO FILE IMPORT/EXPORT FUNCTIONS =====

function downloadProjectAsBro(projectName) {
    const projects = getProjects();
    const project = projects.find(p => p.name === projectName);

    if (!project) {
        showError('Project not found');
        return;
    }

    // Create the .bro file data (JSON format)
    const broData = {
        version: "1.0",
        exportDate: new Date().toISOString(),
        projectName: project.name,
        projectData: project
    };

    // Convert to JSON string
    const jsonString = JSON.stringify(broData, null, 2);

    // Create a blob and download it
    const blob = new Blob([jsonString], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `${projectName}.bro`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);

    showDataStatus(`Project "${projectName}" downloaded as .bro file âœ“`);
}

function importBroFile(file) {
    if (!file) {
        showError('No file selected');
        return;
    }

    // Validate file extension
    if (!file.name.endsWith('.bro')) {
        showError('Invalid file type. Please select a .bro file.');
        return;
    }

    const reader = new FileReader();

    reader.onload = function(e) {
        try {
            const broData = JSON.parse(e.target.result);

            // Validate the .bro file structure
            if (!broData.version || !broData.projectData) {
                showError('Invalid .bro file format');
                return;
            }

            const projectData = broData.projectData;

            // Check if project already exists
            const projects = getProjects();
            const existingProject = projects.find(p => p.name === projectData.name);

            let confirmMessage = existingProject
                ? `A project named "${projectData.name}" already exists. Do you want to replace it?`
                : `Import project "${projectData.name}"?`;

            if (!confirm(confirmMessage)) {
                return;
            }

            // Update or add the project
            if (existingProject) {
                const index = projects.findIndex(p => p.name === projectData.name);
                projects[index] = {
                    ...projectData,
                    savedDate: new Date().toISOString() // Update the saved date
                };
            } else {
                // Check if we're at the limit
                if (projects.length >= MAX_PROJECTS) {
                    showError(`Cannot import. Maximum of ${MAX_PROJECTS} projects reached. Please delete a project first.`);
                    return;
                }
                projects.push({
                    ...projectData,
                    savedDate: new Date().toISOString()
                });
            }

            localStorage.setItem('revisionToolProjects', JSON.stringify(projects));
            showDataStatus(`Project "${projectData.name}" imported successfully âœ“`);

            // Refresh the manage projects list
            refreshManageProjectsList();

        } catch (error) {
            showError('Error reading .bro file: ' + error.message);
        }
    };

    reader.onerror = function() {
        showError('Error reading file');
    };

    reader.readAsText(file);
}

// ===== END .BRO FILE IMPORT/EXPORT FUNCTIONS =====

// ===== END PROJECT MANAGEMENT FUNCTIONS =====

function clearAllData() {
    if (confirm('Clear all saved data? This will remove your saved files, annotations, feedback, and session state.\n\nNote: Saved projects will NOT be deleted. Use the "Manage Projects" option to delete individual projects.')) {
        localStorage.removeItem('revisionToolState');
        localStorage.removeItem('revisionToolFiles');
        localStorage.removeItem('revisionAnnotations');
        localStorage.removeItem('revisionDraftFeedback');
        annotations = {};
        draftFeedback = {};
        savedState = null;
        showDataStatus('All data cleared âœ“');

        // Reload page
        setTimeout(() => {
            window.location.reload();
        }, 1500);
    }
}

// Generate unique ID for annotation based on essay, drafts, and text
function getAnnotationId(essayTitle, fromDraft, toDraft, text) {
    const cleanText = text.substring(0, 50).trim();
    return `${essayTitle}|${fromDraft}|${toDraft}|${cleanText}`;
}

// Show annotation popup
// Show annotation popup (REPLACE ENTIRE FUNCTION)
function showAnnotationPopup(element, annotationId, existingNote = '') {
    // Remove any existing popup
    const existingPopup = document.querySelector('.annotation-popup');
    if (existingPopup) {
        existingPopup.remove();
    }

    const popup = document.createElement('div');
    popup.className = 'annotation-popup';
    
    popup.innerHTML = `
        <h4>Add Annotation</h4>
        <textarea id="annotationText" placeholder="Why did you make this change? What were you trying to achieve?">${existingNote}</textarea>
        <div class="annotation-popup-buttons">
            <button class="annotation-save-btn" id="saveAnnotation">Save</button>
            <button class="annotation-cancel-btn" id="cancelAnnotation">Cancel</button>
            ${existingNote ? '<button class="annotation-delete-btn" id="deleteAnnotation">Delete</button>' : ''}
        </div>
    `;
    
    document.body.appendChild(popup);
    
    // Smart positioning - calculate after adding to DOM so we know popup dimensions
    const rect = element.getBoundingClientRect();
    const popupRect = popup.getBoundingClientRect();
    const viewportHeight = window.innerHeight;
    const viewportWidth = window.innerWidth;
    const scrollY = window.scrollY;
    const scrollX = window.scrollX;
    
    // Determine vertical position
    let top;
    const spaceBelow = viewportHeight - rect.bottom;
    const spaceAbove = rect.top;
    
    if (spaceBelow >= popupRect.height + 20) {
        // Enough space below - place it below the element
        top = rect.bottom + scrollY + 10;
    } else if (spaceAbove >= popupRect.height + 20) {
        // Not enough space below but enough above - place it above
        top = rect.top + scrollY - popupRect.height - 10;
    } else {
        // Not enough space either way - center it vertically in viewport
        top = scrollY + (viewportHeight - popupRect.height) / 2;
    }
    
    // Determine horizontal position
    let left = rect.left + scrollX;
    
    // Make sure popup doesn't go off right edge
    if (left + popupRect.width > viewportWidth + scrollX) {
        left = viewportWidth + scrollX - popupRect.width - 20;
    }
    
    // Make sure popup doesn't go off left edge
    if (left < scrollX + 20) {
        left = scrollX + 20;
    }
    
    popup.style.position = 'absolute';
    popup.style.left = `${left}px`;
    popup.style.top = `${top}px`;
    
    // Focus textarea
    const textarea = popup.querySelector('#annotationText');
    textarea.focus();
    
    // Save button
    document.getElementById('saveAnnotation').onclick = function() {
        const note = textarea.value.trim();
        if (note) {
            annotations[annotationId] = {
                note: note,
                text: element.textContent,
                timestamp: new Date().toISOString()
            };
            saveAnnotations();
            element.classList.add('has-annotation');
            popup.remove();
        }
    };
    
    // Cancel button
    document.getElementById('cancelAnnotation').onclick = function() {
        popup.remove();
    };
    
    // Delete button
    const deleteBtn = document.getElementById('deleteAnnotation');
    if (deleteBtn) {
        deleteBtn.onclick = function() {
            delete annotations[annotationId];
            saveAnnotations();
            element.classList.remove('has-annotation');
            popup.remove();
        };
    }
    
    // Close on click outside
    setTimeout(() => {
        document.addEventListener('click', function closePopup(e) {
            if (!popup.contains(e.target) && e.target !== element) {
                popup.remove();
                document.removeEventListener('click', closePopup);
            }
        });
    }, 100);
}

// Konami Code Easter Egg
(function() {
    const konamiCode = ['ArrowUp', 'ArrowUp', 'ArrowDown', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'ArrowLeft', 'ArrowRight'];
    let konamiIndex = 0;
    
    document.addEventListener('keydown', function(e) {
        // Check if the key matches the next key in the sequence
        if (e.key === konamiCode[konamiIndex]) {
            konamiIndex++;
            
            // If we've completed the sequence
            if (konamiIndex === konamiCode.length) {
                showAllQuotes();
                konamiIndex = 0; // Reset for next time
            }
        } else {
            // Wrong key, reset the sequence
            konamiIndex = 0;
        }
    });
    
    function showAllQuotes() {
        const modal = document.getElementById('quotesModal');
        const container = document.getElementById('quotesListContainer');
        
        // Build the quotes list
        let html = '';
        quotes.forEach((quote, index) => {
            html += `
                <div style="
                    background: ${index % 2 === 0 ? 'var(--secondary-color)' : 'var(--card-background)'};
                    padding: 20px;
                    margin-bottom: 15px;
                    border-radius: 8px;
                    border-left: 4px solid var(--primary-color);
                    box-shadow: 0 2px 5px rgba(0,0,0,0.05);
                ">
                    <p style="
                        font-size: 1.05rem;
                        line-height: 1.6;
                        color: var(--text-color);
                        margin: 0 0 10px 0;
                        font-style: italic;
                    ">"${quote.text}"</p>
                    <p style="
                        text-align: right;
                        color: var(--accent-light);
                        font-weight: 600;
                        font-size: 0.95rem;
                        margin: 0;
                    ">â€” ${quote.author}</p>
                </div>
            `;
        });
        
        container.innerHTML = html;
        modal.style.display = 'block';
        
        // Optional: Play a little celebration
        console.log('ðŸŽ® Konami Code Activated! ðŸŽ®');
    }
})();

// Make diff elements annotatable
function makeAnnotatable(essayTitle, fromDraft, toDraft) {
    const diffPanel = document.querySelector('.comparison-slider').children[currentPosition];
    if (!diffPanel || !diffPanel.classList.contains('diff-panel')) return;
    
    const additions = diffPanel.querySelectorAll('.addition');
    const deletions = diffPanel.querySelectorAll('.deletion');
    
    [...additions, ...deletions].forEach(element => {
        const text = element.textContent;
        const annotationId = getAnnotationId(essayTitle, fromDraft, toDraft, text);
        
        element.classList.add('annotatable');
        
        // Check if annotation exists
        if (annotations[annotationId]) {
            element.classList.add('has-annotation');
        }
        
        element.onclick = function(e) {
            e.stopPropagation();
            const existingNote = annotations[annotationId]?.note || '';
            showAnnotationPopup(element, annotationId, existingNote);
        };
    });
}

// Display all annotations for current comparison
function displayAnnotations() {
    const modal = document.getElementById('annotationsModal');
    const content = document.getElementById('annotationsContent');
    
    if (!currentEssay) {
        content.innerHTML = '<p>No essay loaded.</p>';
        modal.style.display = 'block';
        return;
    }
    
    const currentPanel = document.querySelector('.comparison-slider').children[currentPosition];
    if (!currentPanel || !currentPanel.classList.contains('diff-panel')) {
        content.innerHTML = '<p>Navigate to a changes view to see annotations.</p>';
        modal.style.display = 'block';
        return;
    }
    
    // Get current draft info
    const panelInfo = getPanelInfo();
    const panel = panelInfo[currentPosition];
    
    if (panel.type !== 'diff') {
        content.innerHTML = '<p>Navigate to a changes view to see annotations.</p>';
        modal.style.display = 'block';
        return;
    }
    
    const fromDraft = currentEssay.drafts[panel.fromIndex].version;
    const toDraft = currentEssay.drafts[panel.toIndex].version;
    
    // Find relevant annotations
    const relevantAnnotations = Object.entries(annotations).filter(([id]) => {
        return id.startsWith(`${currentEssay.title}|${fromDraft}|${toDraft}`);
    });
    
    if (relevantAnnotations.length === 0) {
        content.innerHTML = `
            <div class="annotations-panel">
                <p>No annotations yet for this comparison.</p>
                <p style="margin-top: 10px; color: #666;">
                    <strong>Tip:</strong> Click on any highlighted addition or deletion in the changes view to add an annotation.
                </p>
            </div>
        `;
    } else {
        let html = `<div class="annotations-panel">
            <p style="margin-bottom: 20px; color: #666;">
                Showing ${relevantAnnotations.length} annotation(s) for ${fromDraft} â†’ ${toDraft}
            </p>`;
        
        relevantAnnotations.forEach(([id, data]) => {
            html += `
                <div class="annotation-item">
                    <div class="annotation-item-header">Revised text:</div>
                    <div class="annotation-item-text">"${data.text.substring(0, 100)}${data.text.length > 100 ? '...' : ''}"</div>
                    <div class="annotation-item-header">Your note:</div>
                    <div class="annotation-item-note">${data.note}</div>
                    <div style="margin-top: 8px; font-size: 0.85rem; color: #999;">
                        ${new Date(data.timestamp).toLocaleString()}
                    </div>
                </div>
            `;
        });
        
        html += '</div>';
        content.innerHTML = html;
    }
    
    modal.style.display = 'block';
}

// PDF Export Functions

function showPdfOptions() {
    const currentPanel = document.querySelector('.comparison-slider').children[currentPosition];
    
    if (!currentEssay && !currentPanel) {
        alert('Please load an essay or upload files first.');
        return;
    }
    
    // Show modal
    document.getElementById('pdfOptionsModal').style.display = 'block';
    
    // Make options mutually exclusive for all drafts vs current only
    const allDraftsCheckbox = document.getElementById('includeAllDrafts');
    const currentOnlyCheckbox = document.getElementById('includeCurrentOnly');
    
    allDraftsCheckbox.onchange = function() {
        if (this.checked) {
            currentOnlyCheckbox.checked = false;
        }
    };
    
    currentOnlyCheckbox.onchange = function() {
        if (this.checked) {
            allDraftsCheckbox.checked = false;
        } else {
            allDraftsCheckbox.checked = true;
        }
    };
}

function generatePrintableContent() {
    const includeAllDrafts = document.getElementById('includeAllDrafts').checked;
    const includeCurrentOnly = document.getElementById('includeCurrentOnly').checked;
    const includeAnnotations = document.getElementById('includeAnnotations').checked;
    const includeFeedback = document.getElementById('includeFeedback').checked;
    const includeLegend = document.getElementById('includeLegend').checked;
    
    const printableDiv = document.getElementById('printableContent');
    let html = '';
    
    // Add legend (no title page anymore)
    if (includeLegend) {
        html += `<div class="print-legend" style="margin-bottom: 20px;">
            <h3>Color Legend</h3>
            <p><span class="deletion word-level">Deleted text</span> - Text removed from previous draft</p>
            <p><span class="addition word-level">Added text</span> - Text added in revision</p>
            ${includeAnnotations ? '<p>Numbers in circles indicate annotated revisions with notes in the margin</p>' : ''}
        </div>`;
    }
    
    if (includeCurrentOnly) {
        // Export only current view
        const currentPanel = document.querySelector('.comparison-slider').children[currentPosition];
        const panelInfo = getPanelInfo();
        const currentPanelInfo = panelInfo[currentPosition];
        
        if (currentPanelInfo.type === 'draft') {
            html += generateDraftForPrint(currentEssay.drafts[currentPanelInfo.index], true, includeFeedback);
        } else if (currentPanelInfo.type === 'diff') {
            html += generateDiffForPrint(
                currentEssay.drafts[currentPanelInfo.fromIndex],
                currentEssay.drafts[currentPanelInfo.toIndex],
                currentPanel,
                includeAnnotations,
                true
            );
        }
    } else if (includeAllDrafts) {
        // Export all drafts
        const slider = document.getElementById('comparisonSlider');
        const panels = Array.from(slider.children);
        const panelInfo = getPanelInfo();
        
        panelInfo.forEach((info, index) => {
            const isFirstPage = index === 0;
            if (info.type === 'draft') {
                html += generateDraftForPrint(currentEssay.drafts[info.index], isFirstPage, includeFeedback);
            } else if (info.type === 'diff') {
                html += generateDiffForPrint(
                    currentEssay.drafts[info.fromIndex],
                    currentEssay.drafts[info.toIndex],
                    panels[index],
                    includeAnnotations,
                    isFirstPage
                );
            }
        });
    }
    
    printableDiv.innerHTML = html;
}
function generateDiffForPrint(fromDraft, toDraft, panelElement, includeAnnotations, isFirstPage = false) {
    // Get annotations for this diff
    const relevantAnnotations = includeAnnotations ?
        getAnnotationsForDiff(fromDraft.version, toDraft.version) : [];

    // Get the diff content
    let diffContent = panelElement.querySelector('.panel-content').innerHTML;

    // Number annotations by their appearance order in the text (top to bottom)
    const orderedAnnotations = [];

    if (includeAnnotations && relevantAnnotations.length > 0) {
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = diffContent;

        const additions = tempDiv.querySelectorAll('.addition');
        const deletions = tempDiv.querySelectorAll('.deletion');

        // Build a map of text content to annotation data
        const textToAnnotation = new Map();
        relevantAnnotations.forEach(([id, data]) => {
            textToAnnotation.set(data.text, data);
        });

        // Get all annotatable elements (additions and deletions) in document order
        const allElements = tempDiv.querySelectorAll('.addition, .deletion');

        // Iterate through elements in document order and assign numbers
        let annotationNumber = 1;
        const annotationMap = new Map();

        allElements.forEach(el => {
            const text = el.textContent;
            const annotationData = textToAnnotation.get(text);
            if (annotationData && !annotationMap.has(text)) {
                annotationMap.set(text, annotationNumber);

                // Add reference number to the edited text
                el.innerHTML += `<span class="annotation-ref">${annotationNumber}</span>`;

                orderedAnnotations.push({ num: annotationNumber, data: annotationData });
                annotationNumber++;
            }
        });

        diffContent = tempDiv.innerHTML;
    }

    // Build the HTML with two-column layout
    let html = `
        <div class="print-page">
    `;

    // Add document title only on first page
    if (isFirstPage && currentEssay) {
        html += `
            <div style="text-align: center; margin-bottom: 15px; padding-bottom: 8px; border-bottom: 1px solid #333;">
                <div style="font-size: 16pt; font-weight: bold; margin-bottom: 3px;">${currentEssay.title}</div>
                <div style="font-size: 10pt; font-style: italic;">${currentEssay.author} â€¢ ${new Date().toLocaleDateString()}</div>
            </div>
        `;
    }

    html += `
            <div class="print-page-header">
                Changes: ${fromDraft.version} â†’ ${toDraft.version}
            </div>

            <div class="print-content-wrapper">
                <div class="print-main-content">
                    ${diffContent}
                </div>

                <div class="print-annotations-margin">
    `;

    // Add annotations to margin in order of appearance (at the top)
    if (includeAnnotations && orderedAnnotations.length > 0) {
        html += '<div style="font-weight: bold; font-size: 10pt; margin-bottom: 15px; color: #000;">Revision Notes</div>';

        orderedAnnotations.forEach(({ num, data }) => {
            const truncatedText = data.text.length > 60 ?
                data.text.substring(0, 60) + '...' :
                data.text;

            html += `
                <div class="margin-annotation">
                    <div style="display: flex; align-items: start;">
                        <span class="margin-annotation-number">${num}</span>
                        <div style="flex: 1;">
                            <div class="margin-annotation-text">"${truncatedText}"</div>
                            <div class="margin-annotation-content">${data.note}</div>
                        </div>
                    </div>
                </div>
            `;
        });
    } else if (includeAnnotations) {
        html += '<div style="font-size: 9pt; color: #999; font-style: italic;">No annotations for this section</div>';
    }

    html += `
                </div>
            </div>
        </div>
    `;

    return html;
}

function generateDraftForPrint(draft, isFirstPage = false, includeFeedback = false) {
    let html = `<div class="print-page">`;

    // Add document title only on first page
    if (isFirstPage && currentEssay) {
        html += `
            <div style="text-align: center; margin-bottom: 15px; padding-bottom: 8px; border-bottom: 1px solid #333;">
                <div style="font-size: 16pt; font-weight: bold; margin-bottom: 3px;">${currentEssay.title}</div>
                <div style="font-size: 10pt; font-style: italic;">${currentEssay.author} â€¢ ${new Date().toLocaleDateString()}</div>
            </div>
        `;
    }

    html += `
            <div class="print-page-header">${draft.version}</div>
            <div class="print-main-content" style="width: 100%;">
                ${formatText(draft.text)}
            </div>
    `;

    // Add feedback as footnote if available
    if (includeFeedback && currentEssay) {
        const feedbackId = getFeedbackId(currentEssay.title, draft.version);
        const feedbackData = draftFeedback[feedbackId];

        if (feedbackData && feedbackData.items && feedbackData.items.length > 0) {
            html += `
                <div style="margin-top: 30px; padding-top: 15px; border-top: 2px solid #57068c; page-break-inside: avoid;">
                    <div style="font-size: 10pt; font-weight: bold; color: #57068c; margin-bottom: 12px;">
                        ðŸ“ Feedback for ${draft.version}
                    </div>
            `;

            // Sort feedback by date
            const sortedItems = [...feedbackData.items].sort((a, b) =>
                new Date(a.date) - new Date(b.date)
            );

            sortedItems.forEach((item, index) => {
                const sourceIcons = {
                    'instructor': 'ðŸ“š',
                    'peer': 'ðŸ‘¥',
                    'writing-center': 'ðŸ“',
                    'self': 'ðŸ’­',
                    'other': 'ðŸ“Œ'
                };

                const sourceLabels = {
                    'instructor': 'Instructor',
                    'peer': 'Peer',
                    'writing-center': 'Writing Center',
                    'self': 'Self-Analysis',
                    'other': 'Other'
                };

                const icon = sourceIcons[item.source] || 'ðŸ“Œ';
                const label = sourceLabels[item.source] || 'Other';
                const displayName = item.sourceName ? ` (${item.sourceName})` : '';
                const formattedDate = new Date(item.date).toLocaleDateString('en-US', {
                    month: 'short',
                    day: 'numeric',
                    year: 'numeric'
                });

                html += `
                    <div style="margin-bottom: ${index < sortedItems.length - 1 ? '15px' : '0'}; padding: 10px; background: #eee6f3; border-left: 3px solid #57068c; border-radius: 3px; page-break-inside: avoid;">
                        <div style="font-size: 9pt; font-weight: bold; color: #57068c; margin-bottom: 5px;">
                            ${icon} ${label}${displayName} <span style="font-weight: normal; color: #666;">â€¢ ${formattedDate}</span>
                        </div>
                `;

                // Add self-analysis fields if present
                if (item.source === 'self' && (item.goals || item.tryingToImprove)) {
                    if (item.goals) {
                        html += `
                            <div style="font-size: 8.5pt; margin-bottom: 4px;">
                                <strong>Goals:</strong> ${item.goals}
                            </div>
                        `;
                    }
                    if (item.tryingToImprove) {
                        html += `
                            <div style="font-size: 8.5pt; margin-bottom: 4px;">
                                <strong>Trying to Improve:</strong> ${item.tryingToImprove}
                            </div>
                        `;
                    }
                }

                // Add main content
                html += `
                        <div style="font-size: 9pt; line-height: 1.6; color: #333; margin-top: 5px;">
                            ${item.content}
                        </div>
                `;

                // Add tags if present
                if (item.tags && item.tags.length > 0) {
                    html += `
                        <div style="margin-top: 6px; font-size: 8pt;">
                            ${item.tags.map(tag =>
                                `<span style="display: inline-block; background: #eee6f3; color: #57068c; padding: 2px 8px; border-radius: 10px; margin-right: 4px;">${tag}</span>`
                            ).join('')}
                        </div>
                    `;
                }

                // Add attachments note if present
                if (item.attachments && item.attachments.length > 0) {
                    html += `
                        <div style="margin-top: 6px; font-size: 8pt; color: #666; font-style: italic;">
                            ðŸ“Ž ${item.attachments.length} attachment${item.attachments.length > 1 ? 's' : ''}: ${item.attachments.map(a => a.name).join(', ')}
                        </div>
                    `;
                }

                // Add understanding section if present
                if (item.understood && (item.understandingExplanation || item.understandingActionPlan || item.understandingQuestions)) {
                    html += `
                        <div style="margin-top: 10px; padding: 10px; background: #eee6f3; border: 1px solid #ab82c5; border-radius: 3px;">
                            <div style="font-size: 8.5pt; font-weight: bold; color: #57068c; margin-bottom: 6px;">
                                ðŸ’¡ My Understanding:
                            </div>
                    `;

                    if (item.understandingExplanation) {
                        html += `
                            <div style="margin-bottom: 6px;">
                                <div style="font-size: 8pt; font-weight: bold; color: #57068c;">In my own words:</div>
                                <div style="font-size: 8pt; color: #333; line-height: 1.5;">${item.understandingExplanation}</div>
                            </div>
                        `;
                    }

                    if (item.understandingActionPlan) {
                        html += `
                            <div style="margin-bottom: 6px;">
                                <div style="font-size: 8pt; font-weight: bold; color: #57068c;">My action plan:</div>
                                <div style="font-size: 8pt; color: #333; line-height: 1.5;">${item.understandingActionPlan}</div>
                            </div>
                        `;
                    }

                    if (item.understandingQuestions) {
                        html += `
                            <div>
                                <div style="font-size: 8pt; font-weight: bold; color: #57068c;">Questions:</div>
                                <div style="font-size: 8pt; color: #333; line-height: 1.5;">${item.understandingQuestions}</div>
                            </div>
                        `;
                    }

                    html += `</div>`;
                }

                html += `</div>`;
            });

            // Add synthesis notes if they exist
            if (feedbackData.synthesis && (feedbackData.synthesis.convergence || feedbackData.synthesis.divergence)) {
                html += `
                    <div style="margin-top: 20px; padding: 15px; background: #fff3e0; border: 2px solid #ffb74d; border-radius: 5px; page-break-inside: avoid;">
                        <div style="font-size: 10pt; font-weight: bold; color: #e65100; margin-bottom: 12px;">
                            ðŸ“ Feedback Synthesis & Reflection
                        </div>
                `;

                if (feedbackData.synthesis.convergence) {
                    html += `
                        <div style="margin-bottom: 12px;">
                            <div style="font-size: 9pt; font-weight: bold; color: #e65100; margin-bottom: 4px;">
                                ðŸ¤ Convergence: Where feedback agrees
                            </div>
                            <div style="font-size: 9pt; color: #333; line-height: 1.6;">
                                ${feedbackData.synthesis.convergence.replace(/\n/g, '<br>')}
                            </div>
                        </div>
                    `;
                }

                if (feedbackData.synthesis.divergence) {
                    html += `
                        <div>
                            <div style="font-size: 9pt; font-weight: bold; color: #e65100; margin-bottom: 4px;">
                                âš–ï¸ Divergence: Where feedback conflicts
                            </div>
                            <div style="font-size: 9pt; color: #333; line-height: 1.6;">
                                ${feedbackData.synthesis.divergence.replace(/\n/g, '<br>')}
                            </div>
                        </div>
                    `;
                }

                html += `</div>`;
            }

            // Add priority matrix if there are feedback items with priority data
            const itemsWithPriority = feedbackData.items.filter(item =>
                item.scope !== undefined && item.impact !== undefined
            );

            if (itemsWithPriority.length > 0) {
                html += `
                    <div style="margin-top: 20px; padding: 15px; background: #f3e5f5; border: 2px solid #ba68c8; border-radius: 5px; page-break-inside: avoid;">
                        <div style="font-size: 10pt; font-weight: bold; color: #6a1b9a; margin-bottom: 12px;">
                            ðŸ“Š Revision Priority Matrix
                        </div>
                        <div style="font-size: 8.5pt; color: #6a1b9a; margin-bottom: 10px; font-style: italic;">
                            Feedback organized by scope (local â†’ global) and impact (low â†’ high)
                        </div>
                `;

                // Create quadrants
                const quadrants = {
                    1: { label: 'Local & High Impact', items: [], color: '#fce4ec' },
                    2: { label: 'Global & High Impact', items: [], color: '#f3e5f5' },
                    3: { label: 'Local & Low Impact', items: [], color: '#f9f9f9' },
                    4: { label: 'Global & Low Impact', items: [], color: '#fafafa' }
                };

                // Sort items into quadrants
                itemsWithPriority.forEach(item => {
                    const scope = item.scope || 50;
                    const impact = item.impact || 50;

                    let quadrantNum;
                    if (scope < 50 && impact >= 50) {
                        quadrantNum = 1;
                    } else if (scope >= 50 && impact >= 50) {
                        quadrantNum = 2;
                    } else if (scope < 50 && impact < 50) {
                        quadrantNum = 3;
                    } else {
                        quadrantNum = 4;
                    }

                    quadrants[quadrantNum].items.push(item);
                });

                // Render quadrants in a grid
                html += `<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 10px;">`;

                // Top row (high impact): Quadrant 1, then Quadrant 2
                [1, 2].forEach(qNum => {
                    const q = quadrants[qNum];
                    html += `
                        <div style="background: ${q.color}; border: 1px solid #ba68c8; border-radius: 4px; padding: 10px;">
                            <div style="font-size: 8.5pt; font-weight: bold; color: #6a1b9a; margin-bottom: 8px; text-align: center;">
                                ${q.label}
                            </div>
                    `;

                    if (q.items.length > 0) {
                        q.items.forEach(item => {
                            const sourceLabels = {
                                'instructor': 'Instructor',
                                'peer': 'Peer',
                                'writing-center': 'Writing Center',
                                'self': 'Self',
                                'other': item.sourceName || 'Other'
                            };
                            const textContent = item.content.replace(/<[^>]*>/g, ' ').replace(/\s+/g, ' ').trim();
                            const preview = textContent.length > 80 ? textContent.substring(0, 80) + '...' : textContent;

                            html += `
                                <div style="background: white; border: 1px solid #ce93d8; border-radius: 3px; padding: 6px; margin-bottom: 6px; font-size: 8pt;">
                                    <div style="font-weight: bold; color: #6a1b9a; margin-bottom: 3px;">
                                        ${sourceLabels[item.source] || 'Feedback'}
                                    </div>
                                    <div style="color: #333; line-height: 1.4;">
                                        ${preview}
                                    </div>
                                </div>
                            `;
                        });
                    } else {
                        html += `<div style="font-size: 8pt; color: #999; font-style: italic; text-align: center;">No items</div>`;
                    }

                    html += `</div>`;
                });

                html += `</div>`;

                // Bottom row (low impact): Quadrant 3, then Quadrant 4
                html += `<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 10px;">`;

                [3, 4].forEach(qNum => {
                    const q = quadrants[qNum];
                    html += `
                        <div style="background: ${q.color}; border: 1px solid #ba68c8; border-radius: 4px; padding: 10px;">
                            <div style="font-size: 8.5pt; font-weight: bold; color: #6a1b9a; margin-bottom: 8px; text-align: center;">
                                ${q.label}
                            </div>
                    `;

                    if (q.items.length > 0) {
                        q.items.forEach(item => {
                            const sourceLabels = {
                                'instructor': 'Instructor',
                                'peer': 'Peer',
                                'writing-center': 'Writing Center',
                                'self': 'Self',
                                'other': item.sourceName || 'Other'
                            };
                            const textContent = item.content.replace(/<[^>]*>/g, ' ').replace(/\s+/g, ' ').trim();
                            const preview = textContent.length > 80 ? textContent.substring(0, 80) + '...' : textContent;

                            html += `
                                <div style="background: white; border: 1px solid #ce93d8; border-radius: 3px; padding: 6px; margin-bottom: 6px; font-size: 8pt;">
                                    <div style="font-weight: bold; color: #6a1b9a; margin-bottom: 3px;">
                                        ${sourceLabels[item.source] || 'Feedback'}
                                    </div>
                                    <div style="color: #333; line-height: 1.4;">
                                        ${preview}
                                    </div>
                                </div>
                            `;
                        });
                    } else {
                        html += `<div style="font-size: 8pt; color: #999; font-style: italic; text-align: center;">No items</div>`;
                    }

                    html += `</div>`;
                });

                html += `</div>`;  // Close bottom row
                html += `</div>`;  // Close matrix section
            }

            html += `</div>`;
        }
    }

    html += `</div>`;

    return html;
}
function getAnnotationsForDiff(fromDraft, toDraft) {
    if (!currentEssay) return [];
    
    return Object.entries(annotations).filter(([id]) => {
        return id.startsWith(`${currentEssay.title}|${fromDraft}|${toDraft}`);
    });
}

function exportToPdf() {
    // Generate the content
    generatePrintableContent();

    // Show the printable content temporarily
    const printableDiv = document.getElementById('printableContent');
    printableDiv.style.display = 'block';

    // Close the modal
    document.getElementById('pdfOptionsModal').style.display = 'none';

    // Small delay to ensure content is rendered
    setTimeout(() => {
        // Trigger print dialog
        window.print();

        // Hide printable content after printing
        setTimeout(() => {
            printableDiv.style.display = 'none';
        }, 500);
    }, 250);
}

// Helper function to get panel info
function getPanelInfo() {
    const slider = document.getElementById('comparisonSlider');
    const panels = Array.from(slider.children);
    const panelInfo = [];

    // Build a map of draft versions to indices
    const versionToIndex = new Map();
    if (currentEssay && currentEssay.drafts) {
        currentEssay.drafts.forEach((draft, index) => {
            versionToIndex.set(draft.version, index);
        });
    }

    let draftIndex = 0;
    for (let i = 0; i < panels.length; i++) {
        const panel = panels[i];

        // Check if this is a diff panel by looking for the 'diff-panel' class
        if (panel.classList.contains('diff-panel')) {
            // This is a diff panel - extract version info from heading
            const heading = panel.querySelector('h3');
            const headingText = heading ? heading.textContent : '';

            // Check if this is a Complete Transformation panel
            if (headingText.includes('Complete Transformation')) {
                // Extract version names from "Complete Transformation: Version1 â†’ Version2"
                const match = headingText.match(/Complete Transformation:\s*(.+?)\s*â†’\s*(.+)/);
                if (match && currentEssay && currentEssay.drafts) {
                    const fromVersion = match[1].trim();
                    const toVersion = match[2].trim();
                    const fromIndex = versionToIndex.get(fromVersion) ?? 0;
                    const toIndex = versionToIndex.get(toVersion) ?? (currentEssay.drafts.length - 1);
                    panelInfo.push({ type: 'diff', fromIndex, toIndex });
                } else {
                    // Fallback: first to last draft
                    const fromIndex = 0;
                    const toIndex = currentEssay ? currentEssay.drafts.length - 1 : 0;
                    panelInfo.push({ type: 'diff', fromIndex, toIndex });
                }
            } else {
                // Regular diff panel - extract versions from "Changes: Version1 â†’ Version2"
                const match = headingText.match(/Changes:\s*(.+?)\s*â†’\s*(.+)/);
                if (match && currentEssay && currentEssay.drafts) {
                    const fromVersion = match[1].trim();
                    const toVersion = match[2].trim();
                    const fromIndex = versionToIndex.get(fromVersion) ?? (draftIndex - 1);
                    const toIndex = versionToIndex.get(toVersion) ?? draftIndex;
                    panelInfo.push({ type: 'diff', fromIndex, toIndex });
                } else {
                    // Fallback to old logic for regular diff panels
                    panelInfo.push({ type: 'diff', fromIndex: draftIndex - 1, toIndex: draftIndex });
                }
            }
        } else {
            // This is a draft panel
            panelInfo.push({ type: 'draft', index: draftIndex });
            draftIndex++;
        }
    }

    return panelInfo;
}


// Helper function to escape HTML
function escapeHtml(text) {
    const div = document.createElement('div');
    div.textContent = text;
    return div.innerHTML;
}

// Replace the existing analyzeRevisions function and related code with this enhanced version

// Enhanced revision analysis with better categorization
function analyzeRevisions(diffHtml) {
    const analysis = {
        additions: {
            micro: [],      // 1-2 words (punctuation, articles, minor word changes)
            small: [],      // 3-10 words (phrases, short additions)
            medium: [],     // 11-50 words (sentences, substantial phrases)
            large: [],      // 51-150 words (paragraphs)
            massive: []     // 150+ words (multiple paragraphs, major sections)
        },
        deletions: {
            micro: [],
            small: [],
            medium: [],
            large: [],
            massive: []
        },
        statistics: {
            totalChanges: 0,
            totalWordsAdded: 0,
            totalWordsDeleted: 0,
            netWordChange: 0,
            revisionIntensity: 0  // Percentage of text that changed
        },
        patterns: {
            surfaceEdits: 0,      // Micro changes (likely copyediting)
            substantiveEdits: 0,   // Small-medium changes
            structuralChanges: 0,  // Large-massive changes
            balanceScore: 0        // Ratio of additions to deletions
        }
    };
    
    // Parse the diff HTML
    const tempDiv = document.createElement('div');
    tempDiv.innerHTML = diffHtml;
    
    // Process additions
    const additions = tempDiv.querySelectorAll('.addition');
    additions.forEach(span => {
        const text = span.textContent;
        const category = categorizeRevision(text);
        const wordCount = countWords(text);
        
        analysis.additions[category].push({
            text: text,
            wordCount: wordCount,
            charCount: text.length
        });
        analysis.statistics.totalWordsAdded += wordCount;
    });
    
    // Process deletions
    const deletions = tempDiv.querySelectorAll('.deletion');
    deletions.forEach(span => {
        const text = span.textContent;
        const category = categorizeRevision(text);
        const wordCount = countWords(text);
        
        analysis.deletions[category].push({
            text: text,
            wordCount: wordCount,
            charCount: text.length
        });
        analysis.statistics.totalWordsDeleted += wordCount;
    });
    
    // Calculate statistics
    analysis.statistics.totalChanges = additions.length + deletions.length;
    analysis.statistics.netWordChange = analysis.statistics.totalWordsAdded - analysis.statistics.totalWordsDeleted;
    
    // Calculate revision patterns
    calculateRevisionPatterns(analysis);
    
    // Calculate revision intensity
    const totalText = tempDiv.textContent;
    const unchangedText = totalText.replace(/<[^>]*>/g, '');
    if (unchangedText.length > 0) {
        const changedChars = Array.from(additions).reduce((sum, el) => sum + el.textContent.length, 0) +
                           Array.from(deletions).reduce((sum, el) => sum + el.textContent.length, 0);
        analysis.statistics.revisionIntensity = Math.round((changedChars / unchangedText.length) * 100);
    }
    
    return analysis;
}

// Categorize revision by size
function categorizeRevision(text) {
    const wordCount = countWords(text);
    
    if (wordCount <= 2) return 'micro';
    if (wordCount <= 10) return 'small';
    if (wordCount <= 50) return 'medium';
    if (wordCount <= 150) return 'large';
    return 'massive';
}

// Count words accurately
function countWords(text) {
    const words = text.trim().match(/\b\w+(?:'\w+)?\b/g);
    return words ? words.length : 0;
}

// Calculate revision patterns
function calculateRevisionPatterns(analysis) {
    const categories = ['micro', 'small', 'medium', 'large', 'massive'];
    
    // Count surface edits (micro changes)
    analysis.patterns.surfaceEdits = 
        analysis.additions.micro.length + analysis.deletions.micro.length;
    
    // Count substantive edits (small and medium)
    analysis.patterns.substantiveEdits = 
        analysis.additions.small.length + analysis.deletions.small.length +
        analysis.additions.medium.length + analysis.deletions.medium.length;
    
    // Count structural changes (large and massive)
    analysis.patterns.structuralChanges = 
        analysis.additions.large.length + analysis.deletions.large.length +
        analysis.additions.massive.length + analysis.deletions.massive.length;
    
    // Calculate balance score
    const totalAdditions = categories.reduce((sum, cat) => sum + analysis.additions[cat].length, 0);
    const totalDeletions = categories.reduce((sum, cat) => sum + analysis.deletions[cat].length, 0);
    
    if (totalDeletions > 0) {
        analysis.patterns.balanceScore = (totalAdditions / totalDeletions).toFixed(2);
    } else if (totalAdditions > 0) {
        analysis.patterns.balanceScore = "âˆž"; // All additions, no deletions
    } else {
        analysis.patterns.balanceScore = "0";
    }
}

// Generate purely quantitative table view
function generateEnhancedTableView(analysis) {
    const categories = [
        { key: 'micro', label: 'Micro (1-2 words)', description: 'Punctuation, articles, minor adjustments' },
        { key: 'small', label: 'Small (3-10 words)', description: 'Phrases, clarifications' },
        { key: 'medium', label: 'Medium (11-50 words)', description: 'Sentences, substantial additions' },
        { key: 'large', label: 'Large (51-150 words)', description: 'Paragraphs, major revisions' },
        { key: 'massive', label: 'Massive (150+ words)', description: 'Multiple paragraphs, new sections' }
    ];
    
    let html = `
        <!-- Summary Statistics -->
        <div class="stats-summary">
            <div class="stat-card">
                <div class="stat-number">${analysis.statistics.totalChanges}</div>
                <div class="stat-label">Total Changes</div>
            </div>
            <div class="stat-card">
                <div class="stat-number" style="color: #2e7d32;">${analysis.statistics.totalWordsAdded}</div>
                <div class="stat-label">Words Added</div>
            </div>
            <div class="stat-card">
                <div class="stat-number" style="color: #c62828;">${analysis.statistics.totalWordsDeleted}</div>
                <div class="stat-label">Words Deleted</div>
            </div>
            <div class="stat-card">
                <div class="stat-number" style="color: ${analysis.statistics.netWordChange >= 0 ? '#2e7d32' : '#c62828'};">
                    ${analysis.statistics.netWordChange > 0 ? '+' : ''}${analysis.statistics.netWordChange}
                </div>
                <div class="stat-label">Net Word Change</div>
            </div>
        </div>

        <!-- Revision Distribution -->
        <div style="margin: 30px 0; padding: 20px; background: var(--secondary-color); border-radius: 8px;">
            <h3 style="color: var(--primary-dark); margin-bottom: 15px;">Revision Distribution</h3>
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">
                <div>
                    <strong>Micro Changes:</strong> ${analysis.patterns.surfaceEdits} changes<br>
                    <small style="color: #666;">${Math.round((analysis.patterns.surfaceEdits / analysis.statistics.totalChanges) * 100) || 0}% of total</small>
                </div>
                <div>
                    <strong>Small-Medium Changes:</strong> ${analysis.patterns.substantiveEdits} changes<br>
                    <small style="color: #666;">${Math.round((analysis.patterns.substantiveEdits / analysis.statistics.totalChanges) * 100) || 0}% of total</small>
                </div>
                <div>
                    <strong>Large-Massive Changes:</strong> ${analysis.patterns.structuralChanges} changes<br>
                    <small style="color: #666;">${Math.round((analysis.patterns.structuralChanges / analysis.statistics.totalChanges) * 100) || 0}% of total</small>
                </div>
                <div>
                    <strong>Addition/Deletion Ratio:</strong> ${analysis.patterns.balanceScore}<br>
                    <small style="color: #666;">${describeRatio(analysis.patterns.balanceScore)}</small>
                </div>
            </div>
        </div>

        <!-- Detailed Breakdown Table -->
        <h3 style="color: var(--primary-dark); margin: 20px 0 10px 0;">Detailed Breakdown</h3>
        <table class="revision-table">
            <thead>
                <tr>
                    <th>Revision Size</th>
                    <th style="text-align: center;">Additions</th>
                    <th style="text-align: center;">Deletions</th>
                    <th style="text-align: center;">Total</th>
                    <th style="text-align: center;">% of All Changes</th>
                </tr>
            </thead>
            <tbody>
    `;
    
    let totalAdditions = 0;
    let totalDeletions = 0;
    
    categories.forEach(cat => {
        const additions = analysis.additions[cat.key].length;
        const deletions = analysis.deletions[cat.key].length;
        const rowTotal = additions + deletions;
        const percentage = Math.round((rowTotal / analysis.statistics.totalChanges) * 100) || 0;
        
        totalAdditions += additions;
        totalDeletions += deletions;
        
        html += `
            <tr>
                <td class="row-label">${cat.label}</td>
                <td style="text-align: center; color: #2e7d32; font-weight: 600;">${additions}</td>
                <td style="text-align: center; color: #c62828; font-weight: 600;">${deletions}</td>
                <td style="text-align: center; font-weight: 700;">${rowTotal}</td>
                <td style="text-align: center; font-weight: 600;">${percentage}%</td>
            </tr>
        `;
    });
    
    // Totals row
    html += `
        <tr class="total-row">
            <td class="row-label"><strong>TOTAL</strong></td>
            <td style="text-align: center; font-weight: 700; color: #2e7d32;">${totalAdditions}</td>
            <td style="text-align: center; font-weight: 700; color: #c62828;">${totalDeletions}</td>
            <td style="text-align: center; font-weight: 700;">${totalAdditions + totalDeletions}</td>
            <td style="text-align: center; font-weight: 700;">100%</td>
        </tr>
    `;
    
    html += '</tbody></table>';
    
    // Add quantitative summary
    html += generateQuantitativeObservations(analysis);
    
    return html;
}

// Replace interpretBalanceScore with purely descriptive version
function describeRatio(score) {
    if (score === "âˆž") return "Only additions (no deletions)";
    if (score === "0") return "No changes detected";
    const numScore = parseFloat(score);
    if (numScore > 1) return `${numScore}Ã— more additions than deletions`;
    if (numScore === 1) return "Equal additions and deletions";
    return `${(1/numScore).toFixed(2)}Ã— more deletions than additions`;
}

// NEW: Purely observational summary (NO interpretation)
function generateQuantitativeObservations(analysis) {
    const totalChanges = analysis.statistics.totalChanges;
    const microPercent = Math.round((analysis.patterns.surfaceEdits / totalChanges) * 100) || 0;
    const substantivePercent = Math.round((analysis.patterns.substantiveEdits / totalChanges) * 100) || 0;
    const structuralPercent = Math.round((analysis.patterns.structuralChanges / totalChanges) * 100) || 0;
    const netChange = analysis.statistics.netWordChange;
    
    let html = `
        <div style="margin-top: 30px; padding: 25px; background: white; border-left: 4px solid var(--primary-color); border-radius: 8px;">
            <h3 style="color: var(--primary-dark); margin-bottom: 15px;">ðŸ“Š Quantitative Observations</h3>
            
            <div style="margin-bottom: 15px;">
                <strong>Change Distribution:</strong>
                <ul style="margin: 8px 0; padding-left: 20px;">
                    <li>${microPercent}% of changes are 1-2 words (micro)</li>
                    <li>${substantivePercent}% of changes are 3-50 words (small-medium)</li>
                    <li>${structuralPercent}% of changes are 51+ words (large-massive)</li>
                </ul>
            </div>
            
            <div style="margin-bottom: 15px;">
                <strong>Word Count Changes:</strong>
                <ul style="margin: 8px 0; padding-left: 20px;">
                    <li>Net change: ${netChange > 0 ? '+' : ''}${netChange} words</li>
                    <li>Words added: ${analysis.statistics.totalWordsAdded}</li>
                    <li>Words deleted: ${analysis.statistics.totalWordsDeleted}</li>
                    <li>Ratio: ${analysis.patterns.balanceScore} additions per deletion</li>
                </ul>
            </div>
            
            <div style="margin-bottom: 15px;">
                <strong>Change Patterns:</strong>
                <ul style="margin: 8px 0; padding-left: 20px;">
                    <li>${analysis.patterns.surfaceEdits} micro-level changes</li>
                    <li>${analysis.patterns.substantiveEdits} phrase/sentence-level changes</li>
                    <li>${analysis.patterns.structuralChanges} paragraph/section-level changes</li>
                </ul>
            </div>
        </div>
    `;
    
    return html;
}

// Interpret balance score
function interpretBalanceScore(score) {
    if (score === "âˆž") return "Pure expansion (no deletions)";
    if (score === "0") return "No changes detected";
    const numScore = parseFloat(score);
    if (numScore > 2) return "Heavy expansion";
    if (numScore > 1.2) return "More adding than cutting";
    if (numScore > 0.8) return "Balanced revision";
    if (numScore > 0.5) return "More cutting than adding";
    return "Heavy condensation";
}



// Analyze word frequency in changes
function analyzeWordFrequency(analysis) {
    const wordCounts = {};
    const categories = ['small', 'medium', 'large', 'massive'];
    
    // Count word frequency in additions
    categories.forEach(cat => {
        analysis.additions[cat].forEach(item => {
            const words = item.text.toLowerCase().match(/\b\w+(?:'\w+)?\b/g) || [];
            words.forEach(word => {
                if (word.length > 4) { // Only count substantial words
                    wordCounts[word] = (wordCounts[word] || 0) + 1;
                }
            });
        });
    });
    
    // Sort and return top recurring terms
    return Object.entries(wordCounts)
        .filter(([word, count]) => count > 2)
        .sort((a, b) => b[1] - a[1])
        .slice(0, 10);
}

// Generate word frequency section
function generateWordFrequencySection(wordFrequency) {
    if (wordFrequency.length === 0) return '';
    
    let html = `
        <div style="margin-top: 25px; padding: 20px; background: var(--secondary-color); border-radius: 8px;">
            <h3 style="color: var(--primary-dark); margin-bottom: 15px;">ðŸ”¤ Key Terms in Revisions</h3>
            <p style="margin-bottom: 10px; color: #666;">Frequently added or modified terms (may indicate focus areas):</p>
            <div style="display: flex; flex-wrap: wrap; gap: 10px;">
    `;
    
    wordFrequency.forEach(([word, count]) => {
        html += `
            <span style="
                background: white;
                padding: 5px 12px;
                border-radius: 20px;
                border: 1px solid var(--primary-color);
                color: var(--primary-dark);
                font-size: 0.9rem;
            ">
                <strong>${word}</strong> (${count}Ã—)
            </span>
        `;
    });
    
    html += '</div></div>';
    return html;
}

// Update the main generateTableView function to use the enhanced version
function generateTableView(analysis) {
    return generateEnhancedTableView(analysis);
}

// Also enhance the detailed view
// Better version with data attribute for count
function generateDetailedView(analysis) {
    let html = '<div class="detail-list">';
    
    const categories = [
        { key: 'micro', label: 'Micro Changes', class: 'micro' },
        { key: 'small', label: 'Small Changes', class: 'small' },
        { key: 'medium', label: 'Medium Changes', class: 'medium' },
        { key: 'large', label: 'Large Changes', class: 'large' },
        { key: 'massive', label: 'Massive Changes', class: 'massive' }
    ];
    
    const types = [
        { key: 'additions', label: 'Additions', class: 'addition' },
        { key: 'deletions', label: 'Deletions', class: 'deletion' }
    ];
    
    types.forEach(type => {
        let typeHtml = `<div class="revision-category">
            <div class="category-title">${type.label}</div>`;
        let hasContent = false;
        
        categories.forEach(cat => {
            const items = analysis[type.key][cat.key];
            if (items.length > 0) {
                hasContent = true;
                
                // Generate unique ID for this section
                const sectionId = `${type.key}-${cat.key}-${Math.random().toString(36).substr(2, 9)}`;
                
                typeHtml += `
                    <h4 style="margin-top: 15px; color: var(--primary-dark);">
                        ${cat.label} (${items.length} changes, ${items.reduce((sum, item) => sum + item.wordCount, 0)} words)
                    </h4>
                `;
                
                // Show first 5 items
                items.slice(0, 5).forEach((item, index) => {
                    typeHtml += generateRevisionItem(item, index, items.length, type.class);
                });
                
                // If more than 5 items, add hidden items and "Show More" button
                if (items.length > 5) {
                    const remainingCount = items.length - 5;
                    
                    typeHtml += `<div id="${sectionId}-hidden" style="display: none;">`;
                    
                    items.slice(5).forEach((item, index) => {
                        typeHtml += generateRevisionItem(item, index + 5, items.length, type.class);
                    });
                    
                    typeHtml += `</div>`;
                    
                    typeHtml += `
                        <button 
                            onclick="toggleRevisionSection('${sectionId}', ${remainingCount})" 
                            id="${sectionId}-btn"
                            style="
                                background: var(--primary-color);
                                color: white;
                                border: none;
                                border-radius: 20px;
                                padding: 8px 16px;
                                font-size: 0.9rem;
                                font-weight: 600;
                                cursor: pointer;
                                margin: 10px 0;
                                transition: var(--transition-standard);
                            "
                            onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 12px rgba(87, 6, 140, 0.3)'"
                            onmouseout="this.style.transform=''; this.style.boxShadow=''"
                        >
                            Show All (${remainingCount} more)
                        </button>
                    `;
                }
            }
        });
        
        typeHtml += '</div>';
        
        if (hasContent) {
            html += typeHtml;
        }
    });
    
    html += '</div>';
    return html;
}


// Tutorial System for First-Time Users - IMPROVED POSITIONING
class DiffTutorial {
    constructor() {
        this.currentStep = 0;
        this.steps = [
            {
                title: "Welcome to the Revision Viewer! ðŸ‘‹",
                content: "This tool shows you exactly what changed between drafts. Let me give you a quick tour!",
                position: "center",
                showNext: true,
                showSkip: true
            },
            {
                title: "Color-Coded Changes",
                content: "Green highlights show text that was added. Red highlights show text that was deleted. The legend at the top explains the color coding.",
                target: ".diff-legend",
                position: "below",
                showNext: true,
                showSkip: true
            },
            {
                title: "Click to Annotate ðŸ“",
                content: "Click on any highlighted change (green or red) to add your own notes about why you made that revision. This helps you reflect on your writing process!",
                findFirstChange: true, // Special flag to find first visible change
                position: "above",
                showNext: true,
                showSkip: true
            },
            {
                title: "View Your Annotations",
                content: "Click the 'View Annotations' button to see all your revision notes in one place. You can also generate a report and export as PDF!",
                target: "#viewAnnotationsBtn",
                position: "above",
                showNext: false,
                showSkip: false,
                finalStep: true
            }
        ];
    }

    hasSeenTutorial() {
        return localStorage.getItem('revisionToolTutorialComplete') === 'true';
    }

    markComplete() {
        localStorage.setItem('revisionToolTutorialComplete', 'true');
    }

    start() {
        if (this.hasSeenTutorial()) return;
        this.currentStep = 0;
        this.showStep();
    }

    showStep() {
        const step = this.steps[this.currentStep];
        
        // Create overlay
        const overlay = document.createElement('div');
        overlay.className = 'tutorial-overlay active';
        overlay.id = 'tutorialOverlay';
        document.body.appendChild(overlay);
        
        // Find target element
        let targetElement = null;
        if (step.findFirstChange) {
            // Find first visible change in the viewport
            targetElement = this.findFirstVisibleChange();
        } else if (step.target) {
            targetElement = document.querySelector(step.target);
        }
        
        // Create tooltip
        const tooltip = this.createTooltip(step);
        document.body.appendChild(tooltip);
        
        // Highlight target if found
        if (targetElement) {
            this.highlightElement(targetElement);
        }
        
        // Position tooltip AFTER it's in DOM so we can measure it
        requestAnimationFrame(() => {
            this.positionTooltip(tooltip, step, targetElement);
        });
    }

    findFirstVisibleChange() {
        const changes = document.querySelectorAll('.panel-content .addition, .panel-content .deletion');
        
        for (let change of changes) {
            const rect = change.getBoundingClientRect();
            // Check if in viewport
            if (rect.top >= 0 && rect.top < window.innerHeight - 200) {
                return change;
            }
        }
        
        // If none in viewport, return first one
        return changes[0];
    }

    createTooltip(step) {
        const tooltip = document.createElement('div');
        tooltip.className = 'tutorial-tooltip';
        tooltip.id = 'tutorialTooltip';
        
        let buttonsHtml = '';
        if (step.showNext) {
            buttonsHtml += `<button class="tutorial-btn tutorial-btn-primary" id="tutorialNext">Next</button>`;
        }
        if (step.finalStep) {
            buttonsHtml += `<button class="tutorial-btn tutorial-btn-primary" id="tutorialDone">Got it!</button>`;
        }
        if (step.showSkip) {
            buttonsHtml += `<button class="tutorial-btn tutorial-btn-secondary" id="tutorialSkip">Skip Tutorial</button>`;
        }
        
        tooltip.innerHTML = `
            ${this.currentStep > 0 ? `<div class="tutorial-step-indicator">Step ${this.currentStep + 1} of ${this.steps.length}</div>` : ''}
            <h3>${step.title}</h3>
            <p>${step.content}</p>
            <div class="tutorial-tooltip-buttons">
                ${buttonsHtml}
            </div>
        `;
        
        // Add event listeners
        setTimeout(() => {
            const nextBtn = document.getElementById('tutorialNext');
            const skipBtn = document.getElementById('tutorialSkip');
            const doneBtn = document.getElementById('tutorialDone');
            
            if (nextBtn) nextBtn.onclick = () => this.nextStep();
            if (skipBtn) skipBtn.onclick = () => this.skip();
            if (doneBtn) doneBtn.onclick = () => this.complete();
        }, 0);
        
        return tooltip;
    }

    highlightElement(element) {
        if (!element) return;
        
        // Scroll element into view if needed
        element.scrollIntoView({ behavior: 'smooth', block: 'center' });
        
        setTimeout(() => {
            const rect = element.getBoundingClientRect();
            const highlight = document.createElement('div');
            highlight.className = 'tutorial-highlight';
            highlight.id = 'tutorialHighlight';
            highlight.style.left = `${rect.left - 5}px`;
            highlight.style.top = `${rect.top - 5}px`;
            highlight.style.width = `${rect.width + 10}px`;
            highlight.style.height = `${rect.height + 10}px`;
            
            document.body.appendChild(highlight);
        }, 300);
    }

    positionTooltip(tooltip, step, targetElement) {
        const viewportWidth = window.innerWidth;
        const viewportHeight = window.innerHeight;
        const tooltipRect = tooltip.getBoundingClientRect();
        const margin = 20;
        
        // Center position (no target)
        if (step.position === 'center' || !targetElement) {
            const left = (viewportWidth - tooltipRect.width) / 2;
            const top = (viewportHeight - tooltipRect.height) / 2;
            
            tooltip.style.left = `${Math.max(margin, left)}px`;
            tooltip.style.top = `${Math.max(margin, top)}px`;
            tooltip.style.transform = 'none';
            return;
        }
        
        const targetRect = targetElement.getBoundingClientRect();
        let left, top;
        
        // Position relative to target
        if (step.position === 'below') {
            // Center horizontally, below target
            left = targetRect.left + (targetRect.width / 2) - (tooltipRect.width / 2);
            top = targetRect.bottom + 20;
            
            // Keep on screen horizontally
            if (left < margin) left = margin;
            if (left + tooltipRect.width > viewportWidth - margin) {
                left = viewportWidth - tooltipRect.width - margin;
            }
            
            // If tooltip would go off bottom, position above instead
            if (top + tooltipRect.height > viewportHeight - margin) {
                top = targetRect.top - tooltipRect.height - 20;
            }
            
        } else if (step.position === 'above') {
            // Center horizontally, above target
            left = targetRect.left + (targetRect.width / 2) - (tooltipRect.width / 2);
            top = targetRect.top - tooltipRect.height - 20;
            
            // Keep on screen horizontally
            if (left < margin) left = margin;
            if (left + tooltipRect.width > viewportWidth - margin) {
                left = viewportWidth - tooltipRect.width - margin;
            }
            
            // If tooltip would go off top, position below instead
            if (top < margin) {
                top = targetRect.bottom + 20;
            }
        }
        
        // Final boundary check
        left = Math.max(margin, Math.min(left, viewportWidth - tooltipRect.width - margin));
        top = Math.max(margin, Math.min(top, viewportHeight - tooltipRect.height - margin));
        
        tooltip.style.left = `${left}px`;
        tooltip.style.top = `${top}px`;
        tooltip.style.transform = 'none';
    }

    cleanup() {
        const overlay = document.getElementById('tutorialOverlay');
        const tooltip = document.getElementById('tutorialTooltip');
        const highlight = document.getElementById('tutorialHighlight');
        
        if (overlay) overlay.remove();
        if (tooltip) tooltip.remove();
        if (highlight) highlight.remove();
    }

    nextStep() {
        this.cleanup();
        this.currentStep++;
        
        if (this.currentStep < this.steps.length) {
            setTimeout(() => this.showStep(), 100);
        } else {
            this.complete();
        }
    }

    skip() {
        this.cleanup();
        this.markComplete();
    }

    complete() {
        this.cleanup();
        this.markComplete();
    }
}

// Initialize tutorial when a diff panel is first shown
let tutorialInstance = null;

function startTutorialIfNeeded() {
    // Only start if we're on a diff panel
    const currentPanel = document.querySelector('.comparison-slider').children[currentPosition];
    if (!currentPanel || !currentPanel.classList.contains('diff-panel')) return;
    
    // Only start once
    if (tutorialInstance) return;
    
    // Wait for annotations to be set up and DOM to settle
    setTimeout(() => {
        tutorialInstance = new DiffTutorial();
        tutorialInstance.start();
    }, 800);
}


function startTutorialIfNeeded() {
    // Only start if we're on a diff panel
    const currentPanel = document.querySelector('.comparison-slider').children[currentPosition];
    if (!currentPanel || !currentPanel.classList.contains('diff-panel')) return;
    
    // Only start once
    if (tutorialInstance) return;
    
    // Create and start tutorial
    tutorialInstance = new DiffTutorial();
    
    // Small delay to ensure DOM is ready
    setTimeout(() => {
        tutorialInstance.start();
    }, 500);
}

// Landing Page Tutorial System
class LandingPageTutorial {
    constructor() {
        this.currentStep = 0;
        this.steps = [
            {
                title: "Welcome!",
                content: "Expert writers often say that writing is 99 percent revision. That's not just a comment on how difficult writing can be, but also suggests how writing skills are <i> actually </i> developed. <br> <br> At EWP, we believe people improve as writers when they learn to revise more holistically, more strategically, and more often.",
                position: "center",
                showNext: true,
                showSkip: true
            },
            {
                title: "About this site",
                content: "This site draws your attention to the longest and most important part of the writing process: revision. <br> <br> We invite you to reflect upon the nature, scope, goal, and impacts of your changes. Because more deliberate writers are stronger writers.",
                position: "center",
                showNext: true,
                showSkip: true
            },
            {
                title: "A Research-Backed Approach",
                content: "In a landmark study, researchers compared the revision habits of novice and expert writers. Their findings revealed two fundamentally different approaches to revision.",
                citation: `Sommers, Nancy. "Revision Strategies of Student Writers and Experienced Adult Writers." <i>College Composition and Communication</i>, vol. 31, no. 4, 1980, pp. 378â€“88.<br><br>`,
                position: "center",
                showNext: true,
                showSkip: true
            },
            {
                title: "What 'Revision' Means to Novice Writers",
                content: "For novices, revising involves mostly small changes like word substitutions or addressing mechanical errors. This minimalist approach reflects a belief that writing is primarily a tool for expression, requiring little revision.",
                citation: `Sommers, Nancy. "Revision Strategies of Student Writers and Experienced Adult Writers." <i>College Composition and Communication</i>, vol. 31, no. 4, 1980, pp. 378â€“88.<br><br>`,
                position: "center",
                showNext: true,
                showSkip: true
            },
            {
                title: "What 'Revision' Means to Expert Writers",
                content: "For experts, revision means much more. It can include adding, deleting, or rewriting entire paragraphs, introducing new evidence, or transforming initial assumptions. <br><br> Fundamentally, these practices reflect a radically different view of writing: It's not just a tool for expressing our best ideas, but also for generating, testing, and refining them.",
                citation: `Sommers, Nancy. "Revision Strategies of Student Writers and Experienced Adult Writers." <i>College Composition and Communication</i>, vol. 31, no. 4, 1980, pp. 378â€“88.<br><br>`,
                position: "center",
                showNext: true,
                showSkip: true
            },
            {
                title: "How We Aim to Help",
                content: "By examining the nature and scope of revisions, this tool helps you move beyond surface changes and begin utilizing writing to discover, test, and refine your best ideas.",
                position: "center",
                showNext: true,
                showSkip: true
            },
            {
                title: "Getting Started: Add Your Drafts",
                content: "Upload files by clicking here or dragging and dropping. Or use the 'Paste Text' tab to simply copy and paste your drafts directly.",
                target: ".file-input-container",
                position: "below",
                showNext: true,
                showSkip: true
            },
          
            {
                title: "Explore Example Essays",
                content: "Not ready to upload your own work? The Example Essays tab features real student revision processes from NYU's Mercer Street journal. You can see how exceptional undergraduate writers developed their ideas through multiple drafts.",
                target: "#examplesTab",
                position: "below",
                showNext: false,
                finalStep: true
            }
        ];
    }

    hasSeenTutorial() {
        return localStorage.getItem('landingPageTutorialComplete') === 'true';
    }

    markComplete() {
        localStorage.setItem('landingPageTutorialComplete', 'true');
    }

    start() {
        if (this.hasSeenTutorial()) return;
        
        // Small delay to ensure page is loaded
        setTimeout(() => {
            this.currentStep = 0;
            this.showStep();
        }, 500);
    }

    showStep() {
        const step = this.steps[this.currentStep];
        
        // Create or get overlay
        let overlay = document.getElementById('landingTutorialOverlay');
        if (!overlay) {
            overlay = document.createElement('div');
            overlay.className = 'tutorial-overlay active';
            overlay.id = 'landingTutorialOverlay';
            document.body.appendChild(overlay);
        }
        
        // Remove old highlight if exists
        const oldHighlight = document.getElementById('landingTutorialHighlight');
        if (oldHighlight) oldHighlight.remove();
        
        // Find target element
        let targetElement = null;
        if (step.target) {
            targetElement = document.querySelector(step.target);
        }
        
        // Create or update tooltip
        let tooltip = document.getElementById('landingTutorialTooltip');
        if (!tooltip) {
            tooltip = document.createElement('div');
            tooltip.className = 'tutorial-tooltip';
            tooltip.id = 'landingTutorialTooltip';
            document.body.appendChild(tooltip);
        }
        
        // Update tooltip content
        this.updateTooltipContent(tooltip, step);
        
        // Highlight target if found
        if (targetElement) {
            this.highlightElement(targetElement);
        }
        
        // Position tooltip
        requestAnimationFrame(() => {
            this.positionTooltip(tooltip, step, targetElement);
        });
    }

    updateTooltipContent(tooltip, step) {
        let buttonsHtml = '';
        
        // Add Back button (except on first step)
        if (this.currentStep > 0) {
            buttonsHtml += `<button class="tutorial-btn tutorial-btn-secondary" id="landingTutorialBack">Back</button>`;
        }
        
        if (step.showNext) {
            buttonsHtml += `<button class="tutorial-btn tutorial-btn-primary" id="landingTutorialNext">Next</button>`;
        }
        if (step.finalStep) {
            buttonsHtml += `<button class="tutorial-btn tutorial-btn-primary" id="landingTutorialDone">Get Started</button>`;
        }
        if (step.showSkip) {
            buttonsHtml += `<button class="tutorial-btn tutorial-btn-secondary" id="landingTutorialSkip">Skip Tour</button>`;
        }
        
        // Add citation if present
        const citationHtml = step.citation ? 
            `<div style="margin-top: 20px; padding-top: 15px; border-top: 1px solid #e0e0e0; font-size: 0.75rem; line-height: 1.4; color: #666; text-align: left;">${step.citation}</div>` : '';
        
        tooltip.innerHTML = `
            <div class="tutorial-step-indicator">Step ${this.currentStep + 1} of ${this.steps.length}</div>
            <h3>${step.title}</h3>
            <p>${step.content}</p>
            ${citationHtml}
            <div class="tutorial-tooltip-buttons">
                ${buttonsHtml}
            </div>
        `;
        
        // Re-add event listeners after content update
        setTimeout(() => {
            const backBtn = document.getElementById('landingTutorialBack');
            const nextBtn = document.getElementById('landingTutorialNext');
            const skipBtn = document.getElementById('landingTutorialSkip');
            const doneBtn = document.getElementById('landingTutorialDone');
            
            if (backBtn) backBtn.onclick = () => this.previousStep();
            if (nextBtn) nextBtn.onclick = () => this.nextStep();
            if (skipBtn) skipBtn.onclick = () => this.skip();
            if (doneBtn) doneBtn.onclick = () => this.complete();
        }, 0);
    }

    previousStep() {
        if (this.currentStep > 0) {
            this.currentStep--;
            this.showStep();
        }
    }

    nextStep() {
        this.currentStep++;
        
        if (this.currentStep < this.steps.length) {
            // Just update the step without cleanup
            this.showStep();
        } else {
            this.complete();
        }
    }

    highlightElement(element) {
        if (!element) return;
        
        const rect = element.getBoundingClientRect();
        const highlight = document.createElement('div');
        highlight.className = 'tutorial-highlight';
        highlight.id = 'landingTutorialHighlight';
        highlight.style.left = `${rect.left - 5}px`;
        highlight.style.top = `${rect.top - 5}px`;
        highlight.style.width = `${rect.width + 10}px`;
        highlight.style.height = `${rect.height + 10}px`;
        
        document.body.appendChild(highlight);
    }

    positionTooltip(tooltip, step, targetElement) {
        const viewportWidth = window.innerWidth;
        const viewportHeight = window.innerHeight;
        const tooltipRect = tooltip.getBoundingClientRect();
        const margin = 20;
        
        // Center position (no target)
        if (step.position === 'center' || !targetElement) {
            const left = (viewportWidth - tooltipRect.width) / 2;
            const top = (viewportHeight - tooltipRect.height) / 2;
            
            tooltip.style.left = `${Math.max(margin, left)}px`;
            tooltip.style.top = `${Math.max(margin, top)}px`;
            tooltip.style.transform = 'none';
            return;
        }
        
        const targetRect = targetElement.getBoundingClientRect();
        let left, top;
        
        // Position relative to target
        if (step.position === 'below') {
            left = targetRect.left + (targetRect.width / 2) - (tooltipRect.width / 2);
            top = targetRect.bottom + 20;
            
            if (left < margin) left = margin;
            if (left + tooltipRect.width > viewportWidth - margin) {
                left = viewportWidth - tooltipRect.width - margin;
            }
            
            if (top + tooltipRect.height > viewportHeight - margin) {
                top = targetRect.top - tooltipRect.height - 20;
            }
            
        } else if (step.position === 'above') {
            left = targetRect.left + (targetRect.width / 2) - (tooltipRect.width / 2);
            top = targetRect.top - tooltipRect.height - 20;
            
            if (left < margin) left = margin;
            if (left + tooltipRect.width > viewportWidth - margin) {
                left = viewportWidth - tooltipRect.width - margin;
            }
            
            if (top < margin) {
                top = targetRect.bottom + 20;
            }
        }
        
        left = Math.max(margin, Math.min(left, viewportWidth - tooltipRect.width - margin));
        top = Math.max(margin, Math.min(top, viewportHeight - tooltipRect.height - margin));
        
        tooltip.style.left = `${left}px`;
        tooltip.style.top = `${top}px`;
        tooltip.style.transform = 'none';
    }

    nextStep() {
        this.currentStep++;
        
        if (this.currentStep < this.steps.length) {
            // Just update the step without cleanup
            this.showStep();
        } else {
            this.complete();
        }
    }

    cleanup() {
        const overlay = document.getElementById('landingTutorialOverlay');
        const tooltip = document.getElementById('landingTutorialTooltip');
        const highlight = document.getElementById('landingTutorialHighlight');
        
        if (overlay) overlay.remove();
        if (tooltip) tooltip.remove();
        if (highlight) highlight.remove();
    }

    skip() {
        this.cleanup();
        this.markComplete();
    }

    complete() {
        this.cleanup();
        this.markComplete();
    }
}

// Initialize landing page tutorial
let landingTutorial = null;


// Call this in your existing updateSliderPosition function
// Add this at the end of updateSliderPosition(), just before the final closing brace:

// Helper function to generate individual revision item HTML
function generateRevisionItem(item, index, total, className) {
    return `
        <div class="revision-item ${className}" style="margin: 10px 0;">
            <div style="font-size: 0.85rem; color: #999; margin-bottom: 5px;">
                Change ${index + 1} of ${total}
            </div>
            <div class="revision-text">
                "${item.text}"
            </div>
            <div style="font-size: 0.8rem; color: #666; margin-top: 5px;">
                ${item.wordCount} word${item.wordCount !== 1 ? 's' : ''}, ${item.charCount} character${item.charCount !== 1 ? 's' : ''}
            </div>
        </div>
    `;
}

window.toggleRevisionSection = function(sectionId, count) {
    const hiddenSection = document.getElementById(`${sectionId}-hidden`);
    const button = document.getElementById(`${sectionId}-btn`);
    
    if (hiddenSection.style.display === 'none') {
        // Expand
        hiddenSection.style.display = 'block';
        button.textContent = 'Show Less';
    } else {
        // Collapse
        hiddenSection.style.display = 'none';
        button.textContent = `Show All (${count} more)`;
    }
};



// Replace the existing generateRevisionReport function with this updated version:
function generateRevisionReport() {
    const currentPanel = document.querySelector('.comparison-slider').children[currentPosition];
    
    // Check if current panel is a diff panel
    if (!currentPanel || !currentPanel.classList.contains('diff-panel')) {
        alert('Please navigate to a changes view (showing differences between drafts) to generate a report.');
        return;
    }
    
    const diffContent = currentPanel.querySelector('.panel-content').innerHTML;
    const analysis = analyzeRevisions(diffContent);
    
    // Show modal instead of container
    const modal = document.getElementById('revisionReportModal');
    if (modal) {
        modal.style.display = 'block';
        
        // Generate initial table view
        document.getElementById('reportContent').innerHTML = generateTableView(analysis);
    }
}


    

    </script>
</body>
</html>
